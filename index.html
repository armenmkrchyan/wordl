<!DOCTYPE html>
<html lang="hy">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0"/>
  <title>Wordle ðŸ‡¦ðŸ‡²</title>
  <style>
    /* --- Global Reset & Box Sizing --- */
    html {
        box-sizing: border-box;
        height: 100%; /* Ensure html takes full height */
        overflow-y: auto; /* Allow scrolling if content exceeds viewport */
    }
    *, *:before, *:after {
        box-sizing: inherit;
    }

    html, body {
        min-height: 100%; /* Ensure body can fill viewport */
        margin: 0;
        padding: 0; /* Ensure no default padding */
    }
    body {
      font-family: sans-serif;
      display: flex;
      flex-direction: column; /* Stack children vertically */
      align-items: center; /* Center children horizontally */
      transition: background 0.3s, color 0.3s;
      background-color: var(--bg-color, #fff);
      color: var(--text-color, #000);
    }

    :root {
        --bg-color: #fff;
        --text-color: #000;
        --tile-border-empty: #aaa;
        --tile-border-filled: #666;
        --key-bg: #d3d6da;
        --key-text: #1a1a1b;
        --correct-bg: #538d4e;
        --present-bg: #b59f3b;
        --absent-bg: #3a3a3c;
        --delete-key-bg: #dc3545; /* Red */
        --enter-key-bg: #538d4e; /* Green */
        --tile-text-light: #000;
        --tile-text-dark: #fff;
        --link-color: #007bff;
         /* Added for modal */
        --modal-bg: #fff;
        --modal-border: #ccc;
        --modal-text: #000;
        --list-item-hover-bg: #eee;
    }

     .dark {
        --bg-color: #121213;
        --text-color: #fff;
        --tile-border-empty: #3a3a3c;
        --tile-border-filled: #565758;
        --key-bg: #818384;
        --key-text: #dadce0;
        --tile-text-light: #fff;
        --link-color: #64b5f6;
        /* Added for modal dark mode */
        --modal-bg: #222;
        --modal-border: #555;
        --modal-text: #fff;
        --list-item-hover-bg: #333;
    }


    .main-content {
        flex: 1 1 auto; /* Allows growing and shrinking, takes available space */
        width: 100%;
        display: flex;
        flex-direction: column; /* Stack children vertically */
        align-items: center; /* Center children horizontally */
        max-width: 550px; /* Max width for the main content area */
        margin-left: auto;
        margin-right: auto;
        padding-left: 5px;
        padding-right: 5px;
        padding-bottom: 10px; /* Added some padding to the bottom of main-content */
        /* Ensure main-content aligns children even if they don't fill the width */
        align-self: center;
        position: relative; /* Needed for absolute positioning of child buttons */
    }

    h1 {
      margin-top: 10px;
      margin-bottom: 2px;
      font-size: 1.5rem;
      white-space: nowrap;
      display: flex; /* Use flex to align items within h1 */
      align-items: center;
      gap: 8px; /* Space between title and number/flag */
    }
     h1 img {
         height: 0.7em;
         vertical-align: middle;
     }
    /* Style for the game number */
    #game-number {
        font-size: 0.8em; /* Slightly smaller than main title */
        font-weight: normal; /* Not as bold as the title */
        cursor: pointer; /* Indicate it's clickable */
        text-decoration: underline; /* Indicate it's a link/clickable */
        color: inherit; /* Inherit color from h1 */
    }
     #game-number:hover {
         color: var(--link-color); /* Highlight on hover */
     }


    .subtitle {
        font-size: 0.9rem;
        color: #777;
        margin-top: 0;
        margin-bottom: 5px;
    }
    .dark .subtitle {
        color: #aaa;
    }
     .subtitle a {
        color: inherit; /* Inherit color from subtitle */
     }
     .subtitle a:hover {
        text-decoration: underline; /* Keep underline on hover */
     }


    .board-container {
        display: flex;
        justify-content: center;
        align-items: center;
        width: 100%; /* Board container takes full width of main-content */
        /* Removed max-width here - JS will control it */
        /* max-width: 350px; */
        margin: 8px 0; /* Keep vertical margins */
        flex: 1 1 auto; /* Allow board container to grow/shrink within main-content */
        min-height: 0; /* Allow flex item to shrink below content size */
    }

    .board {
      display: grid;
      grid-template-rows: repeat(6, 1fr);
      grid-gap: 4px;
      width: 100%; /* Board takes full width of its container */
      /* The height will be determined by width due to tile aspect ratio */
    }

    .row {
        display: grid;
        grid-template-columns: repeat(5, 1fr);
        grid-gap: 4px;
    }

    .tile {
      width: 100%;
      aspect-ratio: 1 / 1;
      border: 2px solid var(--tile-border-empty);
      font-size: clamp(1.5rem, 6vw, 2rem);
      font-weight: bold;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      text-transform: lowercase;
      color: var(--tile-text-light);
      background-color: var(--bg-color);
      transition: background-color 0.3s, border-color 0.3s;
    }
    .tile > div {
        display: flex;
        align-items: center;
        justify-content: center;
        width: 100%;
        height: 100%;
        color: inherit;
    }
    .tile.filled {
        border-color: var(--tile-border-filled);
    }
    .tile.correct { background-color: var(--correct-bg); color: var(--tile-text-dark); border-color: var(--correct-bg); }
    .tile.present { background-color: var(--present-bg); color: var(--tile-text-dark); border-color: var(--present-bg); }
    .tile.absent { background-color: var(--absent-bg); color: var(--tile-text-dark); border-color: var(--absent-bg); }

    #keyboard {
      flex-shrink: 0; /* Prevent keyboard from shrinking */
      width: 100%;
      max-width: 550px; /* Align keyboard with main content */
      margin-left: auto;
      margin-right: auto;
      display: flex;
      flex-direction: column;
      gap: 4px;
      padding: 0 3px;
      margin-top: 5px;
      margin-bottom: 20px; /* Changed bottom margin to 20px */
      align-self: center; /* Center keyboard horizontally */
    }

    #keyboard-top-row {
        display: grid;
        /* Make Enter and Delete columns equal size */
        grid-template-columns: 1fr 1fr;
        gap: 3px;
    }

    #keyboard-main-grid {
        display: grid;
        /* Default to Alphabetical grid columns, overridden by data attribute */
        grid-template-columns: repeat(8, 1fr);
        gap: 3px;
    }

    /* Specific grid columns for Phonetic layout main grid */
    body[data-keyboard-layout="phonetic"] #keyboard-main-grid {
         grid-template-columns: repeat(10, 1fr); /* Phonetic layout rows have 10 slots */
         gap: 3px; /* Maintain consistent gap */
    }

     /* Placeholder key styling - visible only in layouts that need it for alignment */
     .key.placeholder {
        background: transparent;
        pointer-events: none;
        border-color: transparent;
        visibility: hidden; /* Hidden by default */
     }

    body[data-keyboard-layout="phonetic"] #keyboard-main-grid .key.placeholder {
        visibility: visible; /* Make placeholder visible in phonetic layout */
        background: rgba(0,0,0,0.03); /* Subtle background */
     }


    .key {
      min-height: 40px;
      /* Adjusted font-size clamp to allow single letters to be larger */
      font-size: clamp(1.2rem, 5vw, 1.8rem);
      font-weight: bold;
      border: 3px solid transparent;
      border-radius: 4px;
      background-color: var(--key-bg);
      color: var(--key-text);
      cursor: pointer;
      transition: background-color 0.2s, color 0.2s, border-color 0.2s;
      display: flex;
      justify-content: center;
      align-items: center;
      user-select: none;
      touch-action: manipulation;
      text-transform: lowercase;
      padding: 0;
      min-width: 0;
    }
    .key:hover {
        filter: brightness(90%);
    }

    .key.enter,
    .key.delete {
      /* Increased font size for Enter/Delete keys */
      font-size: clamp(0.9rem, 3.5vw, 1.2rem); /* Adjusted clamp values */
      color: white;
      border-width: 3px;
      border-style: solid;
    }
    .key.enter {
        background-color: var(--enter-key-bg);
        border-color: var(--enter-key-bg);
        white-space: nowrap;
    }
    .key.delete {
         background-color: var(--delete-key-bg);
         border-color: var(--delete-key-bg);
         white-space: nowrap;
    }


    .key.correct {
      background-color: var(--correct-bg);
      color: var(--tile-text-dark);
      border-color: transparent;
    }
    .key.present {
      background-color: var(--present-bg);
      color: var(--tile-text-dark);
      border-color: transparent;
    }
    .key.absent {
      background-color: var(--absent-bg);
      color: var(--tile-text-dark);
      border-color: transparent;
    }

    .key.correct.has-present {
        border-width: 3px;
        border-style: solid;
        /* Using a different color for visibility, you might adjust this */
        border-color: #ffff00; /* Example: Yellow border */
    }


    .message-container {
        position: fixed;
        top: 70px;
        left: 50%;
        transform: translateX(-50%);
        min-height: 30px;
        z-index: 10;
        width: 90%;
        max-width: 350px;
    }
    .message {
      text-align: center;
      font-size: 1em;
      margin-top: 0.5rem;
      padding: 8px 10px;
      font-weight: bold;
      background-color: #333;
      color: white;
      border-radius: 5æ ·çš„ 5px;
      visibility: hidden;
      opacity: 0;
      transition: visibility 0s 1.5s, opacity 1.5s linear;
      white-space: normal;
      word-wrap: break-word;
    }
     .message.show {
        visibility: visible;
        opacity: 1;
        transition: opacity 0.3s linear;
     }

    /* Modal Styles */
    .modal-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.5);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 100;
        visibility: hidden;
        opacity: 0;
        transition: visibility 0s 0.3s, opacity 0.3s ease;
    }

    .modal-overlay.visible {
        visibility: visible;
        opacity: 1;
        transition-delay: 0s;
    }

    .modal-content {
        background-color: var(--modal-bg);
        color: var(--modal-text);
        padding: 20px;
        border-radius: 8px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
        max-width: 90%;
        max-height: 90%;
        overflow-y: auto; /* Add scroll for long lists */
        position: relative;
        width: 300px; /* Adjust modal width as needed */
        display: flex;
        flex-direction: column;
    }
    .dark .modal-content {
        background-color: var(--modal-bg);
        color: var(--modal-text);
    }

    .modal-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 15px;
        padding-bottom: 10px;
        border-bottom: 1px solid var(--modal-border);
    }
    .modal-header h3 {
        margin: 0;
        font-size: 1.2rem;
    }

    .modal-close {
        background: none;
        border: none;
        font-size: 1.5rem;
        cursor: pointer;
        color: inherit;
        padding: 0;
    }
    .modal-close:hover {
        opacity: 0.7;
    }

    #previous-games-list {
        list-style: none;
        padding: 0;
        margin: 0;
    }

    #previous-games-list li {
        padding: 8px 0;
        border-bottom: 1px solid var(--modal-border);
        cursor: pointer;
        transition: background-color 0.2s ease;
    }
    #previous-games-list li:last-child {
        border-bottom: none;
    }
     #previous-games-list li:hover {
         background-color: var(--list-item-hover-bg);
     }
    #previous-games-list li span {
        font-weight: bold;
        margin-right: 10px;
    }


    /* Theme and Layout Button Positioning */
    /* Position these absolutely within the main-content area */
    .main-content > #toggle-theme {
      position: absolute;
      top: 10px;
      right: 10px; /* Position Theme button on the right */
      margin-bottom: 0; /* Remove margin as position is absolute */
      padding: 6px 10px;
      font-size: 0.9rem;
      border-radius: 5px;
      cursor: pointer;
      border: 1px solid #ccc;
      background-color: #eee;
      color: #333;
      z-index: 20;
    }
    .dark .main-content > #toggle-theme {
        background-color: #333;
        color: white;
        border-color: #555;
    }

    .main-content > #toggle-layout {
      position: absolute;
      top: 10px;
      left: 10px; /* Position Layout button on the left */
      margin-bottom: 0; /* Remove margin as position is absolute */
      padding: 6px 10px;
      font-size: 0.9rem;
      border-radius: 5px;
      cursor: pointer;
      border: 1px solid #ccc;
      background-color: #eee;
      color: #333;
      z-index: 20;
       min-width: 80px; /* Added min-width to prevent text wrap */
       text-align: center; /* Center text in button */
    }
     .dark .main-content > #toggle-layout {
        background-color: #333;
        color: white;
        border-color: #555;
    }


    @keyframes shake {
      0%, 100% { transform: translateX(0); }
      10%, 30%, 50%, 70%, 90% { transform: translateX(-5px); }
      20%, 40%, 60%, 80% { transform: translateX(5px); }
    }
    .shake { animation: shake 0.6s ease-in-out; }


    /* Media Query for very small/short screens */
    @media (max-width: 340px), (max-height: 600px) {
        h1 {
            font-size: 1.3rem; /* Further reduce */
            margin-top: 8px;
        }
        h1 #game-number {
            font-size: 0.9em; /* Adjust game number size */
        }
        .subtitle {
            margin-bottom: 3px;
        }
         .main-content {
            padding-bottom: 5px; /* Reduce bottom padding for very short screens */
         }
        .board-container {
            margin: 5px 0;
            /* max-width controlled by JS */
        }
        .board, .row {
            grid-gap: 3px; /* Further reduce */
        }
        #keyboard {
            gap: 3px;
            padding: 0 2px;
            margin-top: 3px;
            margin-bottom: 15px; /* Adjusted bottom margin for small screens */
        }
        /* Adjust gaps/columns for smaller screens if needed, though JS might handle size */
         #keyboard-main-grid, #keyboard-top-row {
            gap: 2px; /* Further reduce default gap */
        }
        body[data-keyboard-layout="phonetic"] #keyboard-main-grid {
             grid-template-columns: repeat(10, 1fr); /* Maintain 10 columns */
             gap: 2px; /* Use the smaller gap */
        }


        .key {
            min-height: 36px; /* Further reduce */
            /* Adjusted font size for small screens */
            font-size: clamp(1rem, 3.5vw, 1.3rem); /* Adjusted clamp values */
        }
        .key.enter, .key.delete {
             /* Increased font size for Enter/Delete on small screens */
            font-size: clamp(0.8rem, 3vw, 1.1rem); /* Adjusted clamp values */
        }
        /* Adjust button positions relative to main-content padding/width */
        .main-content > #toggle-theme {
            padding: 4px 7px;
            font-size: 0.8rem;
            top: 5px;
            right: 5px; /* Maintain right position */
        }
        .main-content > #toggle-layout {
            padding: 44px 7px; /* Reduced padding */
            font-size: 0.8rem;
            top: 5px;
            left: 5px; /* Adjust position to the left */
             min-width: 70px; /* Adjust min-width */
        }
        .message-container {
            top: 60px; /* Adjust if needed */
        }
         .modal-content {
             width: 250px; /* Adjust modal width for small screens */
         }
    }

  </style>
</head>
<body>
  <div class="main-content">
      <h1>
          Wordle <img src="flag.png" alt="ðŸ‡¦ðŸ‡²">
          <span id="game-number"></span> <!-- Game Number Placeholder -->
      </h1>
      <!-- Updated subtitle to be a link -->
      <p class="subtitle">by <a href="https://www.armblog.net" target="_blank">Armen Mkrtchyan</a></p>

      <button id="toggle-theme">ðŸŒ—</button>
      <button id="toggle-layout"></button> <!-- Added Layout Toggle Button -->

      <div class="message-container">
         <div id="message" class="message"></div>
      </div>
      <div class="board-container">
         <div class="board" id="board"></div>
      </div>
  </div>
  <!-- Keyboard is now a direct child of body, AFTER main-content -->
  <div id="keyboard">
      <div id="keyboard-top-row"></div>
      <div id="keyboard-main-grid"></div>
  </div>

  <!-- Previous Games Modal -->
  <div id="previous-games-modal" class="modal-overlay">
      <div class="modal-content">
          <div class="modal-header">
              <h3>Õ†Õ¡Õ­Õ¸Ö€Õ¤ Õ­Õ¡Õ²Õ¥Ö€Õ¨</h3>
              <button class="modal-close">Ã—</button>
          </div>
          <ul id="previous-games-list">
              <!-- List items will be populated by JS -->
          </ul>
      </div>
  </div>


<script>
  const boardElement = document.getElementById('board');
  const keyboardTopRowElement = document.getElementById('keyboard-top-row');
  const keyboardMainGridElement = document.getElementById('keyboard-main-grid');
  const keyboardElement = document.getElementById('keyboard'); // Now a direct child of body
  const toggleBtnTheme = document.getElementById('toggle-theme');
  const toggleBtnLayout = document.getElementById('toggle-layout');
  const messageElement = document.getElementById('message');
  const mainContent = document.querySelector('.main-content'); // Still needed for sizing context
  const gameNumberElement = document.getElementById('game-number'); // Game number element
  const previousGamesModal = document.getElementById('previous-games-modal'); // Modal overlay
  const previousGamesListElement = document.getElementById('previous-games-list'); // Modal list
  const modalCloseButton = previousGamesModal.querySelector('.modal-close'); // Modal close button


  // --- Constants ---
  const WORD_LENGTH = 5;
  const MAX_ROWS = 6;
  const ENTER_KEY = 'Õ¨Õ¶Õ¤Õ¸Ö‚Õ¶Õ¥Õ¬';
  const DELETE_KEY = 'Õ»Õ¶Õ»Õ¥Õ¬';
  const LOCAL_STORAGE_LAYOUT_KEY = 'armenianWordleLayout';
  const LOCAL_STORAGE_PREFIX = 'armenianWordle-'; // Prefix for game state keys

  // --- Word List (Assumed 5 letters, lowercase) ---
  const WORDS = ['Ö†Õ¸Õ¿Õ¸Õ¶','Õ¶Õ¼Õ¶Õ¡Õ¯','Õ°Õ¶Õ¤Õ«Õ¯','Õ°Õ¥Õ²Õ¸Ö‚Õ¯','Õ¡Ö€Õ£Õ¸Õ¶','Õ©Ö€Õ©Õ¸Ö‚Õ¼','Õ¯Õ¡ÕµÕ¸Ö‚Õ¶','Õ¬Õ¸Ö‚Õ®Õ¸Ö‚Õ´','Õ·Õ¡ÕºÕ«Õ¯','Õ°Ö€Õ·Õ¥Õ»','Õ¨Õ¶Õ¢Õ«Õ·','Õ´Õ¥Õ¿Õ¡Õ²','Õ¡Õ¾Õ¥Õ¬Õ«','Õ¡Õ¶Õ¦Õ¥Õ¶','Õ°Õ¡Õ·Õ«Õ¾','Õ©Õ¡ÖƒÕ¸Ö€','Õ­Õ¥Õ¬Õ¡Õ¼','Õ¬Ö„Õ¾Õ¡Õ®','Õ¤Õ¡ÕµÕ¡Õ¯','ÖÕ¥Ö€Õ¥Õ¯','Õ¯Õ¿Ö€Õ¸Ö‚Õ¯','Õ¯Õ³Õ²Õ¡Õ¯','Õ¾Ö€Õ¡ÖÕ«','Ö„Õ¸Ö‚Õ¼Õ¡Õ¯','Õ¢Õ¸Ö€Õ½Õ¡','Õ®Õ¡Õ²Õ«Õ¯','Õ°Õ¡Õ¿Õ«Õ¯','Õ¶Õ«Õ°Õ¡Ö€','Õ¡Ö€Õ±Õ¡Õ¯','Õ©Ö€Õ©Õ¸Ö‚Ö€','Õ¿Õ¸Õ¯Õ¸Ö‚Õ¶','Õ¥Õ²Ö‡Õ¶Õ«','Õ½Õ¡ÕºÕ¡Õ¿','Õ¶Õ¥Õ²Õ¸Ö‚Ö','Õ¢ÕªÕ«Õ·Õ¯','Õ¸Ö‚Õ¼Õ¥Õ¶Õ«','Õ¹Õ¾Õ¥Ö€Õ©','Õ´Õ¡Õ½Õ¸Ö‚Ö€','Õ´Õ¥Õ©Õ¸Õ¤','Õ©Õ·Õ·Õ¸Ö','Ö„Õ¶Ö„Õ¸Ö‚Õ·','ÖƒÕ¥Õ©Õ¡Õ¯','Õ´Õ¥Õ¤Õ«Õ¡','Õ¯Ö€Õ¸Ö‚Õ¶Õ¯','Õ¯Õ¡Õ©Õ½Õ¡','Õ¯Õ¸Õ¡Õ¬Õ¡','Õ£Õ«Õ¿Õ¡Õ¯','Õ¯Ö€Õ¯Õ¥Õ½','Õ¾Õ¡Ö€Õ¡Õ¦','ÖƒÕ¥Õ¿Õ¸Ö‚Ö€','Õ¯Õ¿Ö€Õ«Õ³','Õ°Õ¡Õ¿Õ¸Ö‚Õ¯','Õ¯Õ¡Õ²Õ¶Õ«','ÕºÕ¡ÕºÕ«Õ¯','Õ¥Õ¬Õ¸Ö‚ÕµÕ©','Õ¡Õ¯Õ¡Õ´Õ¡','Õ¢Õ¸Ö‚ÕªÕ¸Ö‚Õ´','Õ¡Õ¶Õ¯Õ¡Õº','Õ´Õ¡Õ´Õ¸Ö‚Õ¬','Ö…Ö€Õ£Õ¡Õ¶','Õ¡Ö€Ö‡Õ¸Õ¿','Õ¤Õ¡Õ¯Õ«Õ¹','Õ©Ö‡Õ¶Õ¸Ö','ÕºÕ¡Õ¿Õ«Õ¾','Õ´Õ¥Õ¿Ö€Õ¸','Ö…Õ©ÕµÕ¡Õ¯','Õ¤Ö€Õ¡Õ­Õ¿','Õ¥Õ¼Õ¡Õ¶Õ¤','Õ¡Ö€Õ¯Õ¡Õ®','Õ¤Õ¡Õ¬Õ¡Ö€','Õ£Õ¸Ö‚Õ¬ÕºÕ¡','Õ­Ö€Õ¸Õ­Õ¿','Õ¯Õ¡Õ¸Ö‚Ö€Õ«','Ö„Õ¡Õ¶Õ¸Õ¶','Õ³Õ¡Õ²Õ¡Õ¿','Õ£Õ¶Õ¸Ö€Õ¤','ÖƒÕ­Ö€Õ¸Ö‚Õ¶','Õ¤Ö€Õ¡Õ´Õ¡','Õ¼Õ¥Õ¿Õ«Õ¶','Õ¦Õ²Õ»Õ¸Ö‚Õ´','Õ¯Õ¡ÕºÕ«Õ¹','Õ¡ÕºÕ¿Õ¡Õ¯','Õ§Õ¯Ö€Õ¡Õ¶','Õ¢Ö€Õ¤ÕµÕ¡','Õ¤Õ¡Õ°Õ¸Ö‚Õ¯','ÕºÕ²Õ¿Õ¸Ö€','Õ¤Õ¡Õ¤Õ¡Ö€','Õ¥Ö€Õ·Õ«Õ¯','Õ±ÕµÕ¸Ö‚Õ¤Õ¸','Õ»Õ¸Ö‚Õ©Õ¡Õ¯','Õ¬Õ¾Õ¡ÖÖ„','Õ¡Ö€Õ®Õ¡Õ©','ÕºÕ¸Ö‚Ö€Õ¡Õ¯','Õ¤Õ¥Õ¯Õ¡Õ¶','Õ¬Õ¡Õ¾Õ¡Õ·','Õ£Õ¡Õ¾Õ¡Õ©','Õ¢Õ¸Ö‚Õ¬Õ¯Õ«','Õ½Õ«Ö€Õ¸Ö‚Õ¶','Õ¯Õ¡Õ¿Õ¡Õ¯','Õ¦Õ¸Õ¤Õ¸Ö‚Õ´','Õ©Õ¥ÖƒÕ¸Ö‚Õ¯','Õ¡Õ¶Õ¿Õ¥Ö€','Õ½Õ¡ÖƒÕ¸Ö€','Õ°ÕµÕ¸Ö‚Õ½Õ¶','Õ°Õ¡Õ¶Õ¸Ö‚Õ´','Õ¢ÕµÕ¸Ö‚Õ»Õ¥','Õ½Õ¥Õ¦Õ¸Õ¶','Õ¶Õ«Õ¦Õ¡Õ¯','Õ£Ö€ÕºÕ¡Õ¶','Õ¢Õ¬Õ²Õ¸Ö‚Ö€','ÕºÕ²ÕºÕ¥Õ²','Õ¯Õ¶Õ³Õ«Õ¼','Õ½Ö€Õ«Õ¶Õ£','Õ¥Õ²Õ«Õ¶Õ»','Õ°Õ¡Õ½ÖÕ¥','Õ¿Õ¦Ö€Õ¸Ö‚Õ¯','Õ½ÕºÕ«Ö€Õ¿','Õ¤Ö€Õ¾Õ¡Õ£','Õ¿Õ¸Õ¯Õ¸Õ½','Õ´Õ¡Õ£Õ«Õ¬','Õ¡Ö€Õ´Õ¡Õ¾','Õ¾Õ½Õ¿Õ¡Õ°','Õ¡Õ¶ÖÕ¸Ö‚Õ´','Õ¹Õ¡Ö€Õ¡Õ¦','Õ¡Õ´Õ¢Õ¸Õ­','ÕºÕ¡Õ°Õ¸Ö','Õ¡Õ¯ÖÕ«Õ¡','Õ¿Õ«Õ¿Õ¡Õ¶','Õ¸Ö‚Ö€Õ¢Õ¡Õ©','Õ¡Õ¶Õ£Õ«Ö€','Õ¯Õ¥Õ¶Õ¡Ö','Õ­Õ¸Õ¼Õ¸Õ¹','Õ¡Õ²Õ¡Õ¶Õ±','Õ¤Õ¡Ö€Õ¡Õ¯','ÖƒÕ¡ÖƒÕ¸Ö‚Õ¯','Õ£Õ´Õ¢Õ¥Õ©','Õ­Õ¸Õ¶Õ¡Õ¾','Õ¶Õ¡Õ­Õ¶Õ«','Õ£Õ¶Õ¤Õ¡Õ¯','Õ¡Õ¦Õ¤Õ¡Õ¯','Õ»Õ¸Õ¯Õ¡Õ¿','Õ©Õ¥Õ¶Õ«Õ½','Õ³Õ¡Õ°Õ«Õ³','Õ¢Õ¶Õ¸Ö‚ÕµÕ©','Õ­Ö€Õ³Õ«Õ©','Õ©Õ«Ö€Õ¡Õ­','Õ¿Õ¡Õ³Õ¡Ö€','Õ¶Õ·Õ¥Õ¶Õ«','Õ¡Õ¶Õ±Ö€Ö‡','Õ°Õ¡Õ¿Õ¸Ö‚Õ´','Õ£Õ¡Ö€Õ¸Ö‚Õ¶','Õ­Õ¸Ö‚Ö€Õ´Õ¡','Õ»Õ¥Õ¼Õ¸Ö','Õ·Õ¶Õ¸Ö€Õ°','ÕºÕ¡Õ¿Õ«Õª','ÕªÕ¸Õ²Õ¸Õ¾','Õ¤Õ«Õ¥Õ¿Õ¡','Õ¯Õ¡Õ¶Õ¸Õ¶','Õ²Õ¡Õ¦Õ¡Õ­','Õ¡Õ¦Õ¶Õ«Õ¾','Õ´Õ¸Õ­Õ«Ö€','Õ³Õ¡Õ·Õ¡Õ¯','Õ¢Õ¶Õ¡Õ¦Õ¤','Õ¡Õ¶Õ°Õ¸Õ£','Õ³Õ¡Õ£Õ¡Ö€','Õ¤Õ¸Ö‚Õ¤Õ¸Ö‚Õ¯','Õ­Õ¸ÕªÕ¸Õ¼','Õ¡Õ»Õ¬Õ«Õ¯','Ö„Õ¸Õ©Õ¸Ö‚Õ¯','Õ¡Õ¶Õ±Õ¡Õ¾','Õ¢Õ´Õ¢Õ¸Ö‚Õ¬','Õ­Õ¶Õ¤Õ«Ö€','Õ½Õ¸Ö‚Õ¬Õ¸Ö','Õ¢Õ¡Õ¶Õ¸Ö‚Õ¯','Õ¯Õ¡Õ¾Õ«Õ³','Õ°Ö€Õ¤Õ¥Õ°','Õ½Õ¡Õ´Õ¢Õ¸','Õ°Õ¸Õ¾Õ«Õ¾','Õ¡Õ¼ÕµÕ¸Ö‚Õ®','Õ¯Õ¸Õ²Õ¸Õ¾','Õ¡Ö€Õ³Õ«Õ³','Õ½Õ´Õ¢Õ¡Õ¯','Ö„Õ¡Õ²ÖÖ€','Õ¡Õ¶Õ¿Õ¡Õ·','Õ©Õ¡Õ¶Õ±Ö€','Õ¥Ö€Õ¯Õ«Ö€','Õ¡Õ¿Õ¬Õ¡Õ½','ÕªÕµÕ¸Ö‚Ö€Õ«','Õ½Õ¿Õ¸Ö‚ÕµÕ£','Õ­Õ¬Õ¸Ö‚Ö€Õ¤','Õ«Õ´Õ¡Õ½Õ¿','Õ¥Õ¼Õ¡Õ¯Õ«','Õ¯Ö€Õ¯Õ«Õ¶','Õ½Ö€Õ«Õ¯Õ¡','Õ¯Õ¡Õ©Õ«Õ¬','Õ©Õ¡Õ¼Õ¡Öƒ','Õ³Õ¡Õ¯Õ¡Õ¿','Õ¯Õ¸Õ¯Õ«Õ¯','Õ½Õ¸Ö‚Õ¿Õ¡Õ¯','Õ¯Õ´Õ¡Õ­Ö„','Õ¡Õ¶Õ¢Õ«Õ®','Õ­Õ­Õ¸Ö‚Õ¶Õ»','Õ´Õ¿Ö€Õ¸Ö‚Õ¯','Õ¯Ö€ÕºÕ¡Õ¯','Õ¡Õ²ÕµÕ¸Ö‚Õ½','Õ´Õ¿Ö€Õ¡Õ¯','Õ°Ö€Õ©Õ«Õ¼','Õ¡Ö€ÕªÕ¥Ö„','Õ§Õ¡Õ¯Õ¡Õ¶','Ö†Õ«Õ¦Õ«Õ¯','Õ¾Õ¡Ö€Õ¡Õ¯','Õ¢Õ¡ÖÕ¸Ö‚Õ´','Õ¡Õ¼Õ¾Õ¡Õ¯','Õ¤Õ¸Õ¶Õ¸Ö€','Õ°Õ¸Ö‚Õ¦Õ«Õ¹','Õ¯ÕµÕ¡Õ¶Ö„','Õ­Õ¶Õ¡Õ´Õ«','Õ©Õ¡ÖƒÕ¸Ö‚Ö€','Õ¯Õ¡Ö€Õ¸Õ¿','Õ°Õ¡Õ´Õ¥Õ´','Õ¹Õ¶Õ¹Õ«Õ¶','Õ¿Õ¥Õ½Õ¸Ö‚Õ¹','Õ¸Ö‚Õ²Õ¥Ö€Õ±','Õ·Õ¡Ö„Õ¡Ö€','Õ´Õ¡Õ¬Õ¸Ö‚Õ­','Õ¯Õ¸Õ´Õ«Õ¯','Õ°Õ¡Õ½Õ¸Ö‚Õ¶','Õ¡Õ²Õ¾Õ¥Õ½','Õ¿Õ¡Ö„Õ½Õ«','Õ¦Õ¾Õ¡Ö€Õ©','Õ¤Ö€Õ¸Õ·Õ´','Õ®Õ¡Õ®Õ¸Ö‚Õ¯','Õ´Õ¡Ö„Õ¸Ö‚Ö€','Ö…ÕºÕ¥Ö€Õ¡','Õ¯Õ¸Ö‚Õ¦Õ«Õ¯','Õ¯Õ«Õ©Õ¡Õ¼','Õ±Õ¾Õ¡Õ±Ö‡','Õ©Õ©Õ¥Õ¶Õ«','Õ§Õ©Õ«Õ¯Õ¡','Õ¹Õ¡Õ´Õ¡Õ¶','Õ¶Õ¡Õ­Õ«Ö€','Õ¢Õ¬Ö€Õ¡Õ¯','Õ¢Õ¸Ö‚Õ¤Õ¤Õ¡','Õ¡Õ¢Õ¥Õ²Õ¡','Õ°Õ¶Õ¡Õ¸Õ³','Õ¥Õ¦Õ¡Õ¯Õ«','Õ¤ÕªÕ¾Õ¡Ö€','ÖƒÕ¡Õ©Õ¥Õ©','ÕºÕ¿Õ¸Ö‚ÕµÕ¿','Õ¡Ö€Õ¤Õ¡Ö€','Õ¡Õ²ÖÕ¡Õ¶','Õ¡Õ¼Õ¸Ö‚ÕµÕ£','Õ¬Ö€Õ¿Õ¥Õ½','Õ¡Õ¶Õ­Õ¶Õ¡','Õ¼Õ¥Õ£Õ¢Õ«','Õ¡Õ®Õ¥Õ¬Õ«','Õ°Õ¸Õ¾Õ¡Õ¦','Ö„Õ¡Ö€Õ¸Õ¦','Õ¹Õ¡Õ´Õ«Õ¹','Õ£Ö€Õ¥Õ©Õ¥','Õ¡Õ²Õ´Õ¸Ö‚Õ¯','Õ¤ÕªÕ£Õ¸Õ°','Õ­Õ¸Õ·Õ¸Ö€','Õ·Õ«Õ¿Õ¡Õ¯','Õ°Õ¡Õ´Õ¡Õ¼','Õ¢Õ¡Õ¶Õ¡Õ¶','Õ´Õ«Õ¿Õ¸Ö‚Õ´','Õ°Õ¸Ö‚ÕªÕ¯Õ¸Ö‚','Ö…Ö€Õ¥Õ¶Ö„','Õ¦Õ¶Õ¤Õ¡Õ¶','Õ½Õ¸Õ²Õ¸Ö‚Õ¶','Õ£Õ¶Õ¡ÖÖ„','ÖƒÕ¸Õ²Õ¸Ö','Õ¢Õ¸Õ¾Õ¡Õ®','Ö„Õ¡ÖÕ¡Õ­','Õ¹Õ´Õ¸Ö‚Õ·Õ¯','ÕªÕ¡Õ¶Õ«Ö„','Õ®Õ²Ö€Õ«Õ¤','Õ°Õ¡Õ½Õ¡Õ®','Õ©Õ¸Õ·Õ¡Õ¯','Õ¡Õ¶Õ´Õ¡Õ°','Õ¿Õ¡Ö€Õ¥Ö','Õ¬Õ¥Õ´Õ¸Ö‚Ö€','ÕºÕ¡Õ¶Õ¤Õ¡','Õ´Õ¯Ö€Õ¡Õ¿','Õ­Õ¼ÕºÕ¸Õ¿','Õ­Õ¡Õ¾Õ«Õ®','Õ¢Ö€Õ¤Õ¸Õ¿','Õ¥Ö€Õ¤Õ¸Ö‚Õ´','Õ¹Õ¥Õ¦Õ¸Ö„','Õ¶Õ¸Õ¿Õ¡Ö€','Õ¾Õ¿Õ¡Õ¶Õ£','ÕºÕ«ÖÖÕ¡','Ö†Õ¥Ö€Õ´Õ¡','Õ®Õ¸Õ¾Õ¡Öƒ','Õ¡Õ£Õ¥Õ¶Õ¿','Õ´Õ¡Õ¼Õ¡Õ¶','Õ¾Õ«ÕºÕ¡Õ¯','Õ¼Õ¸Ö‚Õ¢Õ¬Õ«','Õ°Õ¸Ö‚Õ·Õ¸Ö‚Õ´','ÕºÕ¡Õ¼Õ¡Õ¾','Õ­Õ´Õ¢Õ¡Õ¯','Õ½ÕºÕ¸Ö‚Õ¶Õ£','Õ©Õ¼Õ¹Õ¸Ö‚Õ¶','Õ¡Õ¿ÕµÕ¡Õ¶','Õ¢Õ¥Õ¯Õ¸Ö€','Õ´Õ¡Õ¿Õ¸Ö‚Õ¼','Õ«Õ¶Õ¥Ö€Õ¿','Õ©Õ¸Ö‚Õ©Õ¡Õ¯','Õ¡Õ¶Õ¿Õ¸Ö‚Õ¶','Õ¡Õ¢Õ­Õ¡Õ¦','Õ¢Õ¸Õ¢Õ«Õ¯','Õ¹Õ¡Ö€Õ¹Õ«','Õ¦Õ£Õ¥Õ½Õ¿','Õ°Õ¸Ö‚Õ¬Õ«Õ½','Õ­Õ¡Õ¾Õ¡Ö€','Õ£Õ¡Õ¬Õ¡Ö€','Õ¶Õ¸Ö€Õ¥Õ¯','Õ£Õ¸Õ¼Õ¸Õ¦','Õ¢Õ¡Õ¦Õ¸Ö‚Õ¯','Õ¾Õ¦Õ¯Õ¡Õº','Õ¡Õ¶Õ¡Õ´Õº','Õ½Õ¶Õ¤Õ«Õ¯','Õ­Õ¸Ö‚Õ³Õ¸Ö‚Õ³','Õ¬Õ¡Õ¦Õ¥Ö€','Õ¿Õ¡ÖƒÕ¡Õ¯','Õ¦Õ«Õ»Õ¸Õ²','Õ¡Õ¯Õ¸Ö‚Õ´Õ¢','Õ¯Õ¶Õ¸Ö‚Õ¶Ö„','Õ½Õ¡Õ¬Õ«Õ¯','Õ°Õ¶Õ¡Ö€Ö„','Õ£Õ«Õ·Õ¥Ö€','Õ£Õ¡Õ¦Õ¡Õ¶','Õ¯Õ¡Õ²Õ«Õ¶','Õ¯Õ¡Õ¶Õ¥Öƒ','ÕºÕ«Õ¿Õ¡Õ¯','Õ½Ö€Õ³Õ¥Öƒ','Õ¿Õ¡Õ¾Õ«Õ²','Õ½Õ¡Õ´Õ«Õ©','Õ´Õ¸Ö€Õ¸Ö‚Ö„','Õ¡Õ¬Ö‡Õ¸Ö€','Õ¥Õ²Õ¸Ö‚Õ¶Õ£','Õ¿Õ¡Ö€Õ¡Õ¦','Õ£Õ¡Õ¦Õ¡Ö€','Õ¡Õ¯Õ¡Õ¶Õ»','Õ½Õ¸Ö‚Õ¬Õ«Õ¹','Õ©Õ©Õ¾Õ¡Õ·','Õ¢Õ¡ÖÕ«Õ¹','ÕºÕ¡Õ¿Õ¡Õ¼','Ö…Ö€Ö€Õ¡Õ¶','Ö…Õ¡Õ¦Õ«Õ½','Õ¯Õ¸Ö€Õ«Õ¦','ÕºÕ¡Ö€Õ¸Õ¶','ÕºÕ¡Ö€Õ¥Õ¯','Õ¯Õ¡Ö€Õ«Ö„','ÕºÕ²Õ«Õ¶Õ±','Õ©Õ¡Ö„Õ¸Ö‚Õ¶','Õ±Õ¡Õ£Õ¡Ö€','Õ¥Ö€Õ¥Õ­Õ¡','Õ°Õ¡Õ·Õ«Õ·','Õ½Õ­Õ¿Õ¸Ö€','Õ¡Õ¶Õ°Õ¡Õ¿','ÕºÕ¡Õ°Õ¡Õ¯','Õ¾Õ«Õ·Õ¡Õº','Õ·Ö€Õ»Õ¡Õ¶','Õ®Õ¡Õ´Õ¸Õ¶','Õ´Õ¡Õ®Õ¸Ö‚Õ¶','Õ¾Õ¡ÕµÖ€Õ«','Õ®Õ«Õ®Õ¡Õ²','Õ´Õ«Õ»Õ¡Õ¿','Õ©Õ¡Õ¬Õ¡Õ¶','Õ¶Õ¡Õ´Õ¸Ö‚Õ½','Õ¡Õ´Õ¸Ö‚Ö€Õ«','Õ¾Õ¡Õ²Õ¸Ö‚Ö','Õ°Õ¸Ö‚Õ´Õ¸Ö€','Õ¡Õ´Õ¸Ö€Ö†','Õ­Õ¶Õ¸ÖÕ«','Õ½ÖƒÕ¼Õ¸Ö','Õ¢Õ¡Õ¦Õ¸Ö‚Õ´','Õ©Õ¡ÖƒÕ¸Õ¶','Õ¡ÕºÖ€Õ«Õ¬','Õ¤Õ¥Õ¬Õ¿Õ¡','ÖÕ¶ÖÕ¸Ö‚Õ²','Õ¦Õ¡Õ¾Õ¡Õ¯','Õ¯Õ¡ÕµÕ½Ö€','Õ¢Õ¸Õ¬Õ¸Ö‚Õ¯','Õ´Õ¥Õ¶Õ¡Õ¯','ÖƒÖ€Õ¯Õ«Õ¹','Õ­Õ²Õ³Õ¸Ö‚Õ¯','Õ¹Õ¥Õ¹Õ¥Õ¶','Õ½ÕµÕ¸Ö‚ÕªÕ¥','Õ¡Õ³ÕµÕ¸Ö‚Õ¶','Õ¯Õ¡Õ·Õ¾Õ¥','Õ½Õ¿Ö€Õ¸Ö‚Õ¯','Õ¢Õ¡Õ¬Õ¥Õ¿','Õ©Õ¡Õ¶Õ¡Ö„','Õ½Õ¡Õ¶Õ«Õ¯','Õ¯Õ·Õ¥Õ¼Ö„','Õ©Õ´Õ¢Õ¸Ö‚Õ¯','Õ¾Õ«Ö€Õ¸Ö‚Õ½','Õ¢Õ¼Õ¶Õ«Õ¹','Ö„Õ¡Õ´Õ«Õ¹','Õ¬Ö€Õ¡Õ¿Õ¸Ö‚','Õ£Õ¡Õ³Õ¡Õ³','Õ©Õ¸Õ¾Õ«Õ¹','Õ´Õ«Õ»Õ¸Ö','Õ´Õ¸Õ¿Õ«Õ¯','Õ¤Õ«Õ´Õ¡Õ¯','Õ¢Õ¡ÕªÕ¡Õ¯','Õ¡Õ¾Õ¡Ö€Õ¿','Õ¤Õ¡ÕªÕ¡Õ¶','Õ¢Õ¯Õ¬Õ«Õ¯','Õ¡Ö€Õ©Õ¸Ö‚Õ¶','Õ´Õ¡Õ¶Ö€Õ§','Õ¯Õ¸Õ¿Õ¥Õ´','Õ£Õ¸Õ´Õ¥Õ·','Õ½Õ«Õ½Õ¥Õ¼','Õ½Õ¡Õ¾Õ¡Õ¶','Ö…Õ¤Õ¡Õ¹Õ¸Ö‚','Õ½Õ¸Õ­Õ¡Õ¯','Õ®Õ«Õ®Õ¡Õ¯','Õ½Õ¸Õ­Õ¸Ö‚Õ¯','Õ¨Õ¶Õ¯Õ¥Ö€','Õ¶Õ¥Ö€Õ¯Õ¡','Õ·Õ¬Õ¤Õ«Õ¯','Õ®ÕºÕ¿Õ¸Ö‚Õ¶','Õ³Õ¯Õ¸Ö‚ÕµÕ©','Õ¡Ö„Õ¬Õ¸Ö€','Õ¡Õ¯Õ¶Õ¸Ö','Õ£Õ¶Õ¤Õ«Õ¯','ÖÕ¸Ö‚ÖÕ¸Ö‚Õ´','Õ®Õ¡Õ£Õ¸Ö‚Õ´','Ö„Õ¶Õ¶Õ«Õ¹','Õ¡Ö€Õ·Õ¡Õ¾','Õ¡Õ²Õ»Õ«Õ¯','Õ¸Ö‚Õ¶Õ¥Õ¬Õ«','Õ½Õ¶Õ¸Ö‚Õ¶Õ¤','Õ¿Õ­Õ´Õ¡Ö€','Õ¿Õ«Õ¯Õ«Õ¶','Õ°ÕºÕ¡Ö€Õ¿','Õ½Õ©Ö€Õ¥Õ½','Õ½Ö€Õ¾Õ¡Õ¯','Ö…Õ©Ö‡Õ¡Õ¶','Õ¢Õ¸Õ²Õ¸Ö„','Õ¡Ö€Õ´Õ¡Õ¿','Õ¯Ö€Ö„Õ¸Õ¿','Õ®Õ¡Õ¶Õ¸Õ©','Õ¡Ö€ÕµÕ¸Ö‚Õ¶','Õ¥Ö€Õ¡Õ¶Õ£','Õ¡Õ³Õ¸Ö‚Ö€Õ¤','Õ¬ÕµÕ¡Ö€Õ¤','Õ¡Õ´Õ¡ÕµÕ«','Õ¦Ö€Õ¸Ö‚ÕµÖ','Õ½Õ¡Õ¬Õ¸Ö€','Õ¥Ö€Õ¯Õ¡Õ©','Õ¿Õ¸Õ¶Õ¶Õ¡','Õ¡Ö€Õ®Õ«Õ¾','Õ¤Ö€Õ¸Ö‚ÕµÕ©','Õ¶ÕµÕ¡Ö€Õ¤','Õ¡Õ¶Õ£Õ¥Õ¿','Õ¯Õ¡Õ¿Õ¡Ö€','Õ¤Ö€Õ¡ÖÕ«','Õ¬Õ¡Ö€Õ¸Ö‚Õ´','Õ¯Õ¼Õ¸Ö‚Õ¶Õ¯','Õ¸Ö‚Õ²Ö‡Õ¸Ö€','Õ´Õ¡Õ¶Õ£Õ¸','Õ¡Õ¬Õ¢Õ¸Õ´','Õ¢Õ¥Õ²Õ¬Õ¸Ö‚','Õ¡Õ¶Õ¸Ö‚Ö€Õ»','Õ¤Õ¸Ö‚Õ½Õ¿Ö€','Õ¸Õ²Õ¸Ö€Õ¯','Õ«Õ·Õ­Õ¡Õ¶','Õ¸Õ¬Õ¸Ö€Õ¿','Õ¸Ö‚Õ¬Õ¸Ö‚Õ¶Ö„','Õ¡Õ¶Õ³Õ¡Ö€','Õ©Õ¸Õ¶Õ«Ö€','Õ¡Õ¸Ö‚Õ¤Õ«Õ¸','Õ¢Õ«Õ¦Õ¸Õ¶','Õ¯Õ¸Õ²Õ¡Õ¯','ÖÕ¸Ö€Õ¥Õ¶','Ö…Ö„Õ½Õ«Õ¤','Õ½Õ´Õ¢Õ¸Ö‚Õ¯','Õ½Õ¡Õ´Õ¢Õ¡','Õ¡Õ¶Õ¯Õ¸Õ¹','Ö„Õ¡Õ¶Õ¡Õ¯','Õ°Õ¸Õ¯Õ¥Õµ','Õ¾Õ¡Õ°Õ¡Õ¶','Õ­Õ¡Õ¶Õ¸Ö‚Õ©','Õ°Ö€Õ¡Õ·Ö„','Õ¯Õ¸Õ·Õ«Õ¯','Õ¡Õ¶Õ´Õ«Õ¿','Õ¦Õ¸Ö€Õ¥Õ²','Õ¡Ö€Õ±Õ¡Õ¶','Õ¿Õ¥Õ½Õ¡Õ¯','ÖÕ¸Õ²Õ¸Ö‚Õ¶','Õ¸Õ½Õ¯Õ¸Ö€','Õ¨Õ´Õ¢Õ«Õ·','Õ¤Õ¡Õ£Õ¡Õ²','Õ¡ÕºÕ¡Õ¯Õ«','Õ¤Õ«ÕºÕ¸Ö‚Õ¯','Õ©Õ¡Õ©Õ¡Ö€','Õ´Õ¯Õ¶Õ«Õ¯','Õ¯Õ¸Õ¯Õ¸Õ½','ÖƒÕ¸Ö‚Õ¹Õ«Õ¯','Õ¡Õ¶Õ¤Õ¸Ö‚Ö€','Õ¡Õ´ÖƒÕ¸Öƒ','Õ¯Õ¸Õ¢Ö€Õ¡','Õ£Õ¡Õ£Õ¡Õ©','Õ¡ÕºÕ·Õ¡Õ®','Õ¢Ö€Õ«Õ¶Õ±','Õ¶ÕªÕ¸Ö‚ÕµÕ£','Õ¥Õ²Õ¶Õ«Õ¯','Õ½Õ¥Õ¶Õ¡Õ¿','Õ¼Õ¥Õ¦Õ¸Ö‚Õ½','Õ»Õ¶Õ»Õ¸Ö','Õ·Õ¡Õ·Õ¯Õ«','Õ¯Õ¸Õ³Õ¡Õ¯','Õ¡Õ£Õ¼Õ¡Õ¾','Õ«Õ½Õ¬Õ¡Õ´','Õ¤Õ²ÕµÕ¡Õ¯','Õ´Õ¥Õ¼Õ¡Õ®','Õ£Õ¥Ö€Õ¡Õ¶','Õ¦Õ¶Õ¶Õ¸Õ²','Õ©Õ«Õ©Õ¥Õ¼','Õ·Õ¥ÖƒÕ¸Ö€','Õ¡Ö„Õ½Õ¸Ö€','Õ½Õ¥Õ¬Õ¡Õ¾','Õ´Õ¡Õ¶Õ¸Ö‚Õ¯','Õ½Õ«Õ¢Õ¥Õ­','Õ½ÕºÕ¸Ö€Õ¿','ÕºÕ¶Õ¤Õ¸Ö‚Õ¯','Õ¥Ö€Õ¢Õ¥Ö„','Ö„Õ«Õ´Õ«Õ¯','ÕºÕ¡Ö€Õ¡Õ¶','Õ¡Ö€Õ¤Õ¸Ö‚Õ¯','Õ­Õ¶Õ±Õ¸Ö€','Õ¶Õ¥Õ­Õ¸Ö‚Ö€','Õ°Õ½Õ¿Õ¡Õ¯','Õ´Õ«Õ»Õ¸Ö‚Õ¯','Õ½Õ¿Õ¾Õ¥Ö€','Õ£Õ¥Õ¿Õ«Õ¶','ÖƒÕ¡Ö€Õ¸Õ½','Õ°Õ¶Õ¹Õ¥Õ²','Õ¿Õ¡Õ¿Õ«Õ¯','Õ©Õ·Õ¾Õ¡Õ¼','Ö„Õ¬Õ¸Ö‚Õ¶Õ£','Õ±Õ¡Õ¾Õ¡Ö€','ÕºÕ¡Õ¬Õ¡Õ¿','Õ¡Õ¶Õ»Õ¸Ö‚Ö€','Õ®Õ²Õ¸Õ¿Õ¥','Õ¿Õ¡Õ¶Õ«Ö„','Õ°Õ¡Õ½Õ¡Õ¯','Õ­Õ¡Õ²Õ¡Õ²','ÕºÕ¡Õ¯Õ¡Õ½','Õ¯Õ¡Ö€Õ«Õ³','Õ°Õ½Õ¯Õ«Õ¹','Õ¡Õ¯Õ¸Ö‚Õ¶Ö„','Õ¥Ö€Õ¥Õ¯Õ¸','Õ¬Õ¸Ö‚ÖÕ¯Õ«','Õ¡Õ¶Õ½Õ¥Õ¼','Õ·Õ¡Ö€Õ¡Õ¶','Õ°Õ¸ÕºÕ¸Õº','Õ¿Õ¡Ö€Õ«Ö„','Õ°Õ¡Õ´Õ¡Ö€','Õ¯Õ¸Ö‚Ö€Õ®Ö„','Õ¡Õ¶Õ¥Õ®Ö„','ÕºÕ¡Õ·Õ¡Ö€','Õ¹Õ²Õ»Õ«Õ¯','Õ­Õ¸Ö€Õ¡Õ¶','Õ¾Õ«Õ½Õ¯Õ«','Õ¡Õ¶Õ¯Õ¡Õ­','Õ¬Õ¸Ö‚Õ½Õ¡Õ¶','Õ¥Õ²ÕµÕ¡Õ´','Õ¡Õ¾Õ¡Õ¶Õ¤','Õ¯Õ¡Ö„Õ¡Õ¾','Õ¡Õ¬ÕµÕ¸Ö‚Ö€','Õ¯Õ¡ÕºÕ¡Ö€','Õ´Õ¸Ö€Õ¥Õ­','ÖƒÖ€ÖƒÕ¸Ö‚Ö€','Õ¶Õ¡Õ´Õ¡Õ¯','Õ´Õ©Õ¥Ö€Ö„','Õ¡Õ¶ÖÕ¡Õ®','Õ¤ÕªÕ¸Õ­Ö„','Õ½Õ¯Õ«Õ¦Õ¢','Õ¯Õ¡ÕºÕ¸Ö','Õ¥Õ²Õ¥Õ¼Õ¶','Õ¢Õ¡Ö€Õ¤Õ«','Õ¢Õ¸Ö‚ÕªÕ«Õ¹','Õ´Õ¥Õ­Õ¡Õ¯','ÕºÕ¶Õ¤Õ¸Ö‚Õ´','Ö€Õ¡Õ¢Õ¢Õ«','Õ½Õ¥Õ²Õ¡Õ¶','Õ¹Õ¡ÖƒÕ¸Ö‚Õ´','Õ®Õ¸Ö‚Õ²Õ¡Õ¯','Õ¯Õ¸ÕºÕ¥Õ¯','Õ®Õ¡Ö€Õ¡Õ¾','ÖÕ¶ÖÕ¸Ö‚Õ´','Õ¡Õ¯Õ¸Ö€Õ¤','Õ¸Õ¹Õ«Õ¶Õ¹','Ö„Õ«Õ´Õ«Õ¡','Õ¡Õ¯ÖÕ«Õ¦','Ö†Õ¡Õ¶Õ¿Õ¡','Õ©Õ¡Õ¾Õ«Õ·','Õ­Õ·Õ·Õ¸Ö','Õ´Õ¸Õ®Õ¡Õ¯','Õ¡Õ¾Õ¡Õ¦Õ¥','Õ¯Ö€Õ³Õ¡Õ¿','Õ¯Õ¡ÕºÕ«Õ¯','Õ¢Ö€Õ¸Õ¶Õ¦','Õ°Õ¡Ö€Õ¡Õ¾','Õ©Õ¥Ö€Õ¡Õ³','Õ¼Õ¥ÕªÕ«Õ´','ÖÕ¸Ö‚ÖÕ¡Õ¯','Õ¢Õ¥Ö€Ö€Õ«','Õ¢Õ¡ÕªÕ«Õ¶','Õ¿Õ¸Õ´Õ¡Õ¿','Õ¶Õ¾Õ¡Õ½Õ¿','Õ°Õ¡Õ´Õ¥Õ²','Õ¿Õ¡Õ¯Õ¡Õ¼','Õ¦Õ£Õ¡Õ½Õ¿','Õ£Õ¥Ö€Õ¡Õ³','Õ·Ö„Õ¥Ö€Õ©','Õ¬Õ¸Õ²Õ¡Öƒ','Õ¡ÕºÕ¡Õ£Õ¡','Õ¢Õ¡Õ¶Õ¡Õ¯','Õ°Õ¡Ö€Õ«Õ¹','Õ¦Õ¸Ö‚Õ¼Õ¶Õ¡','Õ¼Õ¸Õ¢Õ¸Õ¿','ÕºÕ¡Ö€Õ£Ö‡','Õ¡Õ¶Õ´Õ¥Õ²','Õ·Õ¼Õ¡ÕµÕ¬','Õ½Õ­Õ¥Õ´Õ¡','Õ°Õ¸Ö‚Õ¶Õ«Õ½','Õ¡ÕµÕ¬Õ¸Ö‚Ö€','Õ¯Õ¡Õ´Õ¡Ö€','Õ¡Ö€Õ¤Õ¥Õ¶','Õ¿Õ¡Õ»Õ«Õ¯','Õ­Õ¡Ö€Õ¡Õ¶','Õ¹Ö„Õ¶Õ¡Õ²','Õ¢Õ¡Ö€Õ±Ö€','Ö„Õ¡Õ²Õ¡Ö„','Õ©Õ¦Õ¥Õ¶Õ«','Õ¢Õ·Õ¿Õ«Õ¯','Õ¡Õ²Ö„Õ¡Õ¿','Õ©Õ¡Õ­Õ«Õ®','Õ¯Õ¡Õ¯Õ¡Õ¹','Õ¡Õ¶Õ¤Õ¡Õ´','Õ­Õ³Õ¸Ö‚Õ²Õ«','Õ»Ö€Õ¾Õ¥Õª','Õ¬Õ¸Ö€Õ¿Õ¸Ö‚','Õ¡Õ¾ÕµÕ¸Ö‚Õ¶','Õ¡Õ½ÕºÕ¥Õ¿','Õ¯Õ¸Õ¹Õ¸Ö‚Õ´','Õ½Õ¯ÕµÕ¸Ö‚Õ¼','Õ¡Õ¶Õ¢Õ¡Õ¶','Õ¯Õ¡ÖÕ«Õ¶','Õ¿Õ¥Ö„Õ½Õ¿','Õ­Õ«Õ¦Õ¡Õ­','Õ³Õ¸Ö‚Õ¼Õ¡Õ¯','Õ¶ÕºÕ¡Õ½Õ¿','Õ¥Õ²Õ¥Õ£Õ¶','Õ¯ÕºÕ¹Õ¸Ö‚Õ¶','Õ¡Õ¼Õ¸Õ²Õ»','Õ´Õ¡ÕµÕ«Õ½','Õ¯Õ¶Õ³Õ«Õ©','Õ¯ÖÕ¸Ö€Õ¤','Õ¦Õ¡Õ¿Õ«Õ¯','Õ¤Õ«Õ´Õ¸Ö‚Õ´','Ö…Õ½Õ¯Õ¡Ö€','Õ°Õ¡Õ´Õ¸Õ¾','Õ°Õ¡Õ¿Õ¡Õ¯','Õ­Õ´Õ«Õ¹Ö„','Õ¤Õ¡Õ¶Õ¡Õ¯','Õ¯Õ¡Ö€Õ¡Õ£','Õ¡Õ¶Õ°Õ¡Õ´','Õ©Õ¼Õ«Õ¹Ö„','Õ¡Õ´Ö€Õ¸Ö','Õ´Õ¥Õ¬Õ«Ö„','Õ½Õ¥Õ¤Õ¡Õ¶','Õ¬Õ¡ÕºÕ·Õ¡','Õ¢Õ¡ÖÕ¡Õ¿','Õ¯Õ¥Õ½Ö…Ö€','Õ®Õ®Õ¸Ö‚Õ´Õ¢','Õ£Õ¸Ö‚Õ´Õ¡Ö€','Õ½Ö€Õ¢Õ«Õ¹','Õ¾Õ¦Õ¶Õ¸Ö','Õ¥Ö€Õ¯Õ¡Ö€','Õ¡Õ¶Õ¾Õ¡Õ­','Õ°Õ´Õ¡ÕµÖ„','Õ½Õ¶Õ¡Õ¶Õ¯','Õ¢Õ¡ÖÕ«Õ¯','Õ´Õ¼Õ¡ÕµÕ¬','Õ¢Õ«Ö€ÕªÕ¡','Õ¢Õ¡ÖÕ«Õ¬','Õ¯Õ¬Õ«Õ´Õ¡','Õ´Ö€ÖÕ¸Ö‚Õ´','Õ¸Õ°Õ´Õ¡Õ¯','Õ¶Õ¡Ö€Õ¤Õ«','Õ¬Õ¡Õ¿Õ¿Õ¥','Õ´Õ¸Ö‚Õ´Õ«Õ¡','Õ¡Õ¼Õ¶Õ¥Õ¿','Õ´Ö€Ö€Õ«Õ¯','Õ¡Õ²Õ¥Ö€Õ½','Õ¸Õ¹Õ­Õ¡Ö€','Õ¥Õ¬Ö‡Õ§Õ»','Õ°Õ¥Ö€Õ¸Õ½','Õ£Õ¸Ö‚Õ¶Õ¡Õ¿','Õ¯Õ¥Õ¼Õ«Õ¯','Õ¤Õ¥Õ²Õ«Õ¶','Õ¯Õ¥Õ¼Õ¡Õ½','Õ®Õ¶Õ¸Ö‚Õ¶Õ¤','Õ­Õ¶Õ¡Õ´Ö„','Õ¡Ö€Õ­Õ«Õ¾','Õ¥Ö€Õ£Õ«Õ¹','Õ°Õ¡Õ¦Õ¡Ö€','Õ¯Õ¡Ö€Õ¡Õº','ÕºÕ¡Õ½Õ«Õ¾','Õ¿Õ¡Õ¢Õ¡Õ¿','Õ®Õ«Ö€Õ¡Õ¶','Õ¤Õ¸Õ¬Õ¡Ö€','Õ­Õ¸Ö‚Õ³Õ¡Õº','Õ°Õ¡Õ¾Õ¡Õ¿','ÖƒÕ¡Õ¯Õ¡Õ¶','ÖƒÕ¡Õ©Õ«Õ¬','Õ£Õ¸Ö‚Õ·Õ¡Õ¯','Õ¯Õ¡Õ­Õ«Õ¹','Õ½Õ¡Õ¯Õ¡Õ¾','ÕºÕ¡Ö€Õ¥Õ¶','Õ®Õ¡Õ¯Õ¸Õ²','Õ¬Õ¸Ö‚Õ½Õ«Õ¶','Õ¼Õ¡Õ¤Õ«Õ¸','Õ¯Ö€Õ®Õ¸Õ²','Õ°Õ«Õ´Õ¡Ö€','Õ½Õ¥Ö€Õ«Õ¡','Õ¬Õ¸Õ¬Õ«Õ¯','Õ­Õ¡Õ²Õ¸Õ²','Õ¼Õ¥Õ°Õ¡Õ¶','Õ¡Õ½Õ¸Ö‚ÕµÕ©','Õ¤Õ¡ÖƒÕ¶Õ«','Õ¸Ö‚Õ¿Õ¥Õ½Õ¿','Õ¡ÕµÕ½Ö…Ö€','Õ¦Õ£Õ¸Ö‚ÕµÕ·','Õ¤ÕºÖ€Õ¸Ö','Õ¢Õ¥Ö€Õ¡Õ¶','Õ´Õ«Õ»Õ«Õ¶','Õ¤Õ¸Õ¤Õ¸Õ·','Õ¡Õ´Õ¢Õ¡Ö€','Õ¡Õ¶Õ¿Õ«Õ¯','Õ®Õ¸Ö€Õ¡Õ¯','Õ°Õ¡Õ³Õ¡Õ­','Õ¥Ö€Õ¡Õ·Õ¿','Õ·Õ¡Õ¢Õ¡Õ©','ÕºÕ¡Ö€Õ¿Ö„','Õ¢Õ¡Õ­Õ¸Ö‚Õ´','Õ¡Õ²Õ¸Õ©Ö„','Õ£Õ¦Ö€Õ¸Ö','Õ¡Õ¶Õ¦Õ¸Ö€','Õ¬Õ«Õ´Õ¸Õ¶','Õ¿Õ¶Õ»Ö€Õ«','Õ¢Õ¼Õ¶Õ¡Õ¯','Õ¡Õ¸Ö‚Õ¤Õ«Õ¿','Õ½Ö€Õ¸Ö‚Õ¶Ö„','Õ¤Õ¤Õ´Õ«Õ¯','Õ¡Õ¬Õ«Õ¢Õ«','Õ¿Õ¸Õ¶Õ¸Ö‚Õ½','Õ¬Õ¡Õ¯Õ¸Õ¿','Õ´Õ¸Ö€Õ©Õ«','Õ­Ö€Õ©Õ«Õ¶','Õ¯Õ¥Ö†Õ«Ö€','Õ¢Õ¡Ö€Õ¡Õ¯','Õ¡Õ¶Õ¸Õ¶Õ½','Õ½ÕºÕ¡Õ½Ö„','Õ¯Õ¡Õ¶Õ¡Õ¹','Õ¾Ö€Õ±Õ«Õ¶','Õ­Õ¥Õ¬Õ¸Ö„','Õ¡Õ´Ö€Õ¡Õ¯','Õ¡Õ¯Õ¿Õ«Õ¾','Õ¤Õ¡Õ°Õ«Õ³','Õ·Õ¸Ö‚Õ·Õ¡Õ¶','Õ´Õ¡Õ¿Õ«Õ¿','ÕºÕ¡Õ¶Õ«Ö€','Õ¯Õ¸ÕºÕ«Õ¿','Õ¿Õ¡ÕºÕ¡Õ¯','Õ¯Õ¡Õ¯Õ¡Õ¸','Õ¾Õ«Õ³Õ¡Õ¯','Õ³Õ¶Õ·Õ¸Ö‚Õ´','Õ¡Õ¶Õ¿Õ¡Õ¼','Õ¡Ö€Õ¡Ö€Ö„','Õ´Õ¸Õ²Õ¥Õ½','Õ·Õ¥Ö€Õ¥Öƒ','Õ°Õ¸Õ¾Õ«Õ¿','Ö†Õ«Õ¬Õ¿Ö€','ÕºÕ¥ÕºÕ½Õ«','Õ´Õ¡Õ½Õ¸Õ¶','Õ¡Õ¶Õ¯Õ¸Ö‚Õ´','Õ¸Ö‚Õ¦Õ¢Õ¥Õ¯','Õ¥Õ¼ÕµÕ¡Õ¯','Õ¶Õ¥Ö€Õ¸Ö‚Õª','Õ¡Ö€Õ»Õ¸Ö‚Õ¯','Õ©Õ´Õ¢Õ«Õ¯','Õ®Õ®Õ¸Ö‚Õ´Õ¢','Õ¤Õ«Õ´Õ¡Ö','Õ¾Õ¡Õ¶Õ¸Õ²','Õ¯Õ«Õ½Õ¡Õ¿','Õ¬Õ«Õ¶Õ¥Õ¬','Õ¡Õ¼Õ¶Õ¥Õ¬','Õ­Õ¸Õ½Õ¥Õ¬','Õ¶Õ½Õ¿Õ¥Õ¬','Õ¾Õ¡Õ¦Õ¥Õ¬','Õ©Õ¼Õ¹Õ¥Õ¬','Õ¬Õ¸Õ²Õ¡Õ¬','Õ½Õ«Ö€Õ¥Õ¬','Õ°Õ«Õ·Õ¥Õ¬','Õ­Õ¡Õ²Õ¡Õ¬','Ö…Õ£Õ¶Õ¥Õ¬','Õ£Õ¿Õ¶Õ¥Õ¬','Õ¢Õ¡ÖÕ¥Õ¬','ÖƒÕ¡Õ¯Õ¥Õ¬','Õ½Õ¯Õ½Õ¥Õ¬','Õ¡ÕºÖ€Õ¥Õ¬','Õ®Õ¶Õ¾Õ¥Õ¬','ÖƒÕ¸Õ­Õ¥Õ¬','Õ¥Ö€Õ£Õ¥Õ¬','ÕºÕ¡Ö€Õ¥Õ¬','ÕªÕºÕ¿Õ¡Õ¬'];


  if (WORDS.length === 0) {
      console.error("Word list is empty!");
  }

  // --- Correctly Sorted LOWERCASE Armenian Letters for Highlighting/Validation ---
  const sortedLetters = [
      'Õ¡', 'Õ¢', 'Õ£', 'Õ¤', 'Õ¥', 'Õ¦', 'Õ§', 'Õ¨', // 8
      'Õ©', 'Õª', 'Õ«', 'Õ¬', 'Õ­', 'Õ®', 'Õ¯', 'Õ°', // 8 (16 total)
      'Õ±', 'Õ²', 'Õ³', 'Õ´', 'Õµ', 'Õ¶', 'Õ·', 'Õ¸', // 8 (24 total)
      'Õ¹', 'Õº', 'Õ»', 'Õ¼', 'Õ½', 'Õ¾', 'Õ¿', 'Ö€', // 8 (32 total)
      'Ö', 'Õ¸Ö‚', 'Öƒ', 'Ö„', 'Ö‡', 'Ö…', 'Ö†'      // 7 (39 total)
    ];
  const allLetters = [...sortedLetters]; // Use this for physical keyboard input validation

  // --- Keyboard Layout Definitions ---
  const keyboardAlphabeticalLayout = [
     sortedLetters.slice(0, 8),   // Õ¡ - Õ¨
     sortedLetters.slice(8, 16),  // Õ© - Õ°
     sortedLetters.slice(16, 24), // Õ± - Õ¸
     sortedLetters.slice(24, 32), // Õ¹ - Ö€
     [...sortedLetters.slice(32), ''] // Ö - Ö† (7 letters) + 1 placeholder = 8 elements
  ];

   const keyboardPhoneticLayout = [
      ['Õ§', 'Õ©', 'Öƒ', 'Õ±', 'Õ»', 'Ö‡', 'Ö€', 'Õ¹', 'Õ³', 'Õª'], // 10 keys
      ['Ö„', 'Õ¸', 'Õ¥', 'Õ¼', 'Õ¿', 'Õ¸Ö‚', 'Õ«', 'Ö…', 'Õº', 'Õ­'], // 10 keys
      ['Õ¡', 'Õ½', 'Õ¤', 'Ö†', 'Õ£', 'Õ°', 'Õµ', 'Õ¯', 'Õ¬', 'Õ®'], // 10 keys
      ['Õ¦', 'Õ²', 'Ö', 'Õ¾', 'Õ¢', 'Õ¶', 'Õ´', 'Õ·', 'Õ¨', ''] // 9 keys + 1 placeholder = 10 elements for consistent grid
   ];

   const LAYOUT_NAMES = {
       'alphabetical': 'Ô±Ô²Ô³', /* Changed name */
       'phonetic': 'Õ”ÕˆÔµ' /* Changed name */
   };

  // --- Daily Word Logic ---
  const startDate = new Date("2025-04-11");
  const today = new Date();
  today.setHours(0, 0, 0, 0); // Normalize today's date to midnight
  const dayOffset = Math.floor((today - startDate) / (1000 * 60 * 60 * 24));
  // Initial target word is always today's word based on the offset
  let currentWordOffset = dayOffset; // Track which game number is currently loaded
  let currentTargetWord = WORDS.length > 0 ? WORDS[currentWordOffset % WORDS.length] : "Õ½Õ­Õ¡Õ¬";
  let parsedCurrentTarget = splitWord(currentTargetWord);
  // The current game's local storage key
  let currentGameDateKey = `${LOCAL_STORAGE_PREFIX}${today.toISOString().split('T')[0]}`;


  // --- Game State Variables ---
  let guesses = [];
  let currentGuess = [];
  let currentRowIndex = 0;
  let isGameOver = false;
  let messageTimeout;
  // Stores CUMULATIVE best status: {'letter': 'correct' | 'present' | 'absent'}
  let keyStatuses = {};
  // Track current layout state
  // Use the saved layout preference as default, if not found, use 'phonetic'
  let currentLayoutName = localStorage.getItem(LOCAL_STORAGE_LAYOUT_KEY) || 'phonetic';
  let currentLayout = (currentLayoutName === 'phonetic') ? keyboardPhoneticLayout : keyboardAlphabeticalLayout;


  // --- Initialization ---
  function init() {
    loadState(); // Load theme, layout preference, and game state for *today* by default

    // Update the game number display initially
    updateGameNumberDisplay();

    buildBoard();
    buildKeyboard(); // Build keyboard based on loaded layout
    redrawBoardFromState();
    updateKeyboardHighlight(); // Update keyboard highlight based on loaded keyStatuses

    // Check for game over state on refresh and display final message/disable input
    // This check is now based on the *loaded* game state
    if (isGameOver) {
        const lastGuessString = guesses.length > 0 ? guesses[guesses.length - 1].map(g => g.letter).join('') : '';
        if (splitWord(lastGuessString).join('') !== parsedCurrentTarget.join('')) {
             // If the game was lost
             showMessage(`ÕŠÕ¡Ö€Õ¿Õ¸Ö‚Õ©ÕµÕ¸Ö‚Õ¶Ö‰ Ô±ÕµÕ½Ö…Ö€Õ¾Õ¡ Õ¢Õ¡Õ¼Õ¨Õ ${currentTargetWord}`, 0); // Show message indefinitely
        } else {
             // If the game was won
             showMessage('ðŸŽ‰ Õ€Õ¡Õ²Õ©Õ¡Õ¶Õ¡Õ¯ ðŸŽ‰', 0); // Show message indefinitely
        }
         disableInput(); // Always disable input if game is over (win or lose)
    } else {
         // If game is not over, ensure input is enabled
         enableInput();
    }


    window.addEventListener('keydown', handlePhysicalKey);
    toggleBtnLayout.addEventListener('click', switchLayout); // Add listener to the new button
    gameNumberElement.addEventListener('click', openPreviousGamesModal); // Add listener to game number
    modalCloseButton.addEventListener('click', closePreviousGamesModal);
    previousGamesModal.addEventListener('click', handleModalOverlayClick); // Close when clicking outside content

  }

   // --- Update Game Number Display ---
   function updateGameNumberDisplay() {
        gameNumberElement.textContent = `#${currentWordOffset + 1}`;
   }


  // --- State Management (localStorage) ---
  function saveState() {
    // Only save state for today's game
    if (currentWordOffset === dayOffset) {
        const state = {
          guesses,
          currentRowIndex,
          isGameOver,
          targetWord: currentTargetWord, // Save the specific word played
          keyStatuses // Save only the CUMULATIVE keyStatuses
        };
        localStorage.setItem(currentGameDateKey, JSON.stringify(state));
    }
    // Always save layout preference regardless of which game is displayed
    localStorage.setItem(LOCAL_STORAGE_LAYOUT_KEY, currentLayoutName);
  }

   // Loads state for a specific game offset
  function loadStateForOffset(offset) {
        const targetDate = new Date(startDate);
        targetDate.setDate(startDate.getDate() + offset);
        const dateKey = `${LOCAL_STORAGE_PREFIX}${targetDate.toISOString().split('T')[0]}`;
        const wordForOffset = WORDS.length > 0 ? WORDS[offset % WORDS.length] : "Õ½Õ­al";

        let loadedState = null;
        const savedStateJSON = localStorage.getItem(dateKey);
        if (savedStateJSON) {
             try {
                 const state = JSON.parse(savedStateJSON);
                 // Validate if the saved word matches the expected word for this offset
                 if (state.targetWord === wordForOffset) {
                     loadedState = state;
                 } else {
                     console.warn(`Saved word for offset ${offset} (${state.targetWord}) does not match expected word (${wordForOffset}). Starting fresh for this day.`);
                 }
             } catch (e) {
                 console.error(`Error loading state for offset ${offset}:`, e);
             }
        }

        // Update global state variables based on loaded state or reset
        currentWordOffset = offset;
        currentTargetWord = wordForOffset;
        parsedCurrentTarget = splitWord(currentTargetWord);

        if (loadedState) {
            guesses = loadedState.guesses || [];
            currentRowIndex = loadedState.currentRowIndex || 0;
            isGameOver = loadedState.isGameOver || false;
             // Note: Key statuses are cumulative *per session* / independent of the specific game loaded.
             // Let's re-evaluate this. Key statuses should probably be tied to the *current day's* progress,
             // even if you're viewing a past game. The keys you press *now* affect today's keyboard.
             // However, the request implies showing the keyboard state *as it was* for that game?
             // No, that's complex. Standard Wordle keyboard state is global for the day.
             // So, keyStatuses should be loaded only ONCE for today's game in `init`.
             // When viewing past games, the keyboard highlight *should still reflect today's progress*.
             // Let's revert keyStatus loading/saving to only happen for the current day in `init` and `saveState`.
             // The `loadStateForOffset` function will *not* load keyStatuses.
            // keyStatuses = loadedState.keyStatuses || {}; // REMOVING THIS LINE

            // But we *do* need to update the keyboard state *display* if the player played this past game and won/lost.
            // No, the keyboard highlight is cumulative *for today*. If you play a past game, it doesn't update today's keyboard.
            // Let's simplify: `keyStatuses` is always for today's game.
            // When loading a past game, we just display its board state. The keyboard is always "today's keyboard".

            // RETHINK: The requirement might be to show the keyboard state *as it was* when that past game finished.
            // This is possible if we save `keyStatuses` *with* each game state.
            // Let's go back to saving/loading keyStatuses per game, but merge them cumulativey when *playing* today's game.
            // When loading a historical game, load its specific key statuses.
            // When playing today's game, load today's key statuses (which might have been saved mid-game),
            // and then update them cumulatively as guesses are made.

            // Let's adjust `loadState` and `loadStateForOffset` roles.
            // `init` calls `loadInitialStateForToday`.
            // `loadStateForOffset` is only called when clicking a historical game.

        } else {
             // No saved state for this offset, start a fresh game for that day's word
             guesses = [];
             currentRowIndex = 0;
             isGameOver = false;
             // When loading a past game, keyStatuses should reflect its finished state? Or today's?
             // Let's make keyStatuses load *with* the game, but only save/update for the *current* day's game.
             // This is still ambiguous. The most common implementation is a global key state based on *all* completed games *on that device*.
             // But the request is linked to *previous games (game number - date)*, implying state per game number.
             // Let's assume key state is tied to the game number. So loading game N loads its guesses AND its key state.
            // If no state exists for game N, start fresh with empty guesses and empty key state.
             keyStatuses = {}; // Start with empty key statuses for a new/unplayed game
        }

        // Update UI
        updateGameNumberDisplay(); // Show the game number
        buildBoard(); // Rebuild the empty board structure
        redrawBoardFromState(); // Populate the board with loaded/empty guesses
        updateKeyboardHighlight(); // Update keyboard highlight based on loaded/empty keyStatuses

         // Check game over status for the loaded game
        if (isGameOver) {
             const lastGuessString = guesses.length > 0 ? guesses[guesses.length - 1].map(g => g.letter).join('') : '';
             if (splitWord(lastGuessString).join('') !== parsedCurrentTarget.join('')) {
                 showMessage(`ÕŠÕ¡Ö€Õ¿Õ¸Ö‚Õ©ÕµÕ¸Ö‚Õ¶Ö‰ Ô±ÕµÕ½Ö…Ö€Õ¾Õ¡ Õ¢Õ¡Õ¼Õ¨Õ ${currentTargetWord}`, 0);
             } else {
                 showMessage('ðŸŽ‰ Õ€Õ¡Õ²Õ©Õ¡Õ¶Õ¡Õ¯ ðŸŽ‰', 0);
             }
             disableInput(); // Disable input if the loaded game is over
        } else {
             // If the loaded game is not over, enable input (only if it's today's game)
             if (currentWordOffset === dayOffset) {
                 enableInput(); // Re-enable input only if loading today's unfinished game
             } else {
                 // If loading a historical, unfinished game, input should be disabled
                 // as you can only play today's game.
                 disableInput();
                 showMessage(`Ô´Õ«Õ¿Õ¡Ö€Õ¯Õ¾Õ¸Ö‚Õ´ Õ§ Õ­Õ¡Õ² #${currentWordOffset + 1}. Ô´Õ¸Ö‚Ö„ Õ¯Õ¡Ö€Õ¸Õ² Õ¥Ö„ Õ­Õ¡Õ²Õ¡Õ¬ Õ´Õ«Õ¡ÕµÕ¶ Õ¡ÕµÕ½Ö…Ö€Õ¾Õ¡ Õ­Õ¡Õ²Õ¨Ö‰`, 3000);
             }
        }
   }

   // Initial load for today's game when the page loads
   function loadInitialStateForToday() {
       currentWordOffset = dayOffset; // Ensure we are on today's game
       currentTargetWord = WORDS.length > 0 ? WORDS[currentWordOffset % WORDS.length] : "Õ½Õ­Õ¡Õ¬";
       parsedCurrentTarget = splitWord(currentTargetWord);
       currentGameDateKey = `${LOCAL_STORAGE_PREFIX}${today.toISOString().split('T')[0]}`;

       let loadedState = null;
       const savedStateJSON = localStorage.getItem(currentGameDateKey);
        if (savedStateJSON) {
             try {
                 const state = JSON.parse(savedStateJSON);
                 if (state.targetWord === currentTargetWord) {
                     loadedState = state;
                 } else {
                     console.warn(`Saved word for today (${state.targetWord}) does not match expected word (${currentTargetWord}). Starting fresh for today.`);
                 }
             } catch (e) {
                 console.error("Error loading today's saved state:", e);
             }
        }

        if (loadedState) {
             guesses = loadedState.guesses || [];
             currentRowIndex = loadedState.currentRowIndex || 0;
             isGameOver = loadedState.isGameOver || false;
             keyStatuses = loadedState.keyStatuses || {}; // Load key statuses for today
             // Validate keyStatuses content
             for (const key in keyStatuses) {
                const validStatuses = ['correct', 'present', 'absent', null];
                if (!validStatuses.includes(keyStatuses[key])) {
                    delete keyStatuses[key];
                }
             }
        } else {
             // No saved state for today, start a fresh game
             guesses = [];
             currentRowIndex = 0;
             isGameOver = false;
             keyStatuses = {}; // Start with empty key statuses for a new day
        }
        lastGuessSpecificInfo = {}; // Always reset this on load - not used for state but good practice
   }


   function enableInput() {
        window.removeEventListener('keydown', handlePhysicalKey); // Remove existing listener to prevent duplicates
        window.addEventListener('keydown', handlePhysicalKey); // Add listener back

        keyboardElement.querySelectorAll('.key').forEach(btn => {
            if (!btn.classList.contains('placeholder')) {
               // Restore click handlers and default cursor for playable keys
               const keyText = btn.dataset.key;
               if (keyText === ENTER_KEY) {
                   btn.onclick = handleSubmit;
               } else if (keyText === DELETE_KEY) {
                   btn.onclick = handleDelete;
               } else {
                   btn.onclick = () => handleKeyClick(keyText);
               }
               btn.style.cursor = 'pointer';
               btn.disabled = false; // Ensure button is enabled
               btn.style.opacity = ''; // Remove potential disabled opacity
            }
        });
   }


  // --- Word Processing ---
   function splitWord(word) {
    const chars = [];
    const lowerWord = String(word || '').toLowerCase();
    for (let i = 0; i < lowerWord.length; i++) {
      // Check for the digraph 'Õ¸Ö‚'
      if (lowerWord[i] === 'Õ¸' && i + 1 < lowerWord.length && lowerWord[i + 1] === 'Ö‚') {
        chars.push('Õ¸Ö‚');
        i++; // Skip the 'Ö‚'
      } else {
        chars.push(lowerWord[i]);
      }
    }
     return chars;
   }

  // --- UI Building ---
  function buildBoard() {
    boardElement.innerHTML = '';
    for (let i = 0; i < MAX_ROWS; i++) {
        const row = document.createElement('div');
        row.className = 'row';
        for (let j = 0; j < WORD_LENGTH; j++) {
            const tile = document.createElement('div');
            tile.className = 'tile';
            tile.innerHTML = '<div></div>';
            row.appendChild(tile);
        }
        boardElement.appendChild(row);
    }
  }

  function buildKeyboard() {
    keyboardTopRowElement.innerHTML = '';
    keyboardMainGridElement.innerHTML = '';

    // Top Row
    [ENTER_KEY, DELETE_KEY].forEach(keyText => {
        const keyElement = document.createElement('button');
        keyElement.textContent = keyText;
        keyElement.className = 'key';
        if (keyText === ENTER_KEY) {
            keyElement.classList.add('enter');
            // Add handler only if input is enabled
            if (!isGameOver && currentWordOffset === dayOffset) keyElement.onclick = handleSubmit;
        } else {
            keyElement.classList.add('delete');
             // Add handler only if input is enabled
            if (!isGameOver && currentWordOffset === dayOffset) keyElement.onclick = handleDelete;
        }
        keyElement.dataset.key = keyText; // Add data-key for these too
        keyboardTopRowElement.appendChild(keyElement);
    });

    // Main Grid - Use the currentLayout
    currentLayout.forEach(rowKeys => {
        rowKeys.forEach(keyText => {
            const keyElement = document.createElement('button');
            keyElement.textContent = keyText;
            keyElement.className = 'key';
             // Handle placeholder keys
            if (!keyText) {
                 keyElement.classList.add('placeholder');
                 keyElement.disabled = true;
                 keyElement.style.cursor = 'default';
                 keyElement.dataset.key = ''; // Add dataset.key even for placeholder
            } else {
                keyElement.dataset.key = keyText;
                 // Add handler only if input is enabled
                if (!isGameOver && currentWordOffset === dayOffset) keyElement.onclick = () => handleKeyClick(keyText);
            }
            keyboardMainGridElement.appendChild(keyElement);
        });
    });

    // Set body attribute for CSS targeting
    document.body.setAttribute('data-keyboard-layout', currentLayoutName);
  }

    // --- Keyboard Layout Switcher ---
    function switchLayout() {
        // Toggle layout name
        currentLayoutName = (currentLayoutName === 'phonetic') ? 'alphabetical' : 'phonetic';

        // Set the corresponding layout array
        currentLayout = (currentLayoutName === 'phonetic') ? keyboardPhoneticLayout : keyboardAlphabeticalLayout;

        // Update button text
        toggleBtnLayout.textContent = LAYOUT_NAMES[currentLayoutName];

        // Rebuild the keyboard with the new layout
        buildKeyboard();

        // *** IMPORTANT: Recalculate and adjust size after rebuilding the keyboard ***
        adjustBoardSize();

        // Update key highlights on the new keyboard (using the current game's keyStatuses)
        updateKeyboardHighlight();

        // Save the preference (only saves layout, not game state unless it's today's game)
        saveState();
    }


  // --- UI Updating & State Restoration ---
  function redrawBoardFromState() {
     const rows = boardElement.querySelectorAll('.row');
     rows.forEach((row, rowIndex) => {
        const tiles = row.querySelectorAll('.tile');
        if (rowIndex < guesses.length) {
             const guessData = guesses[rowIndex];
             tiles.forEach((tile, tileIndex) => {
                const tileInner = tile.querySelector('div');
                if (!tileInner) return;
                const letterData = guessData[tileIndex] || { letter: '', status: '' };
                tileInner.textContent = letterData.letter;
                tile.classList.remove('correct', 'present', 'absent', 'filled');
                if (letterData.letter) {
                     tile.classList.add('filled');
                     if (letterData.status) {
                         tile.classList.add(letterData.status);
                     }
                }
             });
        } else {
              tiles.forEach(tile => {
                 const tileInner = tile.querySelector('div');
                 if (tileInner) tileInner.textContent = '';
                 tile.classList.remove('correct', 'present', 'absent', 'filled');
              });
        }
     });
  }

  // --- updateKeyboardHighlight uses cumulative status ---
  function updateKeyboardHighlight() {
    keyboardElement.querySelectorAll('.key[data-key]').forEach(keyElement => { // Select all keys, including placeholders (they won't have a meaningful status)
        const letter = keyElement.dataset.key;
        // Don't highlight placeholders or special keys
        if (!letter || letter === ENTER_KEY || letter === DELETE_KEY) return;

        const cumulativeStatus = keyStatuses[letter]; // Cumulative best for the *currently loaded game*

        // Remove old status classes
        keyElement.classList.remove('correct', 'present', 'absent', 'has-present');

        // Apply cumulative status
        if (cumulativeStatus) {
            keyElement.classList.add(cumulativeStatus);
        }
    });
}


   // --- Event Handlers ---
  function handleKeyClick(key) {
    // Only allow input for today's game if not game over
    if (isGameOver || currentGuess.length >= WORD_LENGTH || currentWordOffset !== dayOffset) {
        // If not today's game, show a message maybe? Or just ignore. Ignoring is cleaner.
        if (currentWordOffset !== dayOffset) {
             showMessage(`Ô´Õ¸Ö‚Ö„ Õ¯Õ¡Ö€Õ¸Õ² Õ¥Ö„ Õ­Õ¡Õ²Õ¡Õ¬ Õ´Õ«Õ¡ÕµÕ¶ Õ¡ÕµÕ½Ö…Ö€Õ¾Õ¡ Õ­Õ¡Õ²Õ¨Ö‰`, 1500);
             shakeRow(currentRowIndex); // Maybe shake the row?
        }
        return;
    }
    currentGuess.push(key);
    updateCurrentRowDisplay();
  }

  function handleDelete() {
    // Only allow input for today's game if not game over
    if (isGameOver || currentGuess.length === 0 || currentWordOffset !== dayOffset) {
         if (currentWordOffset !== dayOffset) {
             showMessage(`Ô´Õ¸Ö‚Ö„ Õ¯Õ¡Ö€Õ¸Õ² Õ¥Ö„ Õ­Õ¡Õ²Õ¡Õ¬ Õ´Õ«Õ¡ÕµÕ¶ Õ¡ÕµÕ½Ö…Ö€Õ¾Õ¡ Õ­Õ¡Õ²Õ¨Ö‰`, 1500);
             shakeRow(currentRowIndex);
        }
        return;
    }
    currentGuess.pop();
    updateCurrentRowDisplay();
  }

  // --- handleSubmit updates cumulative statuses ---
  function handleSubmit() {
    // Only allow input for today's game if not game over
    if (isGameOver || currentWordOffset !== dayOffset) {
         if (currentWordOffset !== dayOffset) {
             showMessage(`Ô´Õ¸Ö‚Ö„ Õ¯Õ¡Ö€Õ¸Õ² Õ¥Ö„ Õ­Õ¡Õ²Õ¡Õ¬ Õ´Õ«Õ¡ÕµÕ¶ Õ¡ÕµÕ½Ö…Ö€Õ¾Õ¡ Õ­Õ¡Õ²Õ¨Ö‰`, 1500);
             shakeRow(currentRowIndex);
         } else { // isGameOver is true for today's game
             const finalMsg = guesses.length >= MAX_ROWS ? `ÕŠÕ¡Ö€Õ¿Õ¸Ö‚Õ©ÕµÕ¸Ö‚Õ¶Ö‰ Ô±ÕµÕ½Ö…Ö€Õ¾Õ¡ Õ¢Õ¡Õ¼Õ¨Õ ${currentTargetWord}` : 'ðŸŽ‰ Õ€Õ¡Õ²Õ©Õ¡Õ¶Õ¡Õ¯ ðŸŽ‰';
             showMessage(finalMsg, 3000); // Show win/loss message again
         }
        return;
    }

    if (currentGuess.length !== WORD_LENGTH) {
      shakeRow(currentRowIndex);
      showMessage("Ô±Õ¶Õ¢Õ¡Õ¾Õ¡Ö€Õ¡Ö€ Õ¿Õ¡Õ¼Õ¥Ö€Õ« Ö„Õ¡Õ¶Õ¡Õ¯", 1500);
      return;
    }

    const guessString = currentGuess.join('');

    // Check if the word is in the valid word list
    if (!WORDS.includes(guessString)) {
        shakeRow(currentRowIndex);
        showMessage("ÕÕ¾ÕµÕ¡Õ¬ Õ¢Õ¡Õ¼Õ¨ Õ´Õ¥Ö€ Õ¢Õ¡Õ¼Õ¡Ö€Õ¡Õ¶Õ¸Ö‚Õ´ Õ¹Õ¯Õ¡ :(", 1500);
        return;
    }

    const result = checkGuess(guessString);
    guesses.push(result);

    // Update CUMULATIVE keyStatuses based on the current guess result
    result.forEach(({ letter, status }) => {
        const currentStatus = keyStatuses[letter];
        if (status === 'correct') {
            keyStatuses[letter] = 'correct'; // Correct always overrides
        } else if (status === 'present' && currentStatus !== 'correct') {
            keyStatuses[letter] = 'present'; // Present overrides absent/null, but not correct
        } else if (status === 'absent' && !currentStatus) {
             // Mark absent only if it wasn't marked correct or present previously
             // and it was absent *in this specific guess*.
             // The simplified logic below works with cumulative state:
             // only mark absent if there's no status yet.
            keyStatuses[letter] = 'absent'; // Absent only sets if no status yet (not overriding present/correct)
        }
    });

    // Animate and update display
    animateGuessResult(currentRowIndex, result);
    updateKeyboardHighlight(); // Update keyboard based on cumulative state

    // Proceed to next row or end game after animation delay
    setTimeout(() => {
        currentRowIndex++;
        currentGuess = [];
        saveState(); // Save the updated CUMULATIVE keyStatuses and layout preference for TODAY's game

        checkWinLoss(guessString); // Check game over status for TODAY's game
    }, WORD_LENGTH * 150 + 300); // Wait for tile animation + a little buffer
  }


  function handlePhysicalKey(e) {
     // Only allow input for today's game if not game over
     if (isGameOver || currentWordOffset !== dayOffset) {
          // Don't prevent default for standard keys if not today's game,
          // but maybe prevent it for enter/backspace if they trigger messages.
          // Let's allow default unless it's Enter/Backspace in a finished game.
          if (isGameOver && (e.key === 'Enter' || e.key === 'Backspace' || e.key === 'Delete')) {
               e.preventDefault();
          }
          // No input processing for past games or finished games
         return;
     }

     let key = e.key;
     // Prevent default for keys we handle in the game
     if (key.length === 1 || key === 'Backspace' || key === 'Delete' || key === 'Enter') {
        e.preventDefault();
     }


     if (key.length > 1 && key !== 'Backspace' && key !== 'Delete' && key !== 'Enter') {
         return;
     }
     key = key.toLowerCase();

     if (key === 'enter') {
         handleSubmit();
     } else if (key === 'backspace' || key === 'delete') {
         handleDelete();
     } else {
         // Check if the pressed key is a valid Armenian letter or ' Õ¸Ö‚' from the `allLetters` array.
         // This validates physical input based on accepted characters, not the virtual layout.
         if (allLetters.includes(key)) {
             if (currentGuess.length < WORD_LENGTH) {
                 handleKeyClick(key);
             }
         }
     }
  }


  // --- Game Logic ---
  function checkGuess(guessString) {
     const guessChars = splitWord(guessString);
     const result = [];
     const targetCopy = [...parsedCurrentTarget]; // Use the currently loaded target word

     // Initialize result array structure
     for(let i = 0; i < WORD_LENGTH; i++) {
         result[i] = { letter: guessChars[i], status: '' };
     }

     // Pass 1: Correct
     for (let i = 0; i < WORD_LENGTH; i++) {
         if (guessChars[i] === parsedCurrentTarget[i]) {
             result[i].status = 'correct';
             targetCopy[i] = null; // Mark this letter in target as used
         }
     }

     // Pass 2: Present/Absent
     for (let i = 0; i < WORD_LENGTH; i++) {
         if (result[i].status === 'correct') continue; // Skip already matched correct letters

         const letter = guessChars[i];
         const indexInTarget = targetCopy.indexOf(letter); // Search in remaining target letters

         if (indexInTarget !== -1) {
             result[i].status = 'present';
             targetCopy[indexInTarget] = null; // Mark this letter in target as used
         } else {
             result[i].status = 'absent';
         }
     }
     return result;
  }

   // Check win/loss only applies to the *current* day's game
  function checkWinLoss(lastGuessString) {
     if (currentWordOffset !== dayOffset) return; // Only check win/loss for today's game

     if (splitWord(lastGuessString).join('') === parsedCurrentTarget.join('')) {
         showMessage('ðŸŽ‰ Õ€Õ¡Õ²Õ©Õ¡Õ¶Õ¡Õ¯ ðŸŽ‰', 5000); // Short duration for win message
         isGameOver = true;
         disableInput();
         saveState(); // Save final state (win) and layout
     } else if (currentRowIndex >= MAX_ROWS) {
          showMessage(`ÕŠÕ¡Ö€Õ¿Õ¸Ö‚Õ©ÕµÕ¸Ö‚Õ¶Ö‰ Ô±ÕµÕ½Ö…Ö€Õ¾Õ¡ Õ¢Õ¡Õ¼Õ¨Õ ${currentTargetWord}`, 0); // Indefinite duration for loss message
          isGameOver = true;
          disableInput();
          saveState(); // Save final state (loss) and layout
     }
  }


  // --- Animations & Messages ---
  function animateGuessResult(rowIndex, result) {
     const row = boardElement.querySelectorAll('.row')[rowIndex];
     if (!row) return; // Ensure row exists

     const tiles = row.querySelectorAll('.tile');
     tiles.forEach((tile, index) => {
         const { letter, status } = result[index];
         const tileInner = tile.querySelector('div');

         if (!tileInner) return;

         // Set text and 'filled' class immediately
         tileInner.textContent = letter;
         if (letter) {
            tile.classList.add('filled');
         } else {
             tile.classList.remove('filled');
         }
         // Remove any old status classes just in case
         tile.classList.remove('correct', 'present', 'absent');


         // Apply status class with stagger and potentially a flip animation (CSS needed)
         setTimeout(() => {
             if (status) {
                tile.classList.add(status);
                // You could add a flip animation class here if defined in CSS
                // tile.classList.add('flip'); // Example
             }
         }, index * 150); // Stagger delay for status reveal/animation
     });
     // Optional: Add event listener for animation end if using CSS animations
     // row.addEventListener('animationend', handleAnimationEnd, { once: true });
  }


  function shakeRow(rowIndex) {
    const row = boardElement.querySelectorAll('.row')[rowIndex];
    if (row) {
        row.classList.add('shake');
        row.addEventListener('animationend', () => {
            row.classList.remove('shake');
        }, { once: true });
    }
  }

   function showMessage(msg, duration = 2000) {
        clearTimeout(messageTimeout);
        messageElement.textContent = msg;
        messageElement.classList.add('show');
        // Remove 'hide' class if it was added for indefinite messages
        messageElement.classList.remove('hide');
        if (duration > 0) {
            messageTimeout = setTimeout(() => {
                messageElement.classList.remove('show');
                 // Optional: Add a 'hide' class if duration is 0 (indefinite) to maybe style differently
                 // messageElement.classList.add('hide');
            }, duration);
        }
   }


   // --- Previous Games Modal ---
   function openPreviousGamesModal() {
        previousGamesListElement.innerHTML = ''; // Clear previous list
        const numberOfGamesToShow = Math.min(dayOffset + 1, 100); // Show up to last 100 games (including today)

        // Generate list items backwards from today
        for (let i = 0; i < numberOfGamesToShow; i++) {
            const gameOffset = dayOffset - i;
            const gameNumber = gameOffset + 1;
            const gameDate = new Date(startDate);
            gameDate.setDate(startDate.getDate() + gameOffset);
            const dateString = gameDate.toLocaleDateString('hy-AM', { year: 'numeric', month: 'numeric', day: 'numeric' }); // Format date as Armenian
            const wordForThisGame = WORDS.length > 0 ? WORDS[gameOffset % WORDS.length] : "Õ½Õ­Õ¡Õ¬";

            const listItem = document.createElement('li');
            listItem.dataset.gameOffset = gameOffset;
            listItem.textContent = `#${gameNumber} - ${dateString}`;

            // Optionally indicate if the game was played/won/lost based on local storage
             const gameDateKey = `${LOCAL_STORAGE_PREFIX}${gameDate.toISOString().split('T')[0]}`;
             const savedStateJSON = localStorage.getItem(gameDateKey);
             if (savedStateJSON) {
                 try {
                     const state = JSON.parse(savedStateJSON);
                      if (state.targetWord === wordForThisGame) { // Basic validation
                         let statusIndicator = '';
                         if (state.isGameOver) {
                             const lastGuessString = state.guesses.length > 0 ? state.guesses[state.guesses.length - 1].map(g => g.letter).join('') : '';
                             if (splitWord(lastGuessString).join('') === splitWord(wordForThisGame).join('')) {
                                 statusIndicator = ' (âœ…)'; // Win
                             } else if (state.currentRowIndex >= MAX_ROWS) {
                                  statusIndicator = ' (âŒ)'; // Loss
                              } else {
                                   statusIndicator = ' (...)'; // Played, but not finished? (Unlikely with isGameOver logic)
                              }
                          } else if (state.guesses.length > 0) {
                                statusIndicator = ' (...)'; // Started but not finished
                          }
                         listItem.textContent += statusIndicator;
                     }
                 } catch (e) {
                     console.error(`Error parsing state for game ${gameNumber}:`, e);
                 }
             }


            // Add click listener to load this game
            listItem.addEventListener('click', () => {
                loadGameByOffset(gameOffset);
                closePreviousGamesModal();
            });

            previousGamesListElement.appendChild(listItem);
        }

        // Show the modal
        previousGamesModal.classList.add('visible');
   }

   function closePreviousGamesModal() {
       previousGamesModal.classList.remove('visible');
       // Clear the list content when closing
       previousGamesListElement.innerHTML = '';
   }

   // Handles clicks on the modal overlay itself to close it
   function handleModalOverlayClick(event) {
       if (event.target === previousGamesModal) {
           closePreviousGamesModal();
       }
   }


   // Loads a specific game based on its offset from the start date
   function loadGameByOffset(offset) {
        // Determine the target word and state key for this offset
        const targetDate = new Date(startDate);
        targetDate.setDate(startDate.getDate() + offset);
        const dateKey = `${LOCAL_STORAGE_PREFIX}${targetDate.toISOString().split('T')[0]}`;
        const wordForOffset = WORDS.length > 0 ? WORDS[offset % WORDS.length] : "Õ½Õ­Õ¡Õ¬";

        let loadedState = null;
        const savedStateJSON = localStorage.getItem(dateKey);
        if (savedStateJSON) {
             try {
                 const state = JSON.parse(savedStateJSON);
                 // Validate that the word in the saved state matches the word for this day
                 if (state.targetWord === wordForOffset) {
                     loadedState = state;
                 } else {
                     console.warn(`Saved word for offset ${offset} does not match expected word. Starting fresh for this day.`);
                 }
             } catch (e) {
                 console.error(`Error loading state for offset ${offset}:`, e);
             }
        }

        // Set the global state variables for the loaded game
        currentWordOffset = offset;
        currentTargetWord = wordForOffset;
        parsedCurrentTarget = splitWord(currentTargetWord);

        if (loadedState) {
            guesses = loadedState.guesses || [];
            currentRowIndex = loadedState.currentRowIndex || 0;
            isGameOver = loadedState.isGameOver || false;
            // Load key statuses specific to this game number
            keyStatuses = loadedState.keyStatuses || {};
             // Validate keyStatuses content
             for (const key in keyStatuses) {
                const validStatuses = ['correct', 'present', 'absent', null];
                if (!validStatuses.includes(keyStatuses[key])) {
                    delete keyStatuses[key];
                }
             }
        } else {
             // No saved state, reset game state for this word/day
             guesses = [];
             currentRowIndex = 0;
             isGameOver = false;
             keyStatuses = {}; // Reset key statuses for an unplayed game
        }

        // Update UI based on the loaded state
        updateGameNumberDisplay(); // Update the game number in the header
        buildBoard(); // Rebuild the board structure
        redrawBoardFromState(); // Populate the board with the loaded guesses
        updateKeyboardHighlight(); // Update keyboard highlight based on the loaded key statuses

        // Clear any old messages
        showMessage('', 0); // Show empty message with duration 0 to clear it

        // Manage input based on the loaded game's state (only playable if it's today's game)
        if (isGameOver) {
             const lastGuessString = guesses.length > 0 ? guesses[guesses.length - 1].map(g => g.letter).join('') : '';
             if (splitWord(lastGuessString).join('') !== parsedCurrentTarget.join('')) {
                 showMessage(`ÕŠÕ¡Ö€Õ¿Õ¸Ö‚Õ©ÕµÕ¸Ö‚Õ¶Ö‰ Ô±ÕµÕ½Ö…Ö€Õ¾Õ¡ Õ¢Õ¡Õ¼Õ¨Õ ${currentTargetWord}`, 0);
             } else {
                 showMessage('ðŸŽ‰ Õ€Õ¡Õ²Õ©Õ¡Õ¶Õ¡Õ¯ ðŸŽ‰', 0);
             }
             disableInput(); // Disable input if the loaded game is over
        } else if (currentWordOffset === dayOffset) {
            // If loading today's unfinished game
            enableInput(); // Enable input
        } else {
            // If loading a historical, unfinished game
            disableInput(); // Disable input
            showMessage(`Ô´Õ«Õ¿Õ¡Ö€Õ¯Õ¾Õ¸Ö‚Õ´ Õ§ Õ­Õ¡Õ² #${currentWordOffset + 1}. Ô´Õ¸Ö‚Ö„ Õ¯Õ¡Ö€Õ¸Õ² Õ¥Ö„ Õ­Õ¡Õ²Õ¡Õ¬ Õ´Õ«Õ¡ÕµÕ¶ Õ¡ÕµÕ½Ö…Ö€Õ¾Õ¡ Õ­Õ¡Õ²Õ¨Ö‰`, 3000);
        }

         // If loading a historical game (even a completed one), maybe prevent future guesses?
         // The `handleKeyClick`, `handleDelete`, `handleSubmit` already check `currentWordOffset !== dayOffset`.
         // `disableInput` handles the keyboard buttons and physical keys listener. This seems correct.
   }


  // --- Theme Toggle ---
  toggleBtnTheme.onclick = () => {
    const isDark = document.body.classList.toggle('dark');
    const theme = isDark ? 'dark' : 'light';
    toggleBtnTheme.textContent = isDark ? 'â˜€ï¸' : 'ðŸŒ—';
    localStorage.setItem('theme', theme);
  };

  // --- Dynamic Board Sizing for Small Screens (and large screens too) ---
  function adjustBoardSize() {
      const viewportHeight = window.innerHeight;

      // Get references to non-board elements that occupy vertical space
      const h1 = document.querySelector('h1');
      const subtitle = document.querySelector('.subtitle');
      const keyboard = document.getElementById('keyboard'); // Now a direct child of body
      const mainContentStyle = getComputedStyle(mainContent); // Get style for main content padding
      const boardContainer = document.querySelector('.board-container'); // Need this to get its margins

      // Check if all required elements exist
      if (!h1 || !subtitle || !keyboard || !boardContainer || !boardElement || !mainContent) {
          console.warn("adjustBoardSize: One or more elements not found.");
          return; // Exit if critical elements are missing
      }

      // Calculate the total height occupied by non-board elements including their margins/padding
      let nonBoardHeight = 0;
      const flowElements = [h1, subtitle, keyboard]; // Elements in the normal document flow that take vertical space
      flowElements.forEach(el => {
          const style = getComputedStyle(el);
          nonBoardHeight += el.offsetHeight; // Includes padding and border
          nonBoardHeight += parseFloat(style.marginTop) || 0;
          nonBoardHeight += parseFloat(style.marginBottom) || 0;
      });

       // Also account for padding on the main content div
       nonBoardHeight += parseFloat(mainContentStyle.paddingTop) || 0;
       nonBoardHeight += parseFloat(mainContentStyle.paddingBottom) || 0;
       /* Message container is fixed position, its height doesn't affect flow space
          unless we need to ensure there's space below it, but standard flow should
          push things down correctly if it's positioned fixed.
          Let's re-evaluate if its height should be factored in.
          If it's fixed, it's out of flow. The space it covers *visually* might obscure
          content, but doesn't affect the calculation of available space *between*
          flow elements.
          However, if the message is very tall, it might overlay the top of the board.
          The current fixed position means it doesn't contribute to pushing the board down.
          Let's keep it out of the `nonBoardHeight` calculation for now, as it's common
          for fixed elements to be outside the normal layout calculation.
          If issues arise, we might need to add padding-top to main-content dynamically
          or increase the buffer.
       */


      // Account for the board container's own vertical margins
      const boardContainerStyle = getComputedStyle(boardContainer);
      const boardContainerMarginTop = parseFloat(boardContainerStyle.marginTop) || 0;
      const boardContainerMarginBottom = parseFloat(boardContainerStyle.marginBottom) || 0;
      const boardContainerVerticalMargins = boardContainerMarginTop + boardContainerMarginBottom;

      // Available vertical space *for the board grid itself* (excluding its margins and its container's margins)
      const availableBoardHeight = viewportHeight - nonBoardHeight - boardContainerVerticalMargins;

      // Get the current grid gaps from the board element (accounts for media queries)
      const boardStyle = getComputedStyle(boardElement);
      const rowGap = parseFloat(boardStyle.rowGap) || 0;
      const columnGap = parseFloat(boardStyle.columnGap) || 0;

      // Calculate the maximum possible tile size based on the available board height
      // The board has MAX_ROWS rows and (MAX_ROWS - 1) gaps vertically.
      // We add a small buffer to prevent edge cases causing scrollbars.
      const buffer = 8;
      const maxTileSizeBasedOnHeight = (availableBoardHeight - (MAX_ROWS - 1) * rowGap - buffer) / MAX_ROWS;

      // Calculate the required board width to fit this max tile size horizontally
      const requiredBoardWidthFromHeight = (WORD_LENGTH * maxTileSizeBasedOnHeight) + (WORD_LENGTH - 1) * columnGap;


      // Determine the effective max width for the board.
      // This should be the minimum of the width needed to fit vertically
      // AND the max width allowed by the main content container.
      // The max width of the board container itself is handled by the CSS.
      // The JS calculation is primarily to *shrink* the board when vertical space is limited,
      // ensuring it fits without scroll. If vertical space is ample, we let CSS max-width take over.

       // Get the computed CSS max-width of the board container
       const tempMaxWidth = boardContainer.style.maxWidth; // Save current inline style
       boardContainer.style.maxWidth = ''; // Temporarily remove inline style to get CSS value
       const cssMaxWidthForBoardContainer = parseFloat(getComputedStyle(boardContainer).maxWidth);
       const finalCssMaxWidth = isNaN(cssMaxWidthForBoardContainer) ? Infinity : cssMaxWidthForBoardContainer; // Treat NaN as no CSS limit
       boardContainer.style.maxWidth = tempMaxWidth; // Restore inline style


      // The target width is the smaller of the width required for vertical fit
      // and the CSS max-width defined for the board-container.
      const targetWidth = Math.min(requiredBoardWidthFromHeight, finalCssMaxWidth);


      // Apply the calculated width as max-width to the board container
      // Ensure the calculated size is reasonable and positive
      const minReasonableTileSize = 30;
      const minReasonableBoardWidth = (WORD_LENGTH * minReasonableTileSize) + (WORD_LENGTH - 1) * columnGap;

      if (targetWidth > minReasonableBoardWidth && targetWidth > 0) {
          boardContainer.style.maxWidth = `${targetWidth}px`;
          // console.log(`Adjusted: Viewport H=${viewportHeight.toFixed(1)}, Needed W (Vert)=${requiredBoardWidthFromHeight.toFixed(1)}, CSS MaxW=${finalCssMaxWidth.toFixed(1)}, Target W=${targetWidth.toFixed(1)}`);
      } else {
           boardContainer.style.maxWidth = ''; // Revert to CSS
           // console.log(`Default: Viewport H=${viewportHeight.toFixed(1)}, Needed W (Vert)=${requiredBoardWidthFromHeight.toFixed(1)}, CSS MaxW=${finalCssMaxWidth.toFixed(1)}, Target W=${targetWidth.toFixed(1)} (Reverted)`);
      }
  }


  // --- Start the game ---
  // Use DOMContentLoaded to ensure HTML is ready before running init
  document.addEventListener('DOMContentLoaded', () => {
      // First, load the initial state for today's game
      loadInitialStateForToday();
      // Then, initialize the UI based on that state
      init();
      // Finally, adjust size based on initial viewport size
      adjustBoardSize();
  });

  // Adjust size whenever the window is resized or layout changes
  window.addEventListener('resize', adjustBoardSize);

</script>

</body>
</html>
