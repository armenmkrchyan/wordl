<!DOCTYPE html>
<html lang="hy">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0"/>
  <title>Wordle üá¶üá≤</title>
  <style>
    /* --- Global Reset & Box Sizing --- */
    html {
        box-sizing: border-box;
        height: 100%; /* Ensure html takes full height */
        overflow-y: auto; /* Allow scrolling if content exceeds viewport */
    }
    *, *:before, *:after {
        box-sizing: inherit;
    }

    html, body {
        min-height: 100%; /* Ensure body can fill viewport */
        margin: 0;
        padding: 0; /* Ensure no default padding */
    }
    body {
      font-family: sans-serif;
      display: flex;
      flex-direction: column; /* Stack children vertically */
      align-items: center; /* Center children horizontally */
      transition: background 0.3s, color 0.3s;
      background-color: var(--bg-color, #fff);
      color: var(--text-color, #000);
    }

    :root {
        --bg-color: #fff;
        --text-color: #000;
        --tile-border-empty: #aaa;
        --tile-border-filled: #666;
        --key-bg: #d3d6da;
        --key-text: #1a1a1b;
        --correct-bg: #538d4e;
        --present-bg: #b59f3b;
        --absent-bg: #3a3a3c;
        --delete-key-bg: #dc3545; /* Red */
        --enter-key-bg: #538d4e; /* Green */
        --tile-text-light: #000;
        --tile-text-dark: #fff;
        --link-color: #007bff;
         /* Added for modal */
        --modal-bg: #fff;
        --modal-border: #ccc;
        --modal-text: #000;
        --list-item-hover-bg: #eee;
    }

     .dark {
        --bg-color: #121213;
        --text-color: #fff;
        --tile-border-empty: #3a3a3c;
        --tile-border-filled: #565758;
        --key-bg: #818384;
        --key-text: #dadce0;
        --tile-text-light: #fff;
        --link-color: #64b5f6;
        /* Added for modal dark mode */
        --modal-bg: #222;
        --modal-border: #555;
        --modal-text: #fff;
        --list-item-hover-bg: #333;
    }


    .main-content {
        flex: 1 1 auto; /* Allows growing and shrinking, takes available space */
        width: 100%;
        display: flex;
        flex-direction: column; /* Stack children vertically */
        align-items: center; /* Center children horizontally */
        max-width: 550px; /* Max width for the main content area */
        margin-left: auto;
        margin-right: auto;
        padding-left: 5px;
        padding-right: 5px;
        padding-bottom: 10px; /* Added some padding to the bottom of main-content */
        /* Ensure main-content aligns children even if they don't fill the width */
        align-self: center;
        position: relative; /* Needed for absolute positioning of child buttons */
    }

    h1 {
      margin-top: 10px;
      margin-bottom: 2px;
      font-size: 1.5rem;
      white-space: nowrap;
      display: flex; /* Use flex to align items within h1 */
      align-items: center;
      gap: 8px; /* Space between title and number/flag */
    }
     h1 img {
         height: 0.7em;
         vertical-align: middle;
     }
    /* Style for the game number */
    #game-number {
        font-size: 0.8em; /* Slightly smaller than main title */
        font-weight: normal; /* Not as bold as the title */
        cursor: pointer; /* Indicate it's clickable */
        text-decoration: underline; /* Indicate it's a link/clickable */
        color: inherit; /* Inherit color from h1 */
    }
     #game-number:hover {
         color: var(--link-color); /* Highlight on hover */
     }


    .subtitle {
        font-size: 0.9rem;
        color: #777;
        margin-top: 0;
        margin-bottom: 5px;
    }
    .dark .subtitle {
        color: #aaa;
    }
     .subtitle a {
        color: inherit; /* Inherit color from subtitle */
     }
     .subtitle a:hover {
        text-decoration: underline; /* Keep underline on hover */
     }


    .board-container {
        display: flex;
        justify-content: center;
        align-items: center;
        width: 100%; /* Board container takes full width of main-content */
        /* Removed max-width here - JS will control it */
        /* max-width: 350px; */
        margin: 8px 0; /* Keep vertical margins */
        flex: 1 1 auto; /* Allow board container to grow/shrink within main-content */
        min-height: 0; /* Allow flex item to shrink below content size */
    }

    .board {
      display: grid;
      grid-template-rows: repeat(6, 1fr);
      grid-gap: 4px;
      width: 100%; /* Board takes full width of its container */
      /* The height will be determined by width due to tile aspect ratio */
    }

    .row {
        display: grid;
        grid-template-columns: repeat(5, 1fr);
        grid-gap: 4px;
    }

    .tile {
      width: 100%;
      aspect-ratio: 1 / 1;
      border: 2px solid var(--tile-border-empty);
      font-size: clamp(1.5rem, 6vw, 2rem);
      font-weight: bold;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      text-transform: lowercase;
      color: var(--tile-text-light);
      background-color: var(--bg-color);
      transition: background-color 0.3s, border-color 0.3s;
    }
    .tile > div {
        display: flex;
        align-items: center;
        justify-content: center;
        width: 100%;
        height: 100%;
        color: inherit;
    }
    .tile.filled {
        border-color: var(--tile-border-filled);
    }
    .tile.correct { background-color: var(--correct-bg); color: var(--tile-text-dark); border-color: var(--correct-bg); }
    .tile.present { background-color: var(--present-bg); color: var(--tile-text-dark); border-color: var(--present-bg); }
    .tile.absent { background-color: var(--absent-bg); color: var(--tile-text-dark); border-color: var(--absent-bg); }

    #keyboard {
      flex-shrink: 0; /* Prevent keyboard from shrinking */
      width: 100%;
      max-width: 550px; /* Align keyboard with main content */
      margin-left: auto;
      margin-right: auto;
      display: flex;
      flex-direction: column;
      gap: 4px;
      padding: 0 3px;
      margin-top: 5px;
      margin-bottom: 20px; /* Changed bottom margin to 20px */
      align-self: center; /* Center keyboard horizontally */
    }

    #keyboard-top-row {
        display: grid;
        /* Make Enter and Delete columns equal size */
        grid-template-columns: 1fr 1fr;
        gap: 3px;
    }

    #keyboard-main-grid {
        display: grid;
        /* Default to Alphabetical grid columns, overridden by data attribute */
        grid-template-columns: repeat(8, 1fr);
        gap: 3px;
    }

    /* Specific grid columns for Phonetic layout main grid */
    body[data-keyboard-layout="phonetic"] #keyboard-main-grid {
         grid-template-columns: repeat(10, 1fr); /* Phonetic layout rows have 10 slots */
         gap: 3px; /* Maintain consistent gap */
    }

     /* Placeholder key styling - visible only in layouts that need it for alignment */
     .key.placeholder {
        background: transparent;
        pointer-events: none;
        border-color: transparent;
        visibility: hidden; /* Hidden by default */
     }

    body[data-keyboard-layout="phonetic"] #keyboard-main-grid .key.placeholder {
        visibility: visible; /* Make placeholder visible in phonetic layout */
        background: rgba(0,0,0,0.03); /* Subtle background */
     }


    .key {
      min-height: 40px;
      /* Adjusted font-size clamp to allow single letters to be larger */
      font-size: clamp(1.2rem, 5vw, 1.8rem);
      font-weight: bold;
      border: 3px solid transparent;
      border-radius: 4px;
      background-color: var(--key-bg);
      color: var(--key-text);
      cursor: pointer;
      transition: background-color 0.2s, color 0.2s, border-color 0.2s;
      display: flex;
      justify-content: center;
      align-items: center;
      user-select: none;
      touch-action: manipulation;
      text-transform: lowercase;
      padding: 0;
      min-width: 0;
    }
    .key:hover {
        filter: brightness(90%);
    }

    .key.enter,
    .key.delete {
      /* Increased font size for Enter/Delete keys */
      font-size: clamp(0.9rem, 3.5vw, 1.2rem); /* Adjusted clamp values */
      color: white;
      border-width: 3px;
      border-style: solid;
    }
    .key.enter {
        background-color: var(--enter-key-bg);
        border-color: var(--enter-key-bg);
        white-space: nowrap;
    }
    .key.delete {
         background-color: var(--delete-key-bg);
         border-color: var(--delete-key-bg);
         white-space: nowrap;
    }


    .key.correct {
      background-color: var(--correct-bg);
      color: var(--tile-text-dark);
      border-color: transparent;
    }
    .key.present {
      background-color: var(--present-bg);
      color: var(--tile-text-dark);
      border-color: transparent;
    }
    .key.absent {
      background-color: var(--absent-bg);
      color: var(--tile-text-dark);
      border-color: transparent;
    }

    .key.correct.has-present {
        border-width: 3px;
        border-style: solid;
        /* Using a different color for visibility, you might adjust this */
        border-color: #ffff00; /* Example: Yellow border */
    }


    .message-container {
        position: fixed;
        top: 70px;
        left: 50%;
        transform: translateX(-50%);
        min-height: 30px;
        z-index: 10;
        width: 90%;
        max-width: 350px;
    }
    .message {
      text-align: center;
      font-size: 1em;
      margin-top: 0.5rem;
      padding: 8px 10px;
      font-weight: bold;
      background-color: #333;
      color: white;
      border-radius: 5px;
      visibility: hidden;
      opacity: 0;
      transition: visibility 0s 1.5s, opacity 1.5s linear;
      white-space: normal;
      word-wrap: break-word;
    }
     .message.show {
        visibility: visible;
        opacity: 1;
        transition: opacity 0.3s linear;
     }

    /* Modal Styles */
    .modal-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.5);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 100;
        visibility: hidden;
        opacity: 0;
        transition: visibility 0s 0.3s, opacity 0.3s ease;
    }

    .modal-overlay.visible {
        visibility: visible;
        opacity: 1;
        transition-delay: 0s;
    }

    .modal-content {
        background-color: var(--modal-bg);
        color: var(--modal-text);
        padding: 20px;
        border-radius: 8px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
        max-width: 90%;
        max-height: 90%;
        overflow-y: auto; /* Add scroll for long lists */
        position: relative;
        width: 300px; /* Adjust modal width as needed */
        display: flex;
        flex-direction: column;
    }
    .dark .modal-content {
        background-color: var(--modal-bg);
        color: var(--modal-text);
    }

    .modal-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 15px;
        padding-bottom: 10px;
        border-bottom: 1px solid var(--modal-border);
    }
    .modal-header h3 {
        margin: 0;
        font-size: 1.2rem;
    }

    .modal-close {
        background: none;
        border: none;
        font-size: 1.5rem;
        cursor: pointer;
        color: inherit;
        padding: 0;
    }
    .modal-close:hover {
        opacity: 0.7;
    }

    #previous-games-list {
        list-style: none;
        padding: 0;
        margin: 0;
    }

    #previous-games-list li {
        padding: 8px 0;
        border-bottom: 1px solid var(--modal-border);
        cursor: pointer;
        transition: background-color 0.2s ease;
    }
    #previous-games-list li:last-child {
        border-bottom: none;
    }
     #previous-games-list li:hover {
         background-color: var(--list-item-hover-bg);
     }
    #previous-games-list li span {
        font-weight: bold;
        margin-right: 10px;
    }


    /* Theme and Layout Button Positioning */
    /* Position these absolutely within the main-content area */
    .main-content > #toggle-theme {
      position: absolute;
      top: 10px;
      right: 10px; /* Position Theme button on the right */
      margin-bottom: 0; /* Remove margin as position is absolute */
      padding: 6px 10px;
      font-size: 0.9rem;
      border-radius: 5px;
      cursor: pointer;
      border: 1px solid #ccc;
      background-color: #eee;
      color: #333;
      z-index: 20;
    }
    .dark .main-content > #toggle-theme {
        background-color: #333;
        color: white;
        border-color: #555;
    }

    .main-content > #toggle-layout {
      position: absolute;
      top: 10px;
      left: 10px; /* Position Layout button on the left */
      margin-bottom: 0; /* Remove margin as position is absolute */
      padding: 6px 10px;
      font-size: 0.9rem;
      border-radius: 5px;
      cursor: pointer;
      border: 1px solid #ccc;
      background-color: #eee;
      color: #333;
      z-index: 20;
       min-width: 80px; /* Added min-width to prevent text wrap */
       text-align: center; /* Center text in button */
    }
     .dark .main-content > #toggle-layout {
        background-color: #333;
        color: white;
        border-color: #555;
    }


    @keyframes shake {
      0%, 100% { transform: translateX(0); }
      10%, 30%, 50%, 70%, 90% { transform: translateX(-5px); }
      20%, 40%, 60%, 80% { transform: translateX(5px); }
    }
    .shake { animation: shake 0.6s ease-in-out; }


    /* Media Query for very small/short screens */
    @media (max-width: 340px), (max-height: 600px) {
        h1 {
            font-size: 1.3rem; /* Further reduce */
            margin-top: 8px;
        }
        h1 #game-number {
            font-size: 0.9em; /* Adjust game number size */
        }
        .subtitle {
            margin-bottom: 3px;
        }
         .main-content {
            padding-bottom: 5px; /* Reduce bottom padding for very short screens */
         }
        .board-container {
            margin: 5px 0;
            /* max-width controlled by JS */
        }
        .board, .row {
            grid-gap: 3px; /* Further reduce */
        }
        #keyboard {
            gap: 3px;
            padding: 0 2px;
            margin-top: 3px;
            margin-bottom: 15px; /* Adjusted bottom margin for small screens */
        }
        /* Adjust gaps/columns for smaller screens if needed, though JS might handle size */
         #keyboard-main-grid, #keyboard-top-row {
            gap: 2px; /* Further reduce default gap */
        }
        body[data-keyboard-layout="phonetic"] #keyboard-main-grid {
             grid-template-columns: repeat(10, 1fr); /* Maintain 10 columns */
             gap: 2px; /* Use the smaller gap */
        }


        .key {
            min-height: 36px; /* Further reduce */
            /* Adjusted font size for small screens */
            font-size: clamp(1rem, 3.5vw, 1.3rem); /* Adjusted clamp values */
        }
        .key.enter, .key.delete {
             /* Increased font size for Enter/Delete on small screens */
            font-size: clamp(0.8rem, 3vw, 1.1rem); /* Adjusted clamp values */
        }
        /* Adjust button positions relative to main-content padding/width */
        .main-content > #toggle-theme {
            padding: 4px 7px;
            font-size: 0.8rem;
            top: 5px;
            right: 5px; /* Maintain right position */
        }
        .main-content > #toggle-layout {
            padding: 4px 7px; /* Reduced padding */
            font-size: 0.8rem;
            top: 5px;
            left: 5px; /* Adjust position to the left */
             min-width: 70px; /* Adjust min-width */
        }
        .message-container {
            top: 60px; /* Adjust if needed */
        }
         .modal-content {
             width: 250px; /* Adjust modal width for small screens */
         }
    }

  </style>
</head>
<body>
  <div class="main-content">
      <h1>
          Wordle <img src="flag.png" alt="üá¶üá≤">
          <span id="game-number"></span> <!-- Game Number Placeholder -->
      </h1>
      <!-- Updated subtitle to be a link -->
      <p class="subtitle">by <a href="https://www.armblog.net" target="_blank">Armen Mkrtchyan</a></p>

      <button id="toggle-theme">üåó</button>
      <button id="toggle-layout"></button> <!-- Added Layout Toggle Button -->

      <div class="message-container">
         <div id="message" class="message"></div>
      </div>
      <div class="board-container">
         <div class="board" id="board"></div>
      </div>
  </div>
  <!-- Keyboard is now a direct child of body, AFTER main-content -->
  <div id="keyboard">
      <div id="keyboard-top-row"></div>
      <div id="keyboard-main-grid"></div>
  </div>

  <!-- Previous Games Modal -->
  <div id="previous-games-modal" class="modal-overlay">
      <div class="modal-content">
          <div class="modal-header">
              <h3>’Ü’°’≠’∏÷Ä’§ ’≠’°’≤’•÷Ä’®</h3>
              <button class="modal-close">√ó</button>
          </div>
          <ul id="previous-games-list">
              <!-- List items will be populated by JS -->
          </ul>
      </div>
  </div>


<script>
  const boardElement = document.getElementById('board');
  const keyboardTopRowElement = document.getElementById('keyboard-top-row');
  const keyboardMainGridElement = document.getElementById('keyboard-main-grid');
  const keyboardElement = document.getElementById('keyboard'); // Now a direct child of body
  const toggleBtnTheme = document.getElementById('toggle-theme');
  const toggleBtnLayout = document.getElementById('toggle-layout');
  const messageElement = document.getElementById('message');
  const mainContent = document.querySelector('.main-content'); // Still needed for sizing context
  const gameNumberElement = document.getElementById('game-number'); // Game number element
  const previousGamesModal = document.getElementById('previous-games-modal'); // Modal overlay
  const previousGamesListElement = document.getElementById('previous-games-list'); // Modal list
  const modalCloseButton = previousGamesModal.querySelector('.modal-close'); // Modal close button


  // --- Constants ---
  const WORD_LENGTH = 5;
  const MAX_ROWS = 6;
  const ENTER_KEY = '’®’∂’§’∏÷Ç’∂’•’¨';
  const DELETE_KEY = '’ª’∂’ª’•’¨';
  const LOCAL_STORAGE_LAYOUT_KEY = 'armenianWordleLayout';
  const LOCAL_STORAGE_PREFIX = 'armenianWordle-'; // Prefix for game state keys

  // --- Word List (Assumed 5 letters, lowercase) ---
  const WORDS = ['÷Ü’∏’ø’∏’∂','’∂’º’∂’°’Ø','’∞’∂’§’´’Ø','’∞’•’≤’∏÷Ç’Ø','’°÷Ä’£’∏’∂','’©÷Ä’©’∏÷Ç’º','’Ø’°’µ’∏÷Ç’∂','’¨’∏÷Ç’Æ’∏÷Ç’¥','’∑’°’∫’´’Ø','’∞÷Ä’∑’•’ª','’®’∂’¢’´’∑','’¥’•’ø’°’≤','’°’æ’•’¨’´','’°’∂’¶’•’∂','’∞’°’∑’´’æ','’©’°÷É’∏÷Ä','’≠’•’¨’°’º','’¨÷Ñ’æ’°’Æ','’§’°’µ’°’Ø','÷Å’•÷Ä’•’Ø','’Ø’ø÷Ä’∏÷Ç’Ø','’Ø’≥’≤’°’Ø','’æ÷Ä’°÷Å’´','÷Ñ’∏÷Ç’º’°’Ø','’¢’∏÷Ä’Ω’°','’Æ’°’≤’´’Ø','’∞’°’ø’´’Ø','’∂’´’∞’°÷Ä','’°÷Ä’±’°’Ø','’©÷Ä’©’∏÷Ç÷Ä','’ø’∏’Ø’∏÷Ç’∂','’•’≤÷á’∂’´','’Ω’°’∫’°’ø','’∂’•’≤’∏÷Ç÷Å','’¢’™’´’∑’Ø','’∏÷Ç’º’•’∂’´','’π’æ’•÷Ä’©','’¥’°’Ω’∏÷Ç÷Ä','’¥’•’©’∏’§','’©’∑’∑’∏÷Å','÷Ñ’∂÷Ñ’∏÷Ç’∑','÷É’•’©’°’Ø','’¥’•’§’´’°','’Ø÷Ä’∏÷Ç’∂’Ø','’Ø’°’©’Ω’°','’Ø’∏’°’¨’°','’£’´’ø’°’Ø','’Ø÷Ä’Ø’•’Ω','’æ’°÷Ä’°’¶','÷É’•’ø’∏÷Ç÷Ä','’Ø’ø÷Ä’´’≥','’∞’°’ø’∏÷Ç’Ø','’Ø’°’≤’∂’´','’∫’°’∫’´’Ø','’•’¨’∏÷Ç’µ’©','’°’Ø’°’¥’°','’¢’∏÷Ç’™’∏÷Ç’¥','’°’∂’Ø’°’∫','’¥’°’¥’∏÷Ç’¨','÷Ö÷Ä’£’°’∂','’°÷Ä÷á’∏’ø','’§’°’Ø’´’π','’©÷á’∂’∏÷Å','’∫’°’ø’´’æ','’¥’•’ø÷Ä’∏','÷Ö’©’µ’°’Ø','’§÷Ä’°’≠’ø','’•’º’°’∂’§','’°÷Ä’Ø’°’Æ','’§’°’¨’°÷Ä','’£’∏÷Ç’¨’∫’°','’≠÷Ä’∏’≠’ø','’Ø’°’∏÷Ç÷Ä’´','÷Ñ’°’∂’∏’∂','’≥’°’≤’°’ø','’£’∂’∏÷Ä’§','÷É’≠÷Ä’∏÷Ç’∂','’§÷Ä’°’¥’°','’º’•’ø’´’∂','’¶’≤’ª’∏÷Ç’¥','’Ø’°’∫’´’π','’°’∫’ø’°’Ø','’ß’Ø÷Ä’°’∂','’¢÷Ä’§’µ’°','’§’°’∞’∏÷Ç’Ø','’∫’≤’ø’∏÷Ä','’§’°’§’°÷Ä','’•÷Ä’∑’´’Ø','’±’µ’∏÷Ç’§’∏','’ª’∏÷Ç’©’°’Ø','’¨’æ’°÷Å÷Ñ','’°÷Ä’Æ’°’©','’∫’∏÷Ç÷Ä’°’Ø','’§’•’Ø’°’∂','’¨’°’æ’°’∑','’£’°’æ’°’©','’¢’∏÷Ç’¨’Ø’´','’Ω’´÷Ä’∏÷Ç’∂','’Ø’°’ø’°’Ø','’¶’∏’§’∏÷Ç’¥','’©’•÷É’∏÷Ç’Ø','’°’∂’ø’•÷Ä','’Ω’°÷É’∏÷Ä','’∞’µ’∏÷Ç’Ω’∂','’∞’°’∂’∏÷Ç’¥','’¢’µ’∏÷Ç’ª’•','’Ω’•’¶’∏’∂','’∂’´’¶’°’Ø','’£÷Ä’∫’°’∂','’¢’¨’≤’∏÷Ç÷Ä','’∫’≤’∫’•’≤','’Ø’∂’≥’´’º','’Ω÷Ä’´’∂’£','’•’≤’´’∂’ª','’∞’°’Ω÷Å’•','’ø’¶÷Ä’∏÷Ç’Ø','’Ω’∫’´÷Ä’ø','’§÷Ä’æ’°’£','’ø’∏’Ø’∏’Ω','’¥’°’£’´’¨','’°÷Ä’¥’°’æ','’æ’Ω’ø’°’∞','’°’∂÷Å’∏÷Ç’¥','’π’°÷Ä’°’¶','’°’¥’¢’∏’≠','’∫’°’∞’∏÷Å','’°’Ø÷Å’´’°','’ø’´’ø’°’∂','’∏÷Ç÷Ä’¢’°’©','’°’∂’£’´÷Ä','’Ø’•’∂’°÷Å','’≠’∏’º’∏’π','’°’≤’°’∂’±','’§’°÷Ä’°’Ø','÷É’°÷É’∏÷Ç’Ø','’£’¥’¢’•’©','’≠’∏’∂’°’æ','’∂’°’≠’∂’´','’£’∂’§’°’Ø','’°’¶’§’°’Ø','’ª’∏’Ø’°’ø','’©’•’∂’´’Ω','’≥’°’∞’´’≥','’¢’∂’∏÷Ç’µ’©','’≠÷Ä’≥’´’©','’©’´÷Ä’°’≠','’ø’°’≥’°÷Ä','’∂’∑’•’∂’´','’°’∂’±÷Ä÷á','’∞’°’ø’∏÷Ç’¥','’£’°÷Ä’∏÷Ç’∂','’≠’∏÷Ç÷Ä’¥’°','’ª’•’º’∏÷Å','’∑’∂’∏÷Ä’∞','’∫’°’ø’´’™','’™’∏’≤’∏’æ','’§’´’•’ø’°','’Ø’°’∂’∏’∂','’≤’°’¶’°’≠','’°’¶’∂’´’æ','’¥’∏’≠’´÷Ä','’≥’°’∑’°’Ø','’¢’∂’°’¶’§','’°’∂’∞’∏’£','’≥’°’£’°÷Ä','’§’∏÷Ç’§’∏÷Ç’Ø','’≠’∏’™’∏’º','’°’ª’¨’´’Ø','÷Ñ’∏’©’∏÷Ç’Ø','’°’∂’±’°’æ','’¢’¥’¢’∏÷Ç’¨','’≠’∂’§’´÷Ä','’Ω’∏÷Ç’¨’∏÷Å','’¢’°’∂’∏÷Ç’Ø','’Ø’°’æ’´’≥','’∞÷Ä’§’•’∞','’Ω’°’¥’¢’∏','’∞’∏’æ’´’æ','’°’º’µ’∏÷Ç’Æ','’Ø’∏’≤’∏’æ','’°÷Ä’≥’´’≥','’Ω’¥’¢’°’Ø','÷Ñ’°’≤÷Å÷Ä','’°’∂’ø’°’∑','’©’°’∂’±÷Ä','’•÷Ä’Ø’´÷Ä','’°’ø’¨’°’Ω','’™’µ’∏÷Ç÷Ä’´','’Ω’ø’∏÷Ç’µ’£','’≠’¨’∏÷Ç÷Ä’§','’´’¥’°’Ω’ø','’•’º’°’Ø’´','’Ø÷Ä’Ø’´’∂','’Ω÷Ä’´’Ø’°','’Ø’°’©’´’¨','’©’°’º’°÷É','’≥’°’Ø’°’ø','’Ø’∏’Ø’´’Ø','’Ω’∏÷Ç’ø’°’Ø','’Ø’¥’°’≠÷Ñ','’°’∂’¢’´’Æ','’≠’≠’∏÷Ç’∂’ª','’¥’ø÷Ä’∏÷Ç’Ø','’Ø÷Ä’∫’°’Ø','’°’≤’µ’∏÷Ç’Ω','’¥’ø÷Ä’°’Ø','’∞÷Ä’©’´’º','’°÷Ä’™’•÷Ñ','’ß’°’Ø’°’∂','÷Ü’´’¶’´’Ø','’æ’°÷Ä’°’Ø','’¢’°÷Å’∏÷Ç’¥','’°’º’æ’°’Ø','’§’∏’∂’∏÷Ä','’∞’∏÷Ç’¶’´’π','’Ø’µ’°’∂÷Ñ','’≠’∂’°’¥’´','’©’°÷É’∏÷Ç÷Ä','’Ø’°÷Ä’∏’ø','’∞’°’¥’•’¥','’π’∂’π’´’∂','’ø’•’Ω’∏÷Ç’π','’∏÷Ç’≤’•÷Ä’±','’∑’°÷Ñ’°÷Ä','’¥’°’¨’∏÷Ç’≠','’Ø’∏’¥’´’Ø','’∞’°’Ω’∏÷Ç’∂','’°’≤’æ’•’Ω','’ø’°÷Ñ’Ω’´','’¶’æ’°÷Ä’©','’§÷Ä’∏’∑’¥','’Æ’°’Æ’∏÷Ç’Ø','’¥’°÷Ñ’∏÷Ç÷Ä','÷Ö’∫’•÷Ä’°','’Ø’∏÷Ç’¶’´’Ø','’Ø’´’©’°’º','’±’æ’°’±÷á','’©’©’•’∂’´','’ß’©’´’Ø’°','’π’°’¥’°’∂','’∂’°’≠’´÷Ä','’¢’¨÷Ä’°’Ø','’¢’∏÷Ç’§’§’°','’°’¢’•’≤’°','’∞’∂’°’∏’≥','’•’¶’°’Ø’´','’§’™’æ’°÷Ä','÷É’°’©’•’©','’∫’ø’∏÷Ç’µ’ø','’°÷Ä’§’°÷Ä','’°’≤÷Å’°’∂','’°’º’∏÷Ç’µ’£','’¨÷Ä’ø’•’Ω','’°’∂’≠’∂’°','’º’•’£’¢’´','’°’Æ’•’¨’´','’∞’∏’æ’°’¶','÷Ñ’°÷Ä’∏’¶','’π’°’¥’´’π','’£÷Ä’•’©’•','’°’≤’¥’∏÷Ç’Ø','’§’™’£’∏’∞','’≠’∏’∑’∏÷Ä','’∑’´’ø’°’Ø','’∞’°’¥’°’º','’¢’°’∂’°’∂','’¥’´’ø’∏÷Ç’¥','’∞’∏÷Ç’™’Ø’∏÷Ç','÷Ö÷Ä’•’∂÷Ñ','’¶’∂’§’°’∂','’Ω’∏’≤’∏÷Ç’∂','’£’∂’°÷Å÷Ñ','÷É’∏’≤’∏÷Å','’¢’∏’æ’°’Æ','÷Ñ’°÷Å’°’≠','’π’¥’∏÷Ç’∑’Ø','’™’°’∂’´÷Ñ','’Æ’≤÷Ä’´’§','’∞’°’Ω’°’Æ','’©’∏’∑’°’Ø','’°’∂’¥’°’∞','’ø’°÷Ä’•÷Å','’¨’•’¥’∏÷Ç÷Ä','’∫’°’∂’§’°','’¥’Ø÷Ä’°’ø','’≠’º’∫’∏’ø','’≠’°’æ’´’Æ','’¢÷Ä’§’∏’ø','’•÷Ä’§’∏÷Ç’¥','’π’•’¶’∏÷Ñ','’∂’∏’ø’°÷Ä','’æ’ø’°’∂’£','’∫’´÷Å÷Å’°','÷Ü’•÷Ä’¥’°','’Æ’∏’æ’°÷É','’°’£’•’∂’ø','’¥’°’º’°’∂','’æ’´’∫’°’Ø','’º’∏÷Ç’¢’¨’´','’∞’∏÷Ç’∑’∏÷Ç’¥','’∫’°’º’°’æ','’≠’¥’¢’°’Ø','’Ω’∫’∏÷Ç’∂’£','’©’º’π’∏÷Ç’∂','’°’ø’µ’°’∂','’¢’•’Ø’∏÷Ä','’¥’°’ø’∏÷Ç’º','’´’∂’•÷Ä’ø','’©’∏÷Ç’©’°’Ø','’°’∂’ø’∏÷Ç’∂','’°’¢’≠’°’¶','’¢’∏’¢’´’Ø','’π’°÷Ä’π’´','’¶’£’•’Ω’ø','’∞’∏÷Ç’¨’´’Ω','’≠’°’æ’°÷Ä','’£’°’¨’°÷Ä','’∂’∏÷Ä’•’Ø','’£’∏’º’∏’¶','’¢’°’¶’∏÷Ç’Ø','’æ’¶’Ø’°’∫','’°’∂’°’¥’∫','’Ω’∂’§’´’Ø','’≠’∏÷Ç’≥’∏÷Ç’≥','’¨’°’¶’•÷Ä','’ø’°÷É’°’Ø','’¶’´’ª’∏’≤','’°’Ø’∏÷Ç’¥’¢','’Ø’∂’∏÷Ç’∂÷Ñ','’Ω’°’¨’´’Ø','’∞’∂’°÷Ä÷Ñ','’£’´’∑’•÷Ä','’£’°’¶’°’∂','’Ø’°’≤’´’∂','’Ø’°’∂’•÷É','’∫’´’ø’°’Ø','’Ω÷Ä’≥’•÷É','’ø’°’æ’´’≤','’Ω’°’¥’´’©','’¥’∏÷Ä’∏÷Ç÷Ñ','’°’¨÷á’∏÷Ä','’•’≤’∏÷Ç’∂’£','’ø’°÷Ä’°’¶','’£’°’¶’°÷Ä','’°’Ø’°’∂’ª','’Ω’∏÷Ç’¨’´’π','’©’©’æ’°’∑','’¢’°÷Å’´’π','’∫’°’ø’°’º','÷Ö÷Ä÷Ä’°’∂','÷Ö’°’¶’´’Ω','’Ø’∏÷Ä’´’¶','’∫’°÷Ä’∏’∂','’∫’°÷Ä’•’Ø','’Ø’°÷Ä’´÷Ñ','’∫’≤’´’∂’±','’©’°÷Ñ’∏÷Ç’∂','’±’°’£’°÷Ä','’•÷Ä’•’≠’°','’∞’°’∑’´’∑','’Ω’≠’ø’∏÷Ä','’°’∂’∞’°’ø','’∫’°’∞’°’Ø','’æ’´’∑’°’∫','’∑÷Ä’ª’°’∂','’Æ’°’¥’∏’∂','’¥’°’Æ’∏÷Ç’∂','’æ’°’µ÷Ä’´','’Æ’´’Æ’°’≤','’¥’´’ª’°’ø','’©’°’¨’°’∂','’∂’°’¥’∏÷Ç’Ω','’°’¥’∏÷Ç÷Ä’´','’æ’°’≤’∏÷Ç÷Å','’∞’∏÷Ç’¥’∏÷Ä','’°’¥’∏÷Ä÷Ü','’≠’∂’∏÷Å’´','’Ω÷É’º’∏÷Å','’¢’°’¶’∏÷Ç’¥','’©’°÷É’∏’∂','’°’∫÷Ä’´’¨','’§’•’¨’ø’°','÷Å’∂÷Å’∏÷Ç’≤','’¶’°’æ’°’Ø','’Ø’°’µ’Ω÷Ä','’¢’∏’¨’∏÷Ç’Ø','’¥’•’∂’°’Ø','÷É÷Ä’Ø’´’π','’≠’≤’≥’∏÷Ç’Ø','’π’•’π’•’∂','’Ω’µ’∏÷Ç’™’•','’°’≥’µ’∏÷Ç’∂','’Ø’°’∑’æ’•','’Ω’ø÷Ä’∏÷Ç’Ø','’¢’°’¨’•’ø','’©’°’∂’°÷Ñ','’Ω’°’∂’´’Ø','’Ø’∑’•’º÷Ñ','’©’¥’¢’∏÷Ç’Ø','’æ’´÷Ä’∏÷Ç’Ω','’¢’º’∂’´’π','÷Ñ’°’¥’´’π','’¨÷Ä’°’ø’∏÷Ç','’£’°’≥’°’≥','’©’∏’æ’´’π','’¥’´’ª’∏÷Å','’¥’∏’ø’´’Ø','’§’´’¥’°’Ø','’¢’°’™’°’Ø','’°’æ’°÷Ä’ø','’§’°’™’°’∂','’¢’Ø’¨’´’Ø','’°÷Ä’©’∏÷Ç’∂','’¥’°’∂÷Ä’ß','’Ø’∏’ø’•’¥','’£’∏’¥’•’∑','’Ω’´’Ω’•’º','’Ω’°’æ’°’∂','÷Ö’§’°’π’∏÷Ç','’Ω’∏’≠’°’Ø','’Æ’´’Æ’°’Ø','’Ω’∏’≠’∏÷Ç’Ø','’®’∂’Ø’•÷Ä','’∂’•÷Ä’Ø’°','’∑’¨’§’´’Ø','’Æ’∫’ø’∏÷Ç’∂','’≥’Ø’∏÷Ç’µ’©','’°÷Ñ’¨’∏÷Ä','’°’Ø’∂’∏÷Å','’£’∂’§’´’Ø','÷Å’∏÷Ç÷Å’∏÷Ç’¥','’Æ’°’£’∏÷Ç’¥','÷Ñ’∂’∂’´’π','’°÷Ä’∑’°’æ','’°’≤’ª’´’Ø','’∏÷Ç’∂’•’¨’´','’Ω’∂’∏÷Ç’∂’§','’ø’≠’¥’°÷Ä','’ø’´’Ø’´’∂','’∞’∫’°÷Ä’ø','’Ω’©÷Ä’•’Ω','’Ω÷Ä’æ’°’Ø','÷Ö’©÷á’°’∂','’¢’∏’≤’∏÷Ñ','’°÷Ä’¥’°’ø','’Ø÷Ä÷Ñ’∏’ø','’Æ’°’∂’∏’©','’°÷Ä’µ’∏÷Ç’∂','’•÷Ä’°’∂’£','’°’≥’∏÷Ç÷Ä’§','’¨’µ’°÷Ä’§','’°’¥’°’µ’´','’¶÷Ä’∏÷Ç’µ÷Å','’Ω’°’¨’∏÷Ä','’•÷Ä’Ø’°’©','’ø’∏’∂’∂’°','’°÷Ä’Æ’´’æ','’§÷Ä’∏÷Ç’µ’©','’∂’µ’°÷Ä’§','’°’∂’£’•’ø','’Ø’°’ø’°÷Ä','’§÷Ä’°÷Å’´','’¨’°÷Ä’∏÷Ç’¥','’Ø’º’∏÷Ç’∂’Ø','’∏÷Ç’≤÷á’∏÷Ä','’¥’°’∂’£’∏','’°’¨’¢’∏’¥','’¢’•’≤’¨’∏÷Ç','’°’∂’∏÷Ç÷Ä’ª','’§’∏÷Ç’Ω’ø÷Ä','’∏’≤’∏÷Ä’Ø','’´’∑’≠’°’∂','’∏’¨’∏÷Ä’ø','’∏÷Ç’¨’∏÷Ç’∂÷Ñ','’°’∂’≥’°÷Ä','’©’∏’∂’´÷Ä','’°’∏÷Ç’§’´’∏','’¢’´’¶’∏’∂','’Ø’∏’≤’°’Ø','÷Å’∏÷Ä’•’∂','÷Ö÷Ñ’Ω’´’§','’Ω’¥’¢’∏÷Ç’Ø','’Ω’°’¥’¢’°','’°’∂’Ø’∏’π','÷Ñ’°’∂’°’Ø','’∞’∏’Ø’•’µ','’æ’°’∞’°’∂','’≠’°’∂’∏÷Ç’©','’∞÷Ä’°’∑÷Ñ','’Ø’∏’∑’´’Ø','’°’∂’¥’´’ø','’¶’∏÷Ä’•’≤','’°÷Ä’±’°’∂','’ø’•’Ω’°’Ø','÷Å’∏’≤’∏÷Ç’∂','’∏’Ω’Ø’∏÷Ä','’®’¥’¢’´’∑','’§’°’£’°’≤','’°’∫’°’Ø’´','’§’´’∫’∏÷Ç’Ø','’©’°’©’°÷Ä','’¥’Ø’∂’´’Ø','’Ø’∏’Ø’∏’Ω','÷É’∏÷Ç’π’´’Ø','’°’∂’§’∏÷Ç÷Ä','’°’¥÷É’∏÷É','’Ø’∏’¢÷Ä’°','’£’°’£’°’©','’°’∫’∑’°’Æ','’¢÷Ä’´’∂’±','’∂’™’∏÷Ç’µ’£','’•’≤’∂’´’Ø','’Ω’•’∂’°’ø','’º’•’¶’∏÷Ç’Ω','’ª’∂’ª’∏÷Å','’∑’°’∑’Ø’´','’Ø’∏’≥’°’Ø','’°’£’º’°’æ','’´’Ω’¨’°’¥','’§’≤’µ’°’Ø','’¥’•’º’°’Æ','’£’•÷Ä’°’∂','’¶’∂’∂’∏’≤','’©’´’©’•’º','’∑’•÷É’∏÷Ä','’°÷Ñ’Ω’∏÷Ä','’Ω’•’¨’°’æ','’¥’°’∂’∏÷Ç’Ø','’Ω’´’¢’•’≠','’Ω’∫’∏÷Ä’ø','’∫’∂’§’∏÷Ç’Ø','’•÷Ä’¢’•÷Ñ','÷Ñ’´’¥’´’Ø','’∫’°÷Ä’°’∂','’°÷Ä’§’∏÷Ç’Ø','’≠’∂’±’∏÷Ä','’∂’•’≠’∏÷Ç÷Ä','’∞’Ω’ø’°’Ø','’¥’´’ª’∏÷Ç’Ø','’Ω’ø’æ’•÷Ä','’£’•’ø’´’∂','÷É’°÷Ä’∏’Ω','’∞’∂’π’•’≤','’ø’°’ø’´’Ø','’©’∑’æ’°’º','÷Ñ’¨’∏÷Ç’∂’£','’±’°’æ’°÷Ä','’∫’°’¨’°’ø','’°’∂’ª’∏÷Ç÷Ä','’Æ’≤’∏’ø’•','’ø’°’∂’´÷Ñ','’∞’°’Ω’°’Ø','’≠’°’≤’°’≤','’∫’°’Ø’°’Ω','’Ø’°÷Ä’´’≥','’∞’Ω’Ø’´’π','’°’Ø’∏÷Ç’∂÷Ñ','’•÷Ä’•’Ø’∏','’¨’∏÷Ç÷Å’Ø’´','’°’∂’Ω’•’º','’∑’°÷Ä’°’∂','’∞’∏’∫’∏’∫','’ø’°÷Ä’´÷Ñ','’∞’°’¥’°÷Ä','’Ø’∏÷Ç÷Ä’Æ÷Ñ','’°’∂’•’Æ÷Ñ','’∫’°’∑’°÷Ä','’π’≤’ª’´’Ø','’≠’∏÷Ä’°’∂','’æ’´’Ω’Ø’´','’°’∂’Ø’°’≠','’¨’∏÷Ç’Ω’°’∂','’•’≤’µ’°’¥','’°’æ’°’∂’§','’Ø’°÷Ñ’°’æ','’°’¨’µ’∏÷Ç÷Ä','’Ø’°’∫’°÷Ä','’¥’∏÷Ä’•’≠','÷É÷Ä÷É’∏÷Ç÷Ä','’∂’°’¥’°’Ø','’¥’©’•÷Ä÷Ñ','’°’∂÷Å’°’Æ','’§’™’∏’≠÷Ñ','’Ω’Ø’´’¶’¢','’Ø’°’∫’∏÷Å','’•’≤’•’º’∂','’¢’°÷Ä’§’´','’¢’∏÷Ç’™’´’π','’¥’•’≠’°’Ø','’∫’∂’§’∏÷Ç’¥','÷Ä’°’¢’¢’´','’Ω’•’≤’°’∂','’π’°÷É’∏÷Ç’¥','’Æ’∏÷Ç’≤’°’Ø','’Ø’∏’∫’•’Ø','’Æ’°÷Ä’°’æ','÷Å’∂÷Å’∏÷Ç’¥','’°’Ø’∏÷Ä’§','’∏’π’´’∂’π','÷Ñ’´’¥’´’°','’°’Ø÷Å’´’¶','÷Ü’°’∂’ø’°','’©’°’æ’´’∑','’≠’∑’∑’∏÷Å','’¥’∏’Æ’°’Ø','’°’æ’°’¶’•','’Ø÷Ä’≥’°’ø','’Ø’°’∫’´’Ø','’¢÷Ä’∏’∂’¶','’∞’°÷Ä’°’æ','’©’•÷Ä’°’≥','’º’•’™’´’¥','÷Å’∏÷Ç÷Å’°’Ø','’¢’•÷Ä÷Ä’´','’¢’°’™’´’∂','’ø’∏’¥’°’ø','’∂’æ’°’Ω’ø','’∞’°’¥’•’≤','’ø’°’Ø’°’º','’¶’£’°’Ω’ø','’£’•÷Ä’°’≥','’∑÷Ñ’•÷Ä’©','’¨’∏’≤’°÷É','’°’∫’°’£’°','’¢’°’∂’°’Ø','’∞’°÷Ä’´’π','’¶’∏÷Ç’º’∂’°','’º’∏’¢’∏’ø','’∫’°÷Ä’£÷á','’°’∂’¥’•’≤','’∑’º’°’µ’¨','’Ω’≠’•’¥’°','’∞’∏÷Ç’∂’´’Ω','’°’µ’¨’∏÷Ç÷Ä','’Ø’°’¥’°÷Ä','’°÷Ä’§’•’∂','’ø’°’ª’´’Ø','’≠’°÷Ä’°’∂','’π÷Ñ’∂’°’≤','’¢’°÷Ä’±÷Ä','÷Ñ’°’≤’°÷Ñ','’©’¶’•’∂’´','’¢’∑’ø’´’Ø','’°’≤÷Ñ’°’ø','’©’°’≠’´’Æ','’Ø’°’Ø’°’π','’°’∂’§’°’¥','’≠’≥’∏÷Ç’≤’´','’ª÷Ä’æ’•’™','’¨’∏÷Ä’ø’∏÷Ç','’°’æ’µ’∏÷Ç’∂','’°’Ω’∫’•’ø','’Ø’∏’π’∏÷Ç’¥','’Ω’Ø’µ’∏÷Ç’º','’°’∂’¢’°’∂','’Ø’°÷Å’´’∂','’ø’•÷Ñ’Ω’ø','’≠’´’¶’°’≠','’≥’∏÷Ç’º’°’Ø','’∂’∫’°’Ω’ø','’•’≤’•’£’∂','’Ø’∫’π’∏÷Ç’∂','’°’º’∏’≤’ª','’¥’°’µ’´’Ω','’Ø’∂’≥’´’©','’Ø÷Å’∏÷Ä’§','’¶’°’ø’´’Ø','’§’´’¥’∏÷Ç’¥','÷Ö’Ω’Ø’°÷Ä','’∞’°’¥’∏’æ','’∞’°’ø’°’Ø','’≠’¥’´’π÷Ñ','’§’°’∂’°’Ø','’Ø’°÷Ä’°’£','’°’∂’∞’°’¥','’©’º’´’π÷Ñ','’°’¥÷Ä’∏÷Å','’¥’•’¨’´÷Ñ','’Ω’•’§’°’∂','’¨’°’∫’∑’°','’¢’°÷Å’°’ø','’Ø’•’Ω÷Ö÷Ä','’Æ’Æ’∏÷Ç’¥’¢','’£’∏÷Ç’¥’°÷Ä','’Ω÷Ä’¢’´’π','’æ’¶’∂’∏÷Å','’•÷Ä’Ø’°÷Ä','’°’∂’æ’°’≠','’∞’¥’°’µ÷Ñ','’Ω’∂’°’∂’Ø','’¢’°÷Å’´’Ø','’¥’º’°’µ’¨','’¢’´÷Ä’™’°','’¢’°÷Å’´’¨','’Ø’¨’´’¥’°','’¥÷Ä÷Å’∏÷Ç’¥','’∏’∞’¥’°’Ø','’∂’°÷Ä’§’´','’¨’°’ø’ø’•','’¥’∏÷Ç’¥’´’°','’°’º’∂’•’ø','’¥÷Ä÷Ä’´’Ø','’°’≤’•÷Ä’Ω','’∏’π’≠’°÷Ä','’•’¨÷á’ß’ª','’∞’•÷Ä’∏’Ω','’£’∏÷Ç’∂’°’ø','’Ø’•’º’´’Ø','’§’•’≤’´’∂','’Ø’•’º’°’Ω','’Æ’∂’∏÷Ç’∂’§','’≠’∂’°’¥÷Ñ','’°÷Ä’≠’´’æ','’•÷Ä’£’´’π','’∞’°’¶’°÷Ä','’Ø’°÷Ä’°’∫','’∫’°’Ω’´’æ','’ø’°’¢’°’ø','’Æ’´÷Ä’°’∂','’§’∏’¨’°÷Ä','’≠’∏÷Ç’≥’°’∫','’∞’°’æ’°’ø','÷É’°’Ø’°’∂','÷É’°’©’´’¨','’£’∏÷Ç’∑’°’Ø','’Ø’°’≠’´’π','’Ω’°’Ø’°’æ','’∫’°÷Ä’•’∂','’Æ’°’Ø’∏’≤','’¨’∏÷Ç’Ω’´’∂','’º’°’§’´’∏','’Ø÷Ä’Æ’∏’≤','’∞’´’¥’°÷Ä','’Ω’•÷Ä’´’°','’¨’∏’¨’´’Ø','’≠’°’≤’∏’≤','’º’•’∞’°’∂','’°’Ω’∏÷Ç’µ’©','’§’°÷É’∂’´','’∏÷Ç’ø’•’Ω’ø','’°’µ’Ω÷Ö÷Ä','’¶’£’∏÷Ç’µ’∑','’§’∫÷Ä’∏÷Å','’¢’•÷Ä’°’∂','’¥’´’ª’´’∂','’§’∏’§’∏’∑','’°’¥’¢’°÷Ä','’°’∂’ø’´’Ø','’Æ’∏÷Ä’°’Ø','’∞’°’≥’°’≠','’•÷Ä’°’∑’ø','’∑’°’¢’°’©','’∫’°÷Ä’ø÷Ñ','’¢’°’≠’∏÷Ç’¥','’°’≤’∏’©÷Ñ','’£’¶÷Ä’∏÷Å','’°’∂’¶’∏÷Ä','’¨’´’¥’∏’∂','’ø’∂’ª÷Ä’´','’¢’º’∂’°’Ø','’°’∏÷Ç’§’´’ø','’Ω÷Ä’∏÷Ç’∂÷Ñ','’§’§’¥’´’Ø','’°’¨’´’¢’´','’ø’∏’∂’∏÷Ç’Ω','’¨’°’Ø’∏’ø','’¥’∏÷Ä’©’´','’≠÷Ä’©’´’∂','’Ø’•÷Ü’´÷Ä','’¢’°÷Ä’°’Ø','’°’∂’∏’∂’Ω','’Ω’∫’°’Ω÷Ñ','’Ø’°’∂’°’π','’æ÷Ä’±’´’∂','’≠’•’¨’∏÷Ñ','’°’¥÷Ä’°’Ø','’°’Ø’ø’´’æ','’§’°’∞’´’≥','’∑’∏÷Ç’∑’°’∂','’¥’°’ø’´’ø','’∫’°’∂’´÷Ä','’Ø’∏’∫’´’ø','’ø’°’∫’°’Ø','’Ø’°’Ø’°’∏','’æ’´’≥’°’Ø','’≥’∂’∑’∏÷Ç’¥','’°’∂’ø’°’º','’°÷Ä’°÷Ä÷Ñ','’¥’∏’≤’•’Ω','’∑’•÷Ä’•÷É','’∞’∏’æ’´’ø','÷Ü’´’¨’ø÷Ä','’∫’•’∫’Ω’´','’¥’°’Ω’∏’∂','’°’∂’Ø’∏÷Ç’¥','’∏÷Ç’¶’¢’•’Ø','’•’º’µ’°’Ø','’∂’•÷Ä’∏÷Ç’™','’°÷Ä’ª’∏÷Ç’Ø','’©’¥’¢’´’Ø','’Æ’Æ’∏÷Ç’¥’¢','’§’´’¥’°÷Å','’æ’°’∂’∏’≤','’Ø’´’Ω’°’ø','’¨’´’∂’•’¨','’°’º’∂’•’¨','’≠’∏’Ω’•’¨','’∂’Ω’ø’•’¨','’æ’°’¶’•’¨','’©’º’π’•’¨','’¨’∏’≤’°’¨','’Ω’´÷Ä’•’¨','’∞’´’∑’•’¨','’≠’°’≤’°’¨','÷Ö’£’∂’•’¨','’£’ø’∂’•’¨','’¢’°÷Å’•’¨','÷É’°’Ø’•’¨','’Ω’Ø’Ω’•’¨','’°’∫÷Ä’•’¨','’Æ’∂’æ’•’¨','÷É’∏’≠’•’¨','’•÷Ä’£’•’¨','’∫’°÷Ä’•’¨','’™’∫’ø’°’¨'];


  if (WORDS.length === 0) {
      console.error("Word list is empty!");
  }

  // --- Correctly Sorted LOWERCASE Armenian Letters for Highlighting/Validation ---
  const sortedLetters = [
      '’°', '’¢', '’£', '’§', '’•', '’¶', '’ß', '’®', // 8
      '’©', '’™', '’´', '’¨', '’≠', '’Æ', '’Ø', '’∞', // 8 (16 total)
      '’±', '’≤', '’≥', '’¥', '’µ', '’∂', '’∑', '’∏', // 8 (24 total)
      '’π', '’∫', '’ª', '’º', '’Ω', '’æ', '’ø', '÷Ä', // 8 (32 total)
      '÷Å', '’∏÷Ç', '÷É', '÷Ñ', '÷á', '÷Ö', '÷Ü'      // 7 (39 total)
    ];
  const allLetters = [...sortedLetters]; // Use this for physical keyboard input validation

  // --- Keyboard Layout Definitions ---
  const keyboardAlphabeticalLayout = [
     sortedLetters.slice(0, 8),   // ’° - ’®
     sortedLetters.slice(8, 16),  // ’© - ’∞
     sortedLetters.slice(16, 24), // ’± - ’∏
     sortedLetters.slice(24, 32), // ’π - ÷Ä
     [...sortedLetters.slice(32), ''] // ÷Å - ÷Ü (7 letters) + 1 placeholder = 8 elements
  ];

   const keyboardPhoneticLayout = [
      ['’ß', '’©', '÷É', '’±', '’ª', '÷á', '÷Ä', '’π', '’≥', '’™'], // 10 keys
      ['÷Ñ', '’∏', '’•', '’º', '’ø', '’∏÷Ç', '’´', '÷Ö', '’∫', '’≠'], // 10 keys
      ['’°', '’Ω', '’§', '÷Ü', '’£', '’∞', '’µ', '’Ø', '’¨', '’Æ'], // 10 keys
      ['’¶', '’≤', '÷Å', '’æ', '’¢', '’∂', '’¥', '’∑', '’®', ''] // 9 keys + 1 placeholder = 10 elements for consistent grid
   ];

   const LAYOUT_NAMES = {
       'alphabetical': '‘±‘≤‘≥', /* Changed name */
       'phonetic': '’î’à‘µ' /* Changed name */
   };

  // --- Daily Word Logic ---
  const startDate = new Date("2025-04-11");
  const today = new Date();
  today.setHours(0, 0, 0, 0); // Normalize today's date to midnight
  const dayOffset = Math.floor((today - startDate) / (1000 * 60 * 60 * 24));
  // Initial values (will be set by loadGameByOffset)
  let currentWordOffset;
  let currentTargetWord;
  let parsedCurrentTarget;
  let currentGameDateKey; // Local storage key for the currently loaded game


  // --- Game State Variables ---
  let guesses;
  let currentGuess;
  let currentRowIndex;
  let isGameOver;
  let messageTimeout;
  // Stores CUMULATIVE best status: {'letter': 'correct' | 'present' | 'absent'} for the *currently loaded game*
  let keyStatuses;
  // Track current layout state
  let currentLayoutName = localStorage.getItem(LOCAL_STORAGE_LAYOUT_KEY) || 'phonetic'; // Default layout is phonetic
  let currentLayout = (currentLayoutName === 'phonetic') ? keyboardPhoneticLayout : keyboardAlphabeticalLayout;


  // --- Initialization ---
  function init() {
    // Set up global event listeners (only once)
    window.addEventListener('keydown', handlePhysicalKey);
    toggleBtnLayout.addEventListener('click', switchLayout);
    gameNumberElement.addEventListener('click', openPreviousGamesModal);
    modalCloseButton.addEventListener('click', closePreviousGamesModal);
    previousGamesModal.addEventListener('click', handleModalOverlayClick);
    // Theme toggle is already set up in loadState

    // The initial game load and UI build happen outside init() in DOMContentLoaded
  }

   // --- Update Game Number Display ---
   function updateGameNumberDisplay() {
        gameNumberElement.textContent = `#${currentWordOffset + 1}`;
   }


  // --- State Management (localStorage) ---
  function saveState() {
    // Only save state if the currently loaded game is today's game
    if (currentWordOffset === dayOffset) {
        const state = {
          guesses,
          currentRowIndex,
          isGameOver,
          targetWord: currentTargetWord, // Save the specific word played
          keyStatuses // Save key statuses for this game number
        };
        localStorage.setItem(currentGameDateKey, JSON.stringify(state));
    }
    // Always save layout preference regardless of which game is displayed
    localStorage.setItem(LOCAL_STORAGE_LAYOUT_KEY, currentLayoutName);
  }


   // Loads a specific game based on its offset from the start date
   // This function now handles state loading AND UI building/updating
   function loadGameByOffset(offset) {
        // Determine the target word and state key for this offset
        const targetDate = new Date(startDate);
        targetDate.setDate(startDate.getDate() + offset);
        const dateKey = `${LOCAL_STORAGE_PREFIX}${targetDate.toISOString().split('T')[0]}`;
        const wordForOffset = WORDS.length > 0 ? WORDS[offset % WORDS.length] : "’Ω’≠’°’¨";

        let loadedState = null;
        const savedStateJSON = localStorage.getItem(dateKey);
        if (savedStateJSON) {
             try {
                 const state = JSON.parse(savedStateJSON);
                 // Validate if the saved word matches the expected word for this offset
                 if (state.targetWord === wordForOffset) {
                     loadedState = state;
                 } else {
                     console.warn(`Saved word for game ${offset + 1} (${state.targetWord}) does not match expected word (${wordForOffset}). Starting fresh for this day.`);
                 }
             } catch (e) {
                 console.error(`Error loading state for game ${offset + 1}:`, e);
             }
        }

        // Set the global state variables for the loaded game
        currentWordOffset = offset;
        currentTargetWord = wordForOffset;
        parsedCurrentTarget = splitWord(currentTargetWord); // Update parsed target
        currentGameDateKey = dateKey; // Update the current game's LS key

        if (loadedState) {
            guesses = loadedState.guesses || [];
            currentRowIndex = loadedState.currentRowIndex || 0;
            isGameOver = loadedState.isGameOver || false;
            // Load key statuses specific to this game number
            keyStatuses = loadedState.keyStatuses || {};
             // Validate keyStatuses content
             for (const key in keyStatuses) {
                const validStatuses = ['correct', 'present', 'absent', null];
                if (!validStatuses.includes(keyStatuses[key])) {
                    delete keyStatuses[key];
                }
             }
        } else {
             // No saved state, reset game state for this word/day
             guesses = [];
             currentRowIndex = 0;
             isGameOver = false;
             keyStatuses = {}; // Reset key statuses for an unplayed game
        }

        // --- Update UI based on the loaded state ---
        updateGameNumberDisplay(); // Update the game number in the header
        buildBoard(); // Rebuild the board structure
        redrawBoardFromState(); // Populate the board with the loaded/empty guesses
        buildKeyboard(); // Rebuild keyboard to ensure correct handlers are attached/removed
        updateKeyboardHighlight(); // Update keyboard highlight based on the loaded/empty keyStatuses


        // Clear any old messages
        showMessage('', 0); // Show empty message with duration 0 to clear it

        // Manage input based on the loaded game's state (only playable if it's today's game)
        if (isGameOver) {
             const lastGuessString = guesses.length > 0 ? guesses[guesses.length - 1].map(g => g.letter).join('') : '';
             if (splitWord(lastGuessString).join('') !== parsedCurrentTarget.join('')) {
                 showMessage(`’ä’°÷Ä’ø’∏÷Ç’©’µ’∏÷Ç’∂÷â ‘Ω’°’≤ #${currentWordOffset + 1}-’´ ’¢’°’º’®’ù ${currentTargetWord}`, 0); // Show word on loss
             } else {
                 showMessage('üéâ ’Ä’°’≤’©’°’∂’°’Ø üéâ', 0);
             }
             disableInput(); // Disable input if the loaded game is over
        } else if (currentWordOffset === dayOffset) {
            // If loading today's unfinished game
            enableInput(); // Enable input
             // No message needed for ongoing game
        } else {
            // If loading a historical, unfinished game
            disableInput(); // Disable input
            showMessage(`‘¥’´’ø’°÷Ä’Ø’æ’∏÷Ç’¥ ’ß ’≠’°’≤ #${currentWordOffset + 1}. ‘¥’∏÷Ç÷Ñ ’Ø’°÷Ä’∏’≤ ’•÷Ñ ’≠’°’≤’°’¨ ’¥’´’°’µ’∂ ’°’µ’Ω÷Ö÷Ä’æ’° ’≠’°’≤’®÷â`, 3000);
        }

         // Recalculate board size as keyboard size might change depending on game state/input enabled/disabled
         adjustBoardSize();
   }


   // --- Word Processing ---
   function splitWord(word) {
    const chars = [];
    const lowerWord = String(word || '').toLowerCase();
    for (let i = 0; i < lowerWord.length; i++) {
      // Check for the digraph '’∏÷Ç'
      if (lowerWord[i] === '’∏' && i + 1 < lowerWord.length && lowerWord[i + 1] === '÷Ç') {
        chars.push('’∏÷Ç');
        i++; // Skip the '÷Ç'
      } else {
        chars.push(lowerWord[i]);
      }
    }
     return chars;
   }

  // --- UI Building ---
  // buildBoard is now called within loadGameByOffset
  // buildKeyboard is now called within loadGameByOffset and switchLayout


    // --- Keyboard Layout Switcher ---
    function switchLayout() {
        // Toggle layout name
        currentLayoutName = (currentLayoutName === 'phonetic') ? 'alphabetical' : 'phonetic';

        // Set the corresponding layout array
        currentLayout = (currentLayoutName === 'phonetic') ? keyboardPhoneticLayout : keyboardAlphabeticalLayout;

        // Update button text
        toggleBtnLayout.textContent = LAYOUT_NAMES[currentLayoutName];

        // Rebuild the keyboard with the new layout
        buildKeyboard();

        // *** IMPORTANT: Recalculate and adjust size after rebuilding the keyboard ***
        adjustBoardSize();

        // Update key highlights on the new keyboard (using the current game's keyStatuses)
        updateKeyboardHighlight();

        // Save the preference (only saves layout, not game state unless it's today's game)
        saveState();
    }


  // --- UI Updating & State Restoration ---
  // redrawBoardFromState is now called within loadGameByOffset

  function updateCurrentRowDisplay() {
    if (currentRowIndex >= MAX_ROWS) return;
    const currentRow = boardElement.querySelectorAll('.row')[currentRowIndex];
    if (!currentRow) return; // Ensure row exists

    const tiles = currentRow.querySelectorAll('.tile');
    tiles.forEach((tile, index) => {
        const tileInner = tile.querySelector('div');
        if (!tileInner) return;
        const letter = currentGuess[index] || '';
        tileInner.textContent = letter;
        if (letter) {
            tile.classList.add('filled');
        } else {
            tile.classList.remove('filled');
        }
        tile.classList.remove('correct', 'present', 'absent'); // Ensure no old status classes linger
    });
  }

  // --- updateKeyboardHighlight uses cumulative status ---
  // updateKeyboardHighlight is now called within loadGameByOffset and switchLayout
  function updateKeyboardHighlight() {
    keyboardElement.querySelectorAll('.key[data-key]').forEach(keyElement => { // Select all keys, including placeholders (they won't have a meaningful status)
        const letter = keyElement.dataset.key;
        // Don't highlight placeholders or special keys
        if (!letter || letter === ENTER_KEY || letter === DELETE_KEY) return;

        const cumulativeStatus = keyStatuses[letter]; // Cumulative best for the *currently loaded game*

        // Remove old status classes
        keyElement.classList.remove('correct', 'present', 'absent', 'has-present');

        // Apply cumulative status
        if (cumulativeStatus) {
            keyElement.classList.add(cumulativeStatus);
        }
        // The .has-present class logic from the original code is not used here
        // as it wasn't fully integrated with the state.
    });
}


   // --- Event Handlers ---
  function handleKeyClick(key) {
    // Only allow input for today's game if not game over
    if (isGameOver || currentGuess.length >= WORD_LENGTH || currentWordOffset !== dayOffset) {
        // If not today's game, show a message maybe? Or just ignore. Ignoring is cleaner.
        if (currentWordOffset !== dayOffset) {
             showMessage(`‘¥’∏÷Ç÷Ñ ’Ø’°÷Ä’∏’≤ ’•÷Ñ ’≠’°’≤’°’¨ ’¥’´’°’µ’∂ ’°’µ’Ω÷Ö÷Ä’æ’° ’≠’°’≤’®÷â`, 1500);
             shakeRow(currentRowIndex); // Maybe shake the row?
        }
        return;
    }
    currentGuess.push(key);
    updateCurrentRowDisplay();
  }

  function handleDelete() {
    // Only allow input for today's game if not game over
    if (isGameOver || currentGuess.length === 0 || currentWordOffset !== dayOffset) {
         if (currentWordOffset !== dayOffset) {
             showMessage(`‘¥’∏÷Ç÷Ñ ’Ø’°÷Ä’∏’≤ ’•÷Ñ ’≠’°’≤’°’¨ ’¥’´’°’µ’∂ ’°’µ’Ω÷Ö÷Ä’æ’° ’≠’°’≤’®÷â`, 1500);
             shakeRow(currentRowIndex);
        }
        return;
    }
    currentGuess.pop();
    updateCurrentRowDisplay();
  }

  // --- handleSubmit updates cumulative statuses ---
  function handleSubmit() {
    // Only allow input for today's game if not game over
    if (isGameOver || currentWordOffset !== dayOffset) {
         if (currentWordOffset !== dayOffset) {
             showMessage(`‘¥’∏÷Ç÷Ñ ’Ø’°÷Ä’∏’≤ ’•÷Ñ ’≠’°’≤’°’¨ ’¥’´’°’µ’∂ ’°’µ’Ω÷Ö÷Ä’æ’° ’≠’°’≤’®÷â`, 1500);
             shakeRow(currentRowIndex);
         } else { // isGameOver is true for today's game
             const finalMsg = guesses.length >= MAX_ROWS ? `’ä’°÷Ä’ø’∏÷Ç’©’µ’∏÷Ç’∂÷â ‘Ω’°’≤ #${currentWordOffset + 1}-’´ ’¢’°’º’®’ù ${currentTargetWord}` : 'üéâ ’Ä’°’≤’©’°’∂’°’Ø üéâ';
             showMessage(finalMsg, 3000); // Show win/loss message again
         }
        return;
    }

    if (currentGuess.length !== WORD_LENGTH) {
      shakeRow(currentRowIndex);
      showMessage("‘±’∂’¢’°’æ’°÷Ä’°÷Ä ’ø’°’º’•÷Ä’´ ÷Ñ’°’∂’°’Ø", 1500);
      return;
    }

    const guessString = currentGuess.join('');

    // Check if the word is in the valid word list
    if (!WORDS.includes(guessString)) {
        shakeRow(currentRowIndex);
        showMessage("’è’æ’µ’°’¨ ’¢’°’º’® ’¥’•÷Ä ’¢’°’º’°÷Ä’°’∂’∏÷Ç’¥ ’π’Ø’° :(", 1500);
        return;
    }

    const result = checkGuess(guessString);
    guesses.push(result);

    // Update CUMULATIVE keyStatuses based on the current guess result
    result.forEach(({ letter, status }) => {
        // Only update keyStatuses for standard letters
        if (letter === ENTER_KEY || letter === DELETE_KEY) return;

        const currentStatus = keyStatuses[letter];
        if (status === 'correct') {
            keyStatuses[letter] = 'correct'; // Correct always overrides
        } else if (status === 'present' && currentStatus !== 'correct') {
            keyStatuses[letter] = 'present'; // Present overrides absent/null, but not correct
        } else if (status === 'absent' && !currentStatus) {
             // Mark absent only if it wasn't marked correct or present previously
             // and it was absent *in this specific guess*.
             // The simplified logic below works with cumulative state:
             // only mark absent if there's no status yet.
            keyStatuses[letter] = 'absent'; // Absent only sets if no status yet (not overriding present/correct)
        }
    });

    // Animate and update display
    animateGuessResult(currentRowIndex, result);
    updateKeyboardHighlight(); // Update keyboard based on cumulative state

    // Proceed to next row or end game after animation delay
    setTimeout(() => {
        currentRowIndex++;
        currentGuess = [];
        saveState(); // Save the updated CUMULATIVE keyStatuses and layout preference for TODAY's game

        checkWinLoss(guessString); // Check game over status for TODAY's game
    }, WORD_LENGTH * 150 + 300); // Wait for tile animation + a little buffer
  }


  function handlePhysicalKey(e) {
     // Only allow input for today's game if not game over
     if (isGameOver || currentWordOffset !== dayOffset) {
          // Prevent default for Enter/Backspace/Delete if the game is over (prevents unexpected scrolling or other browser actions)
          // Allow default for other keys so browser shortcuts still work
          if (isGameOver && (e.key === 'Enter' || e.key === 'Backspace' || e.key === 'Delete')) {
               e.preventDefault();
          }
          // No input processing for past games or finished games
         return;
     }

     let key = e.key;
     // Prevent default for keys we handle in the game to avoid native browser input actions (like scrolling with space)
     if (key.length === 1 || key === 'Backspace' || key === 'Delete' || key === 'Enter') {
         // Only prevent default if it's a key we might handle AND the game is playable (not over and is today's game)
         if (!isGameOver && currentWordOffset === dayOffset) {
             e.preventDefault();
         } else if (isGameOver && (key === 'Enter' || key === 'Backspace' || key === 'Delete')) {
            // Also prevent default for Enter/Backspace/Delete if game is over
            e.preventDefault();
         } else if (isGameOver) {
             // Allow default for other keys if game is over
             return;
         }
     }


     key = key.toLowerCase();

     if (key === 'enter') {
         handleSubmit();
     } else if (key === 'backspace' || key === 'delete') {
         handleDelete();
     } else {
         // Check if the pressed key is a valid Armenian letter or ' ’∏÷Ç' from the `allLetters` array.
         // This validates physical input based on accepted characters, not the virtual layout.
         if (allLetters.includes(key)) {
             if (currentGuess.length < WORD_LENGTH) {
                 handleKeyClick(key);
             }
         }
     }
  }


  // --- Game Logic ---
  function checkGuess(guessString) {
     const guessChars = splitWord(guessString);
     const result = [];
     const targetCopy = [...parsedCurrentTarget]; // Use the currently loaded target word

     // Initialize result array structure
     for(let i = 0; i < WORD_LENGTH; i++) {
         result[i] = { letter: guessChars[i], status: '' };
     }

     // Pass 1: Correct
     for (let i = 0; i < WORD_LENGTH; i++) {
         if (guessChars[i] === parsedCurrentTarget[i]) {
             result[i].status = 'correct';
             targetCopy[i] = null; // Mark this letter in target as used
         }
     }

     // Pass 2: Present/Absent
     for (let i = 0; i < WORD_LENGTH; i++) {
         if (result[i].status === 'correct') continue; // Skip already matched correct letters

         const letter = guessChars[i];
         const indexInTarget = targetCopy.indexOf(letter); // Search in remaining target letters

         if (indexInTarget !== -1) {
             result[i].status = 'present';
             targetCopy[indexInTarget] = null; // Mark this letter in target as used
         } else {
             result[i].status = 'absent';
         }
     }
     return result;
  }

   // Check win/loss only applies to the *current* day's game
  function checkWinLoss(lastGuessString) {
     if (currentWordOffset !== dayOffset) return; // Only check win/loss for today's game

     if (splitWord(lastGuessString).join('') === parsedCurrentTarget.join('')) {
         showMessage('üéâ ’Ä’°’≤’©’°’∂’°’Ø üéâ', 5000); // Short duration for win message
         isGameOver = true;
         disableInput();
         saveState(); // Save final state (win) and layout
     } else if (currentRowIndex >= MAX_ROWS) {
          showMessage(`’ä’°÷Ä’ø’∏÷Ç’©’µ’∏÷Ç’∂÷â ‘Ω’°’≤ #${currentWordOffset + 1}-’´ ’¢’°’º’®’ù ${currentTargetWord}`, 0); // Indefinite duration for loss message
          isGameOver = true;
          disableInput();
          saveState(); // Save final state (loss) and layout
     }
  }

   // Disables user input (keyboard buttons and physical keys)
  function disableInput() {
     // console.log("Game Over - Input Disabled");
     // Keep physical keyboard listener for Enter/Backspace even when disabled,
     // but let their handlers check `isGameOver` and `currentWordOffset`.
     // Remove onclick handlers from virtual keyboard buttons
     keyboardElement.querySelectorAll('.key').forEach(btn => {
         if (!btn.classList.contains('placeholder')) {
            btn.onclick = null; // Remove click handler
            btn.style.cursor = 'default';
            // Optionally disable the button visually as well
             // btn.disabled = true;
             // btn.style.opacity = 0.8;
         }
     });
  }

    // Enables user input (keyboard buttons and physical keys)
   function enableInput() {
        // Re-add onclick handlers for virtual keyboard buttons
        keyboardElement.querySelectorAll('.key').forEach(btn => {
            if (!btn.classList.contains('placeholder')) {
               const keyText = btn.dataset.key;
               if (keyText === ENTER_KEY) {
                   btn.onclick = handleSubmit;
               } else if (keyText === DELETE_KEY) {
                   btn.onclick = handleDelete;
               } else {
                   btn.onclick = () => handleKeyClick(keyText);
               }
               btn.style.cursor = 'pointer';
                btn.disabled = false; // Ensure button is enabled
                btn.style.opacity = ''; // Remove potential disabled opacity
            }
        });
        // Physical keyboard listener remains active, but handlers check state
   }


  // --- Animations & Messages ---
  function animateGuessResult(rowIndex, result) {
     const row = boardElement.querySelectorAll('.row')[rowIndex];
     if (!row) return; // Ensure row exists

     const tiles = row.querySelectorAll('.tile');
     tiles.forEach((tile, index) => {
         const { letter, status } = result[index];
         const tileInner = tile.querySelector('div');

         if (!tileInner) return;

         // Set text and 'filled' class immediately
         tileInner.textContent = letter;
         if (letter) {
            tile.classList.add('filled');
         } else {
             tile.classList.remove('filled');
         }
         // Remove any old status classes just in case
         tile.classList.remove('correct', 'present', 'absent');


         // Apply status class with stagger and potentially a flip animation (CSS needed)
         setTimeout(() => {
             if (status) {
                tile.classList.add(status);
                // You could add a flip animation class here if defined in CSS
                // tile.classList.add('flip'); // Example
             }
         }, index * 150); // Stagger delay for status reveal/animation
     });
     // Optional: Add event listener for animation end if using CSS animations
     // row.addEventListener('animationend', handleAnimationEnd, { once: true });
  }


  function shakeRow(rowIndex) {
    const row = boardElement.querySelectorAll('.row')[rowIndex];
    if (row) {
        row.classList.add('shake');
        row.addEventListener('animationend', () => {
            row.classList.remove('shake');
        }, { once: true });
    }
  }

   function showMessage(msg, duration = 2000) {
        clearTimeout(messageTimeout);
        messageElement.textContent = msg;
        messageElement.classList.add('show');
        // Remove 'hide' class if it was added for indefinite messages
        messageElement.classList.remove('hide');
        if (duration > 0) {
            messageTimeout = setTimeout(() => {
                messageElement.classList.remove('show');
            }, duration);
        }
   }


   // --- Previous Games Modal ---
   function openPreviousGamesModal() {
        previousGamesListElement.innerHTML = ''; // Clear previous list
        const numberOfGamesToShow = Math.min(dayOffset + 1, 100); // Show up to last 100 games (including today)

        // Generate list items backwards from today
        for (let i = 0; i <= dayOffset; i++) { // Iterate from start date up to today
            const gameOffset = i;
            const gameNumber = gameOffset + 1;
            const gameDate = new Date(startDate);
            gameDate.setDate(startDate.getDate() + gameOffset);
            const dateString = gameDate.toLocaleDateString('hy-AM', { year: 'numeric', month: 'numeric', day: 'numeric' }); // Format date as Armenian
            const wordForThisGame = WORDS.length > 0 ? WORDS[gameOffset % WORDS.length] : "’Ω’≠’°’¨";

            const listItem = document.createElement('li');
            listItem.dataset.gameOffset = gameOffset;
            listItem.textContent = `#${gameNumber} - ${dateString}`;

            // Optionally indicate if the game was played/won/lost based on local storage
             const gameDateKey = `${LOCAL_STORAGE_PREFIX}${gameDate.toISOString().split('T')[0]}`;
             const savedStateJSON = localStorage.getItem(gameDateKey);
             if (savedStateJSON) {
                 try {
                     const state = JSON.parse(savedStateJSON);
                      if (state.targetWord === wordForThisGame) { // Basic validation
                         let statusIndicator = '';
                         if (state.isGameOver) {
                             const lastGuessString = state.guesses.length > 0 ? state.guesses[state.guesses.length - 1].map(g => g.letter).join('') : '';
                             if (splitWord(lastGuessString).join('') === splitWord(wordForThisGame).join('')) {
                                 statusIndicator = ' (‚úÖ)'; // Win
                             } else if (state.currentRowIndex >= MAX_ROWS) {
                                  statusIndicator = ' (‚ùå)'; // Loss
                              } else {
                                   statusIndicator = ' (...)'; // Played, but not finished? (Unlikely with isGameOver logic)
                              }
                          } else if (state.guesses.length > 0) {
                                statusIndicator = ' (...)'; // Started but not finished
                          }
                         listItem.textContent += statusIndicator;
                     }
                 } catch (e) {
                     console.error(`Error parsing state for game ${gameNumber}:`, e);
                 }
             }


            // Add click listener to load this game
            listItem.addEventListener('click', () => {
                loadGameByOffset(gameOffset);
                closePreviousGamesModal();
            });

            previousGamesListElement.appendChild(listItem);
        }

         // Reverse the list to show the most recent games first (today at the top)
        const items = Array.from(previousGamesListElement.children);
        items.reverse().forEach(item => previousGamesListElement.appendChild(item));


        // Show the modal
        previousGamesModal.classList.add('visible');
   }

   function closePreviousGamesModal() {
       previousGamesModal.classList.remove('visible');
       // Clear the list content when closing
       // previousGamesListElement.innerHTML = ''; // Keep content until next open for faster display? Or clear to save memory? Let's clear.
        previousGamesListElement.innerHTML = '';
   }

   // Handles clicks on the modal overlay itself to close it
   function handleModalOverlayClick(event) {
       if (event.target === previousGamesModal) {
           closePreviousGamesModal();
       }
   }


  // --- Theme Toggle ---
  toggleBtnTheme.onclick = () => {
    const isDark = document.body.classList.toggle('dark');
    const theme = isDark ? 'dark' : 'light';
    toggleBtnTheme.textContent = isDark ? '‚òÄÔ∏è' : 'üåó';
    localStorage.setItem('theme', theme);
  };

  // --- Dynamic Board Sizing for Small Screens (and large screens too) ---
  function adjustBoardSize() {
      const viewportHeight = window.innerHeight;

      // Get references to non-board elements that occupy vertical space
      const h1 = document.querySelector('h1');
      const subtitle = document.querySelector('.subtitle');
      const keyboard = document.getElementById('keyboard'); // Now a direct child of body
      const mainContentStyle = getComputedStyle(mainContent); // Get style for main content padding
      const boardContainer = document.querySelector('.board-container'); // Need this to get its margins

      // Check if all required elements exist
      if (!h1 || !subtitle || !keyboard || !boardContainer || !boardElement || !mainContent) {
          console.warn("adjustBoardSize: One or more elements not found.");
          return; // Exit if critical elements are missing
      }

      // Calculate the total height occupied by non-board elements including their margins/padding
      let nonBoardHeight = 0;
      const flowElements = [h1, subtitle, keyboard]; // Elements in the normal document flow that take vertical space
      flowElements.forEach(el => {
          const style = getComputedStyle(el);
          nonBoardHeight += el.offsetHeight; // Includes padding and border
          nonBoardHeight += parseFloat(style.marginTop) || 0;
          nonBoardHeight += parseFloat(style.marginBottom) || 0;
      });

       // Also account for padding on the main content div
       nonBoardHeight += parseFloat(mainContentStyle.paddingTop) || 0;
       nonBoardHeight += parseFloat(mainContentStyle.paddingBottom) || 0;
       /* Message container is fixed position, its height doesn't affect flow space
          unless we need to ensure there's space below it, but standard flow should
          push things down correctly if it's positioned fixed.
          Let's re-evaluate if its height should be factored in.
          If it's fixed, it's out of flow. The space it covers *visually* might obscure
          content, but doesn't affect the calculation of available space *between*
          flow elements.
          However, if the message is very tall, it might overlay the top of the board.
          The current fixed position means it doesn't contribute to pushing the board down.
          Let's keep it out of the `nonBoardHeight` calculation for now, as it's common
          for fixed elements to be outside the normal layout calculation.
          If issues arise, we might need to add padding-top to main-content dynamically
          or increase the buffer.
       */


      // Account for the board container's own vertical margins
      const boardContainerStyle = getComputedStyle(boardContainer);
      const boardContainerMarginTop = parseFloat(boardContainerStyle.marginTop) || 0;
      const boardContainerMarginBottom = parseFloat(boardContainerStyle.marginBottom) || 0;
      const boardContainerVerticalMargins = boardContainerMarginTop + boardContainerMarginBottom;

      // Available vertical space *for the board grid itself* (excluding its margins and its container's margins)
      const availableBoardHeight = viewportHeight - nonBoardHeight - boardContainerVerticalMargins;

      // Get the current grid gaps from the board element (accounts for media queries)
      const boardStyle = getComputedStyle(boardElement);
      const rowGap = parseFloat(boardStyle.rowGap) || 0;
      const columnGap = parseFloat(boardStyle.columnGap) || 0;

      // Calculate the maximum possible tile size based on the available board height
      // The board has MAX_ROWS rows and (MAX_ROWS - 1) gaps vertically.
      // We add a small buffer to prevent edge cases causing scrollbars.
      const buffer = 8;
      const maxTileSizeBasedOnHeight = (availableBoardHeight - (MAX_ROWS - 1) * rowGap - buffer) / MAX_ROWS;

      // Calculate the required board width to fit this max tile size horizontally
      const requiredBoardWidthFromHeight = (WORD_LENGTH * maxTileSizeBasedOnHeight) + (WORD_LENGTH - 1) * columnGap;


      // Determine the effective max width for the board.
      // This should be the minimum of the width needed to fit vertically
      // AND the max width allowed by the main content container.
      // The max width of the board container itself is handled by the CSS.
      // The JS calculation is primarily to *shrink* the board when vertical space is limited,
      // ensuring it fits without scroll. If vertical space is ample, we let CSS max-width take over.

       // Get the computed CSS max-width of the board container
       const tempMaxWidth = boardContainer.style.maxWidth; // Save current inline style
       boardContainer.style.maxWidth = ''; // Temporarily remove inline style to get CSS value
       const cssMaxWidthForBoardContainer = parseFloat(getComputedStyle(boardContainer).maxWidth);
       const finalCssMaxWidth = isNaN(cssMaxWidthForBoardContainer) ? Infinity : cssMaxWidthForBoardContainer; // Treat NaN as no CSS limit
       boardContainer.style.maxWidth = tempMaxWidth; // Restore inline style


      // The target width is the smaller of the width required for vertical fit
      // and the CSS max-width defined for the board-container.
      const targetWidth = Math.min(requiredBoardWidthFromHeight, finalCssMaxWidth);


      // Apply the calculated width as max-width to the board container
      // Ensure the calculated size is reasonable and positive
      const minReasonableTileSize = 30;
      const minReasonableBoardWidth = (WORD_LENGTH * minReasonableTileSize) + (WORD_LENGTH - 1) * columnGap;

      if (targetWidth > minReasonableBoardWidth && targetWidth > 0) {
          boardContainer.style.maxWidth = `${targetWidth}px`;
          // console.log(`Adjusted: Viewport H=${viewportHeight.toFixed(1)}, Needed W (Vert)=${requiredBoardWidthFromHeight.toFixed(1)}, CSS MaxW=${finalCssMaxWidth.toFixed(1)}, Target W=${targetWidth.toFixed(1)}`);
      } else {
           boardContainer.style.maxWidth = ''; // Revert to CSS
           // console.log(`Default: Viewport H=${viewportHeight.toFixed(1)}, Needed W (Vert)=${requiredBoardWidthFromHeight.toFixed(1)}, CSS MaxW=${finalCssMaxWidth.toFixed(1)}, Target W=${targetWidth.toFixed(1)} (Reverted)`);
      }
  }


  // --- Start the game ---
  // Use DOMContentLoaded to ensure HTML is ready before running init
  document.addEventListener('DOMContentLoaded', () => {
      // Load layout preference first as it affects keyboard height
      const savedLayoutName = localStorage.getItem(LOCAL_STORAGE_LAYOUT_KEY);
      if (savedLayoutName && LAYOUT_NAMES[savedLayoutName]) {
          currentLayoutName = savedLayoutName;
      } else {
          currentLayoutName = 'phonetic'; // Default layout
      }
      currentLayout = (currentLayoutName === 'phonetic') ? keyboardPhoneticLayout : keyboardAlphabeticalLayout;
      toggleBtnLayout.textContent = LAYOUT_NAMES[currentLayoutName];
      document.body.setAttribute('data-keyboard-layout', currentLayoutName);


      // Load today's game state and build UI
      loadGameByOffset(dayOffset);

      // Initialize global listeners
      init();

      // Adjust size based on initial viewport size (now accounts for correct keyboard height)
      adjustBoardSize();
  });

  // Adjust size whenever the window is resized or layout changes
  window.addEventListener('resize', adjustBoardSize);

</script>

</body>
</html>
