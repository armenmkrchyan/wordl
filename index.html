<!DOCTYPE html>
<html lang="hy">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0"/>
  <title>Wordle 🇦🇲</title>
  <style>
    /* --- Global Reset & Box Sizing --- */
    html {
        box-sizing: border-box;
        height: 100%; /* Ensure html takes full height */
        overflow-y: auto; /* Allow scrolling if content exceeds viewport */
    }
    *, *:before, *:after {
        box-sizing: inherit;
    }

    html, body {
        min-height: 100%; /* Ensure body can fill viewport */
        margin: 0;
        padding: 0; /* Ensure no default padding */
    }
    body {
      font-family: sans-serif;
      display: flex;
      flex-direction: column; /* Stack children vertically */
      align-items: center; /* Center children horizontally */
      transition: background 0.3s, color 0.3s;
      background-color: var(--bg-color, #fff);
      color: var(--text-color, #000);
    }

    :root {
        --bg-color: #fff;
        --text-color: #000;
        --tile-border-empty: #aaa;
        --tile-border-filled: #666;
        --key-bg: #d3d6da;
        --key-text: #1a1a1b;
        --correct-bg: #538d4e;
        --present-bg: #b59f3b;
        --absent-bg: #3a3a3c;
        --delete-key-bg: #dc3545; /* Red */
        --enter-key-bg: #538d4e; /* Green */
        --tile-text-light: #000;
        --tile-text-dark: #fff;
        --link-color: #007bff;
         /* Added for modal */
        --modal-bg: #fff;
        --modal-border: #ccc;
        --modal-text: #000;
        --list-item-hover-bg: #eee;
    }

     .dark {
        --bg-color: #121213;
        --text-color: #fff;
        --tile-border-empty: #3a3a3c;
        --tile-border-filled: #565758;
        --key-bg: #818384;
        --key-text: #dadce0;
        --tile-text-light: #fff;
        --link-color: #64b5f6;
        /* Added for modal dark mode */
        --modal-bg: #222;
        --modal-border: #555;
        --modal-text: #fff;
        --list-item-hover-bg: #333;
    }


    .main-content {
        flex: 1 1 auto; /* Allows growing and shrinking, takes available space */
        width: 100%;
        display: flex;
        flex-direction: column; /* Stack children vertically */
        align-items: center; /* Center children horizontally */
        max-width: 550px; /* Max width for the main content area */
        margin-left: auto;
        margin-right: auto;
        padding-left: 5px;
        padding-right: 5px;
        padding-bottom: 10px; /* Added some padding to the bottom of main-content */
        /* Ensure main-content aligns children even if they don't fill the width */
        align-self: center;
        position: relative; /* Needed for absolute positioning of child buttons */
    }

    h1 {
      margin-top: 10px;
      margin-bottom: 2px;
      font-size: 1.5rem;
      white-space: nowrap;
      display: flex; /* Use flex to align items within h1 */
      align-items: center;
      gap: 8px; /* Space between title and number/flag */
    }
     h1 img {
         height: 0.7em;
         vertical-align: middle;
     }
    /* Style for the game number */
    #game-number {
        font-size: 0.8em; /* Slightly smaller than main title */
        font-weight: normal; /* Not as bold as the title */
        cursor: pointer; /* Indicate it's clickable */
        text-decoration: underline; /* Indicate it's a link/clickable */
        color: inherit; /* Inherit color from h1 */
    }
     #game-number:hover {
         color: var(--link-color); /* Highlight on hover */
     }


    .subtitle {
        font-size: 0.9rem;
        color: #777;
        margin-top: 0;
        margin-bottom: 5px;
    }
    .dark .subtitle {
        color: #aaa;
    }
     .subtitle a {
        color: inherit; /* Inherit color from subtitle */
     }
     .subtitle a:hover {
        text-decoration: underline; /* Keep underline on hover */
     }


    .board-container {
        display: flex;
        justify-content: center;
        align-items: center;
        width: 100%; /* Board container takes full width of main-content */
        /* Removed max-width here - JS will control it */
        /* max-width: 350px; */
        margin: 8px 0; /* Keep vertical margins */
        flex: 1 1 auto; /* Allow board container to grow/shrink within main-content */
        min-height: 0; /* Allow flex item to shrink below content size */
    }

    .board {
      display: grid;
      grid-template-rows: repeat(6, 1fr);
      grid-gap: 4px;
      width: 100%; /* Board takes full width of its container */
      /* The height will be determined by width due to tile aspect ratio */
    }

    .row {
        display: grid;
        grid-template-columns: repeat(5, 1fr);
        grid-gap: 4px;
    }

    .tile {
      width: 100%;
      aspect-ratio: 1 / 1;
      border: 2px solid var(--tile-border-empty);
      font-size: clamp(1.5rem, 6vw, 2rem);
      font-weight: bold;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      text-transform: lowercase;
      color: var(--tile-text-light);
      background-color: var(--bg-color);
      transition: background-color 0.3s, border-color 0.3s;
    }
    .tile > div {
        display: flex;
        align-items: center;
        justify-content: center;
        width: 100%;
        height: 100%;
        color: inherit;
    }
    .tile.filled {
        border-color: var(--tile-border-filled);
    }
    .tile.correct { background-color: var(--correct-bg); color: var(--tile-text-dark); border-color: var(--correct-bg); }
    .tile.present { background-color: var(--present-bg); color: var(--tile-text-dark); border-color: var(--present-bg); }
    .tile.absent { background-color: var(--absent-bg); color: var(--tile-text-dark); border-color: var(--absent-bg); }

    #keyboard {
      flex-shrink: 0; /* Prevent keyboard from shrinking */
      width: 100%;
      max-width: 550px; /* Align keyboard with main content */
      margin-left: auto;
      margin-right: auto;
      display: flex;
      flex-direction: column;
      gap: 4px;
      padding: 0 3px;
      margin-top: 5px;
      margin-bottom: 20px; /* Changed bottom margin to 20px */
      align-self: center; /* Center keyboard horizontally */
    }

    #keyboard-top-row {
        display: grid;
        /* Make Enter and Delete columns equal size */
        grid-template-columns: 1fr 1fr;
        gap: 3px;
    }

    #keyboard-main-grid {
        display: grid;
        /* Default to Alphabetical grid columns, overridden by data attribute */
        grid-template-columns: repeat(8, 1fr);
        gap: 3px;
    }

    /* Specific grid columns for Phonetic layout main grid */
    body[data-keyboard-layout="phonetic"] #keyboard-main-grid {
         grid-template-columns: repeat(10, 1fr); /* Phonetic layout rows have 10 slots */
         gap: 3px; /* Maintain consistent gap */
    }

     /* Placeholder key styling - visible only in layouts that need it for alignment */
     .key.placeholder {
        background: transparent;
        pointer-events: none;
        border-color: transparent;
        visibility: hidden; /* Hidden by default */
     }

    body[data-keyboard-layout="phonetic"] #keyboard-main-grid .key.placeholder {
        visibility: visible; /* Make placeholder visible in phonetic layout */
        background: rgba(0,0,0,0.03); /* Subtle background */
     }


    .key {
      min-height: 40px;
      /* Adjusted font-size clamp to allow single letters to be larger */
      font-size: clamp(1.2rem, 5vw, 1.8rem);
      font-weight: bold;
      border: 3px solid transparent;
      border-radius: 4px;
      background-color: var(--key-bg);
      color: var(--key-text);
      cursor: pointer;
      transition: background-color 0.2s, color 0.2s, border-color 0.2s;
      display: flex;
      justify-content: center;
      align-items: center;
      user-select: none;
      touch-action: manipulation;
      text-transform: lowercase;
      padding: 0;
      min-width: 0;
    }
    .key:hover {
        filter: brightness(90%);
    }

    .key.enter,
    .key.delete {
      /* Increased font size for Enter/Delete keys */
      font-size: clamp(0.9rem, 3.5vw, 1.2rem); /* Adjusted clamp values */
      color: white;
      border-width: 3px;
      border-style: solid;
    }
    .key.enter {
        background-color: var(--enter-key-bg);
        border-color: var(--enter-key-bg);
        white-space: nowrap;
    }
    .key.delete {
         background-color: var(--delete-key-bg);
         border-color: var(--delete-key-bg);
         white-space: nowrap;
    }


    .key.correct {
      background-color: var(--correct-bg);
      color: var(--tile-text-dark);
      border-color: transparent;
    }
    .key.present {
      background-color: var(--present-bg);
      color: var(--tile-text-dark);
      border-color: transparent;
    }
    .key.absent {
      background-color: var(--absent-bg);
      color: var(--tile-text-dark);
      border-color: transparent;
    }

    .key.correct.has-present {
        border-width: 3px;
        border-style: solid;
        /* Using a different color for visibility, you might adjust this */
        border-color: #ffff00; /* Example: Yellow border */
    }


    .message-container {
        position: fixed;
        top: 70px;
        left: 50%;
        transform: translateX(-50%);
        min-height: 30px;
        z-index: 10;
        width: 90%;
        max-width: 350px;
    }
    .message {
      text-align: center;
      font-size: 1em;
      margin-top: 0.5rem;
      padding: 8px 10px;
      font-weight: bold;
      background-color: #333;
      color: white;
      border-radius: 5px;
      visibility: hidden;
      opacity: 0;
      transition: visibility 0s 1.5s, opacity 1.5s linear;
      white-space: normal;
      word-wrap: break-word;
    }
     .message.show {
        visibility: visible;
        opacity: 1;
        transition: opacity 0.3s linear;
     }

    /* Modal Styles */
    .modal-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.5);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 100;
        visibility: hidden;
        opacity: 0;
        transition: visibility 0s 0.3s, opacity 0.3s ease;
    }

    .modal-overlay.visible {
        visibility: visible;
        opacity: 1;
        transition-delay: 0s;
    }

    .modal-content {
        background-color: var(--modal-bg);
        color: var(--modal-text);
        padding: 20px;
        border-radius: 8px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
        max-width: 90%;
        max-height: 90%;
        overflow-y: auto; /* Add scroll for long lists */
        position: relative;
        width: 300px; /* Adjust modal width as needed */
        display: flex;
        flex-direction: column;
    }
    .dark .modal-content {
        background-color: var(--modal-bg);
        color: var(--modal-text);
    }

    .modal-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 15px;
        padding-bottom: 10px;
        border-bottom: 1px solid var(--modal-border);
    }
    .modal-header h3 {
        margin: 0;
        font-size: 1.2rem;
    }

    .modal-close {
        background: none;
        border: none;
        font-size: 1.5rem;
        cursor: pointer;
        color: inherit;
        padding: 0;
    }
    .modal-close:hover {
        opacity: 0.7;
    }

    #previous-games-list {
        list-style: none;
        padding: 0;
        margin: 0;
    }

    #previous-games-list li {
        padding: 8px 0;
        border-bottom: 1px solid var(--modal-border);
        cursor: pointer;
        transition: background-color 0.2s ease;
    }
    #previous-games-list li:last-child {
        border-bottom: none;
    }
     #previous-games-list li:hover {
         background-color: var(--list-item-hover-bg);
     }
    #previous-games-list li span {
        font-weight: bold;
        margin-right: 10px;
    }


    /* Theme and Layout Button Positioning */
    /* Position these absolutely within the main-content area */
    .main-content > #toggle-theme {
      position: absolute;
      top: 10px;
      right: 10px; /* Position Theme button on the right */
      margin-bottom: 0; /* Remove margin as position is absolute */
      padding: 6px 10px;
      font-size: 0.9rem;
      border-radius: 5px;
      cursor: pointer;
      border: 1px solid #ccc;
      background-color: #eee;
      color: #333;
      z-index: 20;
    }
    .dark .main-content > #toggle-theme {
        background-color: #333;
        color: white;
        border-color: #555;
    }

    .main-content > #toggle-layout {
      position: absolute;
      top: 10px;
      left: 10px; /* Position Layout button on the left */
      margin-bottom: 0; /* Remove margin as position is absolute */
      padding: 6px 10px;
      font-size: 0.9rem;
      border-radius: 5px;
      cursor: pointer;
      border: 1px solid #ccc;
      background-color: #eee;
      color: #333;
      z-index: 20;
       min-width: 80px; /* Added min-width to prevent text wrap */
       text-align: center; /* Center text in button */
    }
     .dark .main-content > #toggle-layout {
        background-color: #333;
        color: white;
        border-color: #555;
    }


    @keyframes shake {
      0%, 100% { transform: translateX(0); }
      10%, 30%, 50%, 70%, 90% { transform: translateX(-5px); }
      20%, 40%, 60%, 80% { transform: translateX(5px); }
    }
    .shake { animation: shake 0.6s ease-in-out; }


    /* Media Query for very small/short screens */
    @media (max-width: 340px), (max-height: 600px) {
        h1 {
            font-size: 1.3rem; /* Further reduce */
            margin-top: 8px;
        }
        h1 #game-number {
            font-size: 0.9em; /* Adjust game number size */
        }
        .subtitle {
            margin-bottom: 3px;
        }
         .main-content {
            padding-bottom: 5px; /* Reduce bottom padding for very short screens */
         }
        .board-container {
            margin: 5px 0;
            /* max-width controlled by JS */
        }
        .board, .row {
            grid-gap: 3px; /* Further reduce */
        }
        #keyboard {
            gap: 3px;
            padding: 0 2px;
            margin-top: 3px;
            margin-bottom: 15px; /* Adjusted bottom margin for small screens */
        }
        /* Adjust gaps/columns for smaller screens if needed, though JS might handle size */
         #keyboard-main-grid, #keyboard-top-row {
            gap: 2px; /* Further reduce default gap */
        }
        body[data-keyboard-layout="phonetic"] #keyboard-main-grid {
             grid-template-columns: repeat(10, 1fr); /* Maintain 10 columns */
             gap: 2px; /* Use the smaller gap */
        }


        .key {
            min-height: 36px; /* Further reduce */
            /* Adjusted font size for small screens */
            font-size: clamp(1rem, 3.5vw, 1.3rem); /* Adjusted clamp values */
        }
        .key.enter, .key.delete {
             /* Increased font size for Enter/Delete on small screens */
            font-size: clamp(0.8rem, 3vw, 1.1rem); /* Adjusted clamp values */
        }
        /* Adjust button positions relative to main-content padding/width */
        .main-content > #toggle-theme {
            padding: 4px 7px;
            font-size: 0.8rem;
            top: 5px;
            right: 5px; /* Maintain right position */
        }
        .main-content > #toggle-layout {
            padding: 4px 7px; /* Reduced padding */
            font-size: 0.8rem;
            top: 5px;
            left: 5px; /* Adjust position to the left */
             min-width: 70px; /* Adjust min-width */
        }
        .message-container {
            top: 60px; /* Adjust if needed */
        }
         .modal-content {
             width: 250px; /* Adjust modal width for small screens */
         }
    }

  </style>
</head>
<body>
  <div class="main-content">
      <h1>
          Wordle <img src="flag.png" alt="🇦🇲">
          <span id="game-number"></span> <!-- Game Number Placeholder -->
      </h1>
      <!-- Updated subtitle to be a link -->
      <p class="subtitle">by <a href="https://www.armblog.net" target="_blank">Armen Mkrtchyan</a></p>

      <button id="toggle-theme">🌗</button>
      <button id="toggle-layout"></button> <!-- Added Layout Toggle Button -->

      <div class="message-container">
         <div id="message" class="message"></div>
      </div>
      <div class="board-container">
         <div class="board" id="board"></div>
      </div>
  </div>
  <!-- Keyboard is now a direct child of body, AFTER main-content -->
  <div id="keyboard">
      <div id="keyboard-top-row"></div>
      <div id="keyboard-main-grid"></div>
  </div>

  <!-- Previous Games Modal -->
  <div id="previous-games-modal" class="modal-overlay">
      <div class="modal-content">
          <div class="modal-header">
              <h3>Նախորդ խաղերը</h3>
              <button class="modal-close">×</button>
          </div>
          <ul id="previous-games-list">
              <!-- List items will be populated by JS -->
          </ul>
      </div>
  </div>


<script>
  const boardElement = document.getElementById('board');
  const keyboardTopRowElement = document.getElementById('keyboard-top-row');
  const keyboardMainGridElement = document.getElementById('keyboard-main-grid');
  const keyboardElement = document.getElementById('keyboard'); // Now a direct child of body
  const toggleBtnTheme = document.getElementById('toggle-theme');
  const toggleBtnLayout = document.getElementById('toggle-layout');
  const messageElement = document.getElementById('message');
  const mainContent = document.querySelector('.main-content'); // Still needed for sizing context
  const gameNumberElement = document.getElementById('game-number'); // Game number element
  const previousGamesModal = document.getElementById('previous-games-modal'); // Modal overlay
  const previousGamesListElement = document.getElementById('previous-games-list'); // Modal list
  const modalCloseButton = previousGamesModal.querySelector('.modal-close'); // Modal close button


  // --- Constants ---
  const WORD_LENGTH = 5;
  const MAX_ROWS = 6;
  const ENTER_KEY = 'ընդունել';
  const DELETE_KEY = 'ջնջել';
  const LOCAL_STORAGE_LAYOUT_KEY = 'armenianWordleLayout';
  const LOCAL_STORAGE_PREFIX = 'armenianWordle-'; // Prefix for game state keys

  // --- Word List (Assumed 5 letters, lowercase) ---
  const WORDS = ['ֆոտոն','նռնակ','հնդիկ','հեղուկ','արգոն','թրթուռ','կայուն','լուծում','շապիկ','հրշեջ','ընբիշ','մետաղ','ավելի','անզեն','հաշիվ','թափոր','խելառ','լքված','դայակ','ցերեկ','կտրուկ','կճղակ','վրացի','քուռակ','բորսա','ծաղիկ','հատիկ','նիհար','արձակ','թրթուր','տոկուն','եղևնի','սապատ','նեղուց','բժիշկ','ուռենի','չվերթ','մասուր','մեթոդ','թշշոց','քնքուշ','փեթակ','մեդիա','կրունկ','կաթսա','կոալա','գիտակ','կրկես','վարազ','փետուր','կտրիճ','հատուկ','կաղնի','պապիկ','ելույթ','ակամա','բուժում','անկապ','մամուլ','օրգան','արևոտ','դակիչ','թևնոց','պատիվ','մետրո','օթյակ','դրախտ','եռանդ','արկած','դալար','գուլպա','խրոխտ','կաուրի','քանոն','ճաղատ','գնորդ','փխրուն','դրամա','ռետին','զղջում','կապիչ','ապտակ','էկրան','բրդյա','դահուկ','պղտոր','դադար','երշիկ','ձյուդո','ջութակ','լվացք','արծաթ','պուրակ','դեկան','լավաշ','գավաթ','բուլկի','սիրուն','կատակ','զոդում','թեփուկ','անտեր','սափոր','հյուսն','հանում','բյուջե','սեզոն','նիզակ','գրպան','բլղուր','պղպեղ','կնճիռ','սրինգ','եղինջ','հասցե','տզրուկ','սպիրտ','դրվագ','տոկոս','մագիլ','արմավ','վստահ','անցում','չարազ','ամբոխ','պահոց','ակցիա','տիտան','ուրբաթ','անգիր','կենաց','խոռոչ','աղանձ','դարակ','փափուկ','գմբեթ','խոնավ','նախնի','գնդակ','ազդակ','ջոկատ','թենիս','ճահիճ','բնույթ','խրճիթ','թիրախ','տաճար','նշենի','անձրև','հատում','գարուն','խուրմա','ջեռոց','շնորհ','պատիժ','ժողով','դիետա','կանոն','ղազախ','ազնիվ','մոխիր','ճաշակ','բնազդ','անհոգ','ճագար','դուդուկ','խոժոռ','աջլիկ','քոթուկ','անձավ','բմբուլ','խնդիր','սուլոց','բանուկ','կավիճ','հրդեհ','սամբո','հովիվ','առյուծ','կողով','արճիճ','սմբակ','քաղցր','անտաշ','թանձր','երկիր','ատլաս','ժյուրի','ստույգ','խլուրդ','իմաստ','եռակի','կրկին','սրիկա','կաթիլ','թառափ','ճակատ','կոկիկ','սուտակ','կմախք','անբիծ','խխունջ','մտրուկ','կրպակ','աղյուս','մտրակ','հրթիռ','արժեք','էական','ֆիզիկ','վարակ','բացում','առվակ','դոնոր','հուզիչ','կյանք','խնամի','թափուր','կարոտ','համեմ','չնչին','տեսուչ','ուղերձ','շաքար','մալուխ','կոմիկ','հասուն','աղվես','տաքսի','զվարթ','դրոշմ','ծածուկ','մաքուր','օպերա','կուզիկ','կիթառ','ձվաձև','թթենի','էթիկա','չաման','նախիր','բլրակ','բուդդա','աբեղա','հնաոճ','եզակի','դժվար','փաթեթ','պտույտ','արդար','աղցան','առույգ','լրտես','անխնա','ռեգբի','ածելի','հովազ','քարոզ','չամիչ','գրեթե','աղմուկ','դժգոհ','խոշոր','շիտակ','համառ','բանան','միտում','հուժկու','օրենք','զնդան','սողուն','գնացք','փողոց','բոված','քացախ','չմուշկ','ժանիք','ծղրիդ','հասած','թոշակ','անմահ','տարեց','լեմուր','պանդա','մկրատ','խռպոտ','խավիծ','բրդոտ','երդում','չեզոք','նոտար','վտանգ','պիցցա','ֆերմա','ծովափ','ագենտ','մառան','վիպակ','ռուբլի','հուշում','պառավ','խմբակ','սպունգ','թռչուն','ատյան','բեկոր','մատուռ','իներտ','թութակ','անտուն','աբխազ','բոբիկ','չարչի','զգեստ','հուլիս','խավար','գալար','նորեկ','գոռոզ','բազուկ','վզկապ','անամպ','սնդիկ','խուճուճ','լազեր','տափակ','զիջող','ակումբ','կնունք','սալիկ','հնարք','գիշեր','գազան','կաղին','կանեփ','պիտակ','սրճեփ','տավիղ','սամիթ','մորուք','ալևոր','եղունգ','տարազ','գազար','ականջ','սուլիչ','թթվաշ','բացիչ','պատառ','օրրան','օազիս','կորիզ','պարոն','պարեկ','կարիք','պղինձ','թաքուն','ձագար','երեխա','հաշիշ','սխտոր','անհատ','պահակ','վիշապ','շրջան','ծամոն','մածուն','վայրի','ծիծաղ','միջատ','թալան','նամուս','ամուրի','վաղուց','հումոր','ամորֆ','խնոցի','սփռոց','բազում','թափոն','ապրիլ','դելտա','ցնցուղ','զավակ','կայսր','բոլուկ','մենակ','փրկիչ','խղճուկ','չեչեն','սյուժե','աճյուն','կաշվե','ստրուկ','բալետ','թանաք','սանիկ','կշեռք','թմբուկ','վիրուս','բռնիչ','քամիչ','լրատու','գաճաճ','թովիչ','միջոց','մոտիկ','դիմակ','բաժակ','ավարտ','դաժան','բկլիկ','արթուն','մանրէ','կոտեմ','գոմեշ','սիսեռ','սավան','օդաչու','սոխակ','ծիծակ','սոխուկ','ընկեր','ներկա','շլդիկ','ծպտուն','ճկույթ','աքլոր','ակնոց','գնդիկ','ցուցում','ծագում','քննիչ','արշավ','աղջիկ','ունելի','սնունդ','տխմար','տիկին','հպարտ','սթրես','սրվակ','օթևան','բողոք','արմատ','կրքոտ','ծանոթ','արյուն','երանգ','աճուրդ','լյարդ','ամայի','զրույց','սալոր','երկաթ','տոննա','արծիվ','դրույթ','նյարդ','անգետ','կատար','դրացի','լարում','կռունկ','ուղևոր','մանգո','ալբոմ','բեղլու','անուրջ','դուստր','ողորկ','իշխան','ոլորտ','ուլունք','անճար','թոնիր','աուդիո','բիզոն','կողակ','ցորեն','օքսիդ','սմբուկ','սամբա','անկոչ','քանակ','հոկեյ','վահան','խանութ','հրաշք','կոշիկ','անմիտ','զորեղ','արձան','տեսակ','ցողուն','ոսկոր','ըմբիշ','դագաղ','ապակի','դիպուկ','թաթար','մկնիկ','կոկոս','փուչիկ','անդուր','ամփոփ','կոբրա','գագաթ','ապշած','բրինձ','նժույգ','եղնիկ','սենատ','ռեզուս','ջնջոց','շաշկի','կոճակ','ագռավ','իսլամ','դղյակ','մեռած','գերան','զննող','թիթեռ','շեփոր','աքսոր','սելավ','մանուկ','սիբեխ','սպորտ','պնդուկ','երբեք','քիմիկ','պարան','արդուկ','խնձոր','նեխուր','հստակ','միջուկ','ստվեր','գետին','փարոս','հնչեղ','տատիկ','թշվառ','քլունգ','ձավար','պալատ','անջուր','ծղոտե','տանիք','հասակ','խաղաղ','պակաս','կարիճ','հսկիչ','ակունք','երեկո','լուցկի','անսեռ','շարան','հոպոպ','տարիք','համար','կուրծք','անեծք','պաշար','չղջիկ','խորան','վիսկի','անկախ','լուսան','եղյամ','ավանդ','կաքավ','ալյուր','կապար','մորեխ','փրփուր','նամակ','մթերք','անցած','դժոխք','սկիզբ','կապոց','եղեռն','բարդի','բուժիչ','մեխակ','պնդում','րաբբի','սեղան','չափում','ծուղակ','կոպեկ','ծարավ','ցնցում','ակորդ','ոչինչ','քիմիա','ակցիզ','ֆանտա','թավիշ','խշշոց','մոծակ','ավազե','կրճատ','կապիկ','բրոնզ','հարավ','թերաճ','ռեժիմ','ցուցակ','բերրի','բաժին','տոմատ','նվաստ','համեղ','տակառ','զգաստ','գերաճ','շքերթ','լողափ','ապագա','բանակ','հարիչ','զուռնա','ռոբոտ','պարգև','անմեղ','շռայլ','սխեմա','հունիս','այլուր','կամար','արդեն','տաջիկ','խարան','չքնաղ','բարձր','քաղաք','թզենի','բշտիկ','աղքատ','թախիծ','կակաչ','անդամ','խճուղի','ջրվեժ','լորտու','ավյուն','ասպետ','կոչում','սկյուռ','անբան','կացին','տեքստ','խիզախ','ճուռակ','նպաստ','եղեգն','կպչուն','առողջ','մայիս','կնճիթ','կցորդ','զատիկ','դիմում','օսկար','համով','հատակ','խմիչք','դանակ','կարագ','անհամ','թռիչք','ամրոց','մելիք','սեդան','լապշա','բացատ','կեսօր','ծծումբ','գումար','սրբիչ','վզնոց','երկար','անվախ','հմայք','սնանկ','բացիկ','մռայլ','բիրժա','բացիլ','կլիմա','մրցում','ոհմակ','նարդի','լատտե','մումիա','առնետ','մրրիկ','աղերս','ոչխար','ելևէջ','հերոս','գունատ','կեռիկ','դեղին','կեռաս','ծնունդ','խնամք','արխիվ','երգիչ','հազար','կարապ','պասիվ','տաբատ','ծիրան','դոլար','խուճապ','հավատ','փական','փաթիլ','գուշակ','կախիչ','սակավ','պարեն','ծակող','լուսին','ռադիո','կրծող','հիմար','սերիա','լոլիկ','խաղող','ռեհան','ասույթ','դափնի','ուտեստ','այսօր','զգույշ','դպրոց','բերան','միջին','դոդոշ','ամբար','անտիկ','ծորակ','հաճախ','երաշտ','շաբաթ','պարտք','բախում','աղոթք','գզրոց','անզոր','լիմոն','տնջրի','բռնակ','աուդիտ','սրունք','դդմիկ','ալիբի','տոնուս','լակոտ','մորթի','խրթին','կեֆիր','բարակ','անոնս','սպասք','կանաչ','վրձին','խելոք','ամրակ','ակտիվ','դահիճ','շուշան','մատիտ','պանիր','կոպիտ','տապակ','կակաո','վիճակ','ճնշում','անտառ','արարք','մողես','շերեփ','հովիտ','ֆիլտր','պեպսի','մասոն','անկում','ուզբեկ','եռյակ','ներուժ','արջուկ','թմբիկ','ծծումբ','դիմաց','վանող','կիսատ','լինել','առնել','խոսել','նստել','վազել','թռչել','լողալ','սիրել','հիշել','խաղալ','օգնել','գտնել','բացել','փակել','սկսել','ապրել','ծնվել','փոխել','երգել','պարել','ժպտալ'];


  if (WORDS.length === 0) {
      console.error("Word list is empty!");
  }

  // --- Correctly Sorted LOWERCASE Armenian Letters for Highlighting/Validation ---
  const sortedLetters = [
      'ա', 'բ', 'գ', 'դ', 'ե', 'զ', 'է', 'ը', // 8
      'թ', 'ժ', 'ի', 'լ', 'խ', 'ծ', 'կ', 'հ', // 8 (16 total)
      'ձ', 'ղ', 'ճ', 'մ', 'յ', 'ն', 'շ', 'ո', // 8 (24 total)
      'չ', 'պ', 'ջ', 'ռ', 'ս', 'վ', 'տ', 'ր', // 8 (32 total)
      'ց', 'ու', 'փ', 'ք', 'և', 'օ', 'ֆ'      // 7 (39 total)
    ];
  const allLetters = [...sortedLetters]; // Use this for physical keyboard input validation

  // --- Keyboard Layout Definitions ---
  const keyboardAlphabeticalLayout = [
     sortedLetters.slice(0, 8),   // ա - ը
     sortedLetters.slice(8, 16),  // թ - հ
     sortedLetters.slice(16, 24), // ձ - ո
     sortedLetters.slice(24, 32), // չ - ր
     [...sortedLetters.slice(32), ''] // ց - ֆ (7 letters) + 1 placeholder = 8 elements
  ];

   const keyboardPhoneticLayout = [
      ['է', 'թ', 'փ', 'ձ', 'ջ', 'և', 'ր', 'չ', 'ճ', 'ժ'], // 10 keys
      ['ք', 'ո', 'ե', 'ռ', 'տ', 'ու', 'ի', 'օ', 'պ', 'խ'], // 10 keys
      ['ա', 'ս', 'դ', 'ֆ', 'գ', 'հ', 'յ', 'կ', 'լ', 'ծ'], // 10 keys
      ['զ', 'ղ', 'ց', 'վ', 'բ', 'ն', 'մ', 'շ', 'ը', ''] // 9 keys + 1 placeholder = 10 elements for consistent grid
   ];

   const LAYOUT_NAMES = {
       'alphabetical': 'ԱԲԳ', /* Changed name */
       'phonetic': 'ՔՈԵ' /* Changed name */
   };

  // --- Daily Word Logic ---
  const startDate = new Date("2025-04-11");
  const today = new Date();
  today.setHours(0, 0, 0, 0); // Normalize today's date to midnight
  const dayOffset = Math.floor((today - startDate) / (1000 * 60 * 60 * 24));
  // Initial values (will be set by loadGameByOffset)
  let currentWordOffset;
  let currentTargetWord;
  let parsedCurrentTarget;
  let currentGameDateKey; // Local storage key for the currently loaded game


  // --- Game State Variables ---
  let guesses;
  let currentGuess;
  let currentRowIndex;
  let isGameOver;
  let messageTimeout;
  // Stores CUMULATIVE best status: {'letter': 'correct' | 'present' | 'absent'} for the *currently loaded game*
  let keyStatuses;
  // Track current layout state
  let currentLayoutName = localStorage.getItem(LOCAL_STORAGE_LAYOUT_KEY) || 'phonetic'; // Default layout is phonetic
  let currentLayout = (currentLayoutName === 'phonetic') ? keyboardPhoneticLayout : keyboardAlphabeticalLayout;


  // --- Initialization ---
  function init() {
    // Set up global event listeners (only once)
    window.addEventListener('keydown', handlePhysicalKey);
    toggleBtnLayout.addEventListener('click', switchLayout);
    gameNumberElement.addEventListener('click', openPreviousGamesModal);
    modalCloseButton.addEventListener('click', closePreviousGamesModal);
    previousGamesModal.addEventListener('click', handleModalOverlayClick);
    // Theme toggle is already set up in loadState

    // The initial game load and UI build happen outside init() in DOMContentLoaded
  }

   // --- Update Game Number Display ---
   function updateGameNumberDisplay() {
        gameNumberElement.textContent = `#${currentWordOffset + 1}`;
   }


  // --- State Management (localStorage) ---
  function saveState() {
    // Only save state if the currently loaded game is today's game
    if (currentWordOffset === dayOffset) {
        const state = {
          guesses,
          currentRowIndex,
          isGameOver,
          targetWord: currentTargetWord, // Save the specific word played
          keyStatuses // Save key statuses for this game number
        };
        localStorage.setItem(currentGameDateKey, JSON.stringify(state));
    }
    // Always save layout preference regardless of which game is displayed
    localStorage.setItem(LOCAL_STORAGE_LAYOUT_KEY, currentLayoutName);
  }


   // Loads a specific game based on its offset from the start date
   // This function now handles state loading AND UI building/updating
   function loadGameByOffset(offset) {
        // Determine the target word and state key for this offset
        const targetDate = new Date(startDate);
        targetDate.setDate(startDate.getDate() + offset);
        const dateKey = `${LOCAL_STORAGE_PREFIX}${targetDate.toISOString().split('T')[0]}`;
        const wordForOffset = WORDS.length > 0 ? WORDS[offset % WORDS.length] : "սխալ";

        let loadedState = null;
        const savedStateJSON = localStorage.getItem(dateKey);
        if (savedStateJSON) {
             try {
                 const state = JSON.parse(savedStateJSON);
                 // Validate if the saved word matches the expected word for this offset
                 if (state.targetWord === wordForOffset) {
                     loadedState = state;
                 } else {
                     console.warn(`Saved word for game ${offset + 1} (${state.targetWord}) does not match expected word (${wordForOffset}). Starting fresh for this day.`);
                 }
             } catch (e) {
                 console.error(`Error loading state for game ${offset + 1}:`, e);
             }
        }

        // Set the global state variables for the loaded game
        currentWordOffset = offset;
        currentTargetWord = wordForOffset;
        parsedCurrentTarget = splitWord(currentTargetWord); // Update parsed target
        currentGameDateKey = dateKey; // Update the current game's LS key

        if (loadedState) {
            guesses = loadedState.guesses || [];
            currentRowIndex = loadedState.currentRowIndex || 0;
            isGameOver = loadedState.isGameOver || false;
            // Load key statuses specific to this game number
            keyStatuses = loadedState.keyStatuses || {};
             // Validate keyStatuses content
             for (const key in keyStatuses) {
                const validStatuses = ['correct', 'present', 'absent', null];
                if (!validStatuses.includes(keyStatuses[key])) {
                    delete keyStatuses[key];
                }
             }
        } else {
             // No saved state, reset game state for this word/day
             guesses = [];
             currentRowIndex = 0;
             isGameOver = false;
             keyStatuses = {}; // Reset key statuses for an unplayed game
        }

        // --- Update UI based on the loaded state ---
        updateGameNumberDisplay(); // Update the game number in the header
        buildBoard(); // Rebuild the board structure
        redrawBoardFromState(); // Populate the board with the loaded/empty guesses
        buildKeyboard(); // Rebuild keyboard to ensure correct handlers are attached/removed
        updateKeyboardHighlight(); // Update keyboard highlight based on the loaded/empty keyStatuses


        // Clear any old messages
        showMessage('', 0); // Show empty message with duration 0 to clear it

        // Manage input based on the loaded game's state (only playable if it's today's game)
        if (isGameOver) {
             const lastGuessString = guesses.length > 0 ? guesses[guesses.length - 1].map(g => g.letter).join('') : '';
             if (splitWord(lastGuessString).join('') !== parsedCurrentTarget.join('')) {
                 showMessage(`Պարտություն։ Խաղ #${currentWordOffset + 1}-ի բառը՝ ${currentTargetWord}`, 0); // Show word on loss
             } else {
                 showMessage('🎉 Հաղթանակ 🎉', 0);
             }
             disableInput(); // Disable input if the loaded game is over
        } else if (currentWordOffset === dayOffset) {
            // If loading today's unfinished game
            enableInput(); // Enable input
             // No message needed for ongoing game
        } else {
            // If loading a historical, unfinished game
            disableInput(); // Disable input
            showMessage(`Դիտարկվում է խաղ #${currentWordOffset + 1}. Դուք կարող եք խաղալ միայն այսօրվա խաղը։`, 3000);
        }

         // Recalculate board size as keyboard size might change depending on game state/input enabled/disabled
         adjustBoardSize();
   }


   // --- Word Processing ---
   function splitWord(word) {
    const chars = [];
    const lowerWord = String(word || '').toLowerCase();
    for (let i = 0; i < lowerWord.length; i++) {
      // Check for the digraph 'ու'
      if (lowerWord[i] === 'ո' && i + 1 < lowerWord.length && lowerWord[i + 1] === 'ւ') {
        chars.push('ու');
        i++; // Skip the 'ւ'
      } else {
        chars.push(lowerWord[i]);
      }
    }
     return chars;
   }

  // --- UI Building ---
  // buildBoard is now called within loadGameByOffset
  // buildKeyboard is now called within loadGameByOffset and switchLayout


    // --- Keyboard Layout Switcher ---
    function switchLayout() {
        // Toggle layout name
        currentLayoutName = (currentLayoutName === 'phonetic') ? 'alphabetical' : 'phonetic';

        // Set the corresponding layout array
        currentLayout = (currentLayoutName === 'phonetic') ? keyboardPhoneticLayout : keyboardAlphabeticalLayout;

        // Update button text
        toggleBtnLayout.textContent = LAYOUT_NAMES[currentLayoutName];

        // Rebuild the keyboard with the new layout
        buildKeyboard();

        // *** IMPORTANT: Recalculate and adjust size after rebuilding the keyboard ***
        adjustBoardSize();

        // Update key highlights on the new keyboard (using the current game's keyStatuses)
        updateKeyboardHighlight();

        // Save the preference (only saves layout, not game state unless it's today's game)
        saveState();
    }


  // --- UI Updating & State Restoration ---
  // redrawBoardFromState is now called within loadGameByOffset

  function updateCurrentRowDisplay() {
    if (currentRowIndex >= MAX_ROWS) return;
    const currentRow = boardElement.querySelectorAll('.row')[currentRowIndex];
    if (!currentRow) return; // Ensure row exists

    const tiles = currentRow.querySelectorAll('.tile');
    tiles.forEach((tile, index) => {
        const tileInner = tile.querySelector('div');
        if (!tileInner) return;
        const letter = currentGuess[index] || '';
        tileInner.textContent = letter;
        if (letter) {
            tile.classList.add('filled');
        } else {
            tile.classList.remove('filled');
        }
        tile.classList.remove('correct', 'present', 'absent'); // Ensure no old status classes linger
    });
  }

  // --- updateKeyboardHighlight uses cumulative status ---
  // updateKeyboardHighlight is now called within loadGameByOffset and switchLayout
  function updateKeyboardHighlight() {
    keyboardElement.querySelectorAll('.key[data-key]').forEach(keyElement => { // Select all keys, including placeholders (they won't have a meaningful status)
        const letter = keyElement.dataset.key;
        // Don't highlight placeholders or special keys
        if (!letter || letter === ENTER_KEY || letter === DELETE_KEY) return;

        const cumulativeStatus = keyStatuses[letter]; // Cumulative best for the *currently loaded game*

        // Remove old status classes
        keyElement.classList.remove('correct', 'present', 'absent', 'has-present');

        // Apply cumulative status
        if (cumulativeStatus) {
            keyElement.classList.add(cumulativeStatus);
        }
        // The .has-present class logic from the original code is not used here
        // as it wasn't fully integrated with the state.
    });
}


   // --- Event Handlers ---
  function handleKeyClick(key) {
    // Only allow input for today's game if not game over
    if (isGameOver || currentGuess.length >= WORD_LENGTH || currentWordOffset !== dayOffset) {
        // If not today's game, show a message maybe? Or just ignore. Ignoring is cleaner.
        if (currentWordOffset !== dayOffset) {
             showMessage(`Դուք կարող եք խաղալ միայն այսօրվա խաղը։`, 1500);
             shakeRow(currentRowIndex); // Maybe shake the row?
        }
        return;
    }
    currentGuess.push(key);
    updateCurrentRowDisplay();
  }

  function handleDelete() {
    // Only allow input for today's game if not game over
    if (isGameOver || currentGuess.length === 0 || currentWordOffset !== dayOffset) {
         if (currentWordOffset !== dayOffset) {
             showMessage(`Դուք կարող եք խաղալ միայն այսօրվա խաղը։`, 1500);
             shakeRow(currentRowIndex);
        }
        return;
    }
    currentGuess.pop();
    updateCurrentRowDisplay();
  }

  // --- handleSubmit updates cumulative statuses ---
  function handleSubmit() {
    // Only allow input for today's game if not game over
    if (isGameOver || currentWordOffset !== dayOffset) {
         if (currentWordOffset !== dayOffset) {
             showMessage(`Դուք կարող եք խաղալ միայն այսօրվա խաղը։`, 1500);
             shakeRow(currentRowIndex);
         } else { // isGameOver is true for today's game
             const finalMsg = guesses.length >= MAX_ROWS ? `Պարտություն։ Խաղ #${currentWordOffset + 1}-ի բառը՝ ${currentTargetWord}` : '🎉 Հաղթանակ 🎉';
             showMessage(finalMsg, 3000); // Show win/loss message again
         }
        return;
    }

    if (currentGuess.length !== WORD_LENGTH) {
      shakeRow(currentRowIndex);
      showMessage("Անբավարար տառերի քանակ", 1500);
      return;
    }

    const guessString = currentGuess.join('');

    // Check if the word is in the valid word list
    if (!WORDS.includes(guessString)) {
        shakeRow(currentRowIndex);
        showMessage("Տվյալ բառը մեր բառարանում չկա :(", 1500);
        return;
    }

    const result = checkGuess(guessString);
    guesses.push(result);

    // Update CUMULATIVE keyStatuses based on the current guess result
    result.forEach(({ letter, status }) => {
        // Only update keyStatuses for standard letters
        if (letter === ENTER_KEY || letter === DELETE_KEY) return;

        const currentStatus = keyStatuses[letter];
        if (status === 'correct') {
            keyStatuses[letter] = 'correct'; // Correct always overrides
        } else if (status === 'present' && currentStatus !== 'correct') {
            keyStatuses[letter] = 'present'; // Present overrides absent/null, but not correct
        } else if (status === 'absent' && !currentStatus) {
             // Mark absent only if it wasn't marked correct or present previously
             // and it was absent *in this specific guess*.
             // The simplified logic below works with cumulative state:
             // only mark absent if there's no status yet.
            keyStatuses[letter] = 'absent'; // Absent only sets if no status yet (not overriding present/correct)
        }
    });

    // Animate and update display
    animateGuessResult(currentRowIndex, result);
    updateKeyboardHighlight(); // Update keyboard based on cumulative state

    // Proceed to next row or end game after animation delay
    setTimeout(() => {
        currentRowIndex++;
        currentGuess = [];
        saveState(); // Save the updated CUMULATIVE keyStatuses and layout preference for TODAY's game

        checkWinLoss(guessString); // Check game over status for TODAY's game
    }, WORD_LENGTH * 150 + 300); // Wait for tile animation + a little buffer
  }


  function handlePhysicalKey(e) {
     // Only allow input for today's game if not game over
     if (isGameOver || currentWordOffset !== dayOffset) {
          // Prevent default for Enter/Backspace/Delete if the game is over (prevents unexpected scrolling or other browser actions)
          // Allow default for other keys so browser shortcuts still work
          if (isGameOver && (e.key === 'Enter' || e.key === 'Backspace' || e.key === 'Delete')) {
               e.preventDefault();
          }
          // No input processing for past games or finished games
         return;
     }

     let key = e.key;
     // Prevent default for keys we handle in the game to avoid native browser input actions (like scrolling with space)
     if (key.length === 1 || key === 'Backspace' || key === 'Delete' || key === 'Enter') {
         // Only prevent default if it's a key we might handle AND the game is playable (not over and is today's game)
         if (!isGameOver && currentWordOffset === dayOffset) {
             e.preventDefault();
         } else if (isGameOver && (key === 'Enter' || key === 'Backspace' || key === 'Delete')) {
            // Also prevent default for Enter/Backspace/Delete if game is over
            e.preventDefault();
         } else if (isGameOver) {
             // Allow default for other keys if game is over
             return;
         }
     }


     key = key.toLowerCase();

     if (key === 'enter') {
         handleSubmit();
     } else if (key === 'backspace' || key === 'delete') {
         handleDelete();
     } else {
         // Check if the pressed key is a valid Armenian letter or ' ու' from the `allLetters` array.
         // This validates physical input based on accepted characters, not the virtual layout.
         if (allLetters.includes(key)) {
             if (currentGuess.length < WORD_LENGTH) {
                 handleKeyClick(key);
             }
         }
     }
  }


  // --- Game Logic ---
  function checkGuess(guessString) {
     const guessChars = splitWord(guessString);
     const result = [];
     const targetCopy = [...parsedCurrentTarget]; // Use the currently loaded target word

     // Initialize result array structure
     for(let i = 0; i < WORD_LENGTH; i++) {
         result[i] = { letter: guessChars[i], status: '' };
     }

     // Pass 1: Correct
     for (let i = 0; i < WORD_LENGTH; i++) {
         if (guessChars[i] === parsedCurrentTarget[i]) {
             result[i].status = 'correct';
             targetCopy[i] = null; // Mark this letter in target as used
         }
     }

     // Pass 2: Present/Absent
     for (let i = 0; i < WORD_LENGTH; i++) {
         if (result[i].status === 'correct') continue; // Skip already matched correct letters

         const letter = guessChars[i];
         const indexInTarget = targetCopy.indexOf(letter); // Search in remaining target letters

         if (indexInTarget !== -1) {
             result[i].status = 'present';
             targetCopy[indexInTarget] = null; // Mark this letter in target as used
         } else {
             result[i].status = 'absent';
         }
     }
     return result;
  }

   // Check win/loss only applies to the *current* day's game
  function checkWinLoss(lastGuessString) {
     if (currentWordOffset !== dayOffset) return; // Only check win/loss for today's game

     if (splitWord(lastGuessString).join('') === parsedCurrentTarget.join('')) {
         showMessage('🎉 Հաղթանակ 🎉', 5000); // Short duration for win message
         isGameOver = true;
         disableInput();
         saveState(); // Save final state (win) and layout
     } else if (currentRowIndex >= MAX_ROWS) {
          showMessage(`Պարտություն։ Խաղ #${currentWordOffset + 1}-ի բառը՝ ${currentTargetWord}`, 0); // Indefinite duration for loss message
          isGameOver = true;
          disableInput();
          saveState(); // Save final state (loss) and layout
     }
  }

   // Disables user input (keyboard buttons and physical keys)
  function disableInput() {
     // console.log("Game Over - Input Disabled");
     // Keep physical keyboard listener for Enter/Backspace even when disabled,
     // but let their handlers check `isGameOver` and `currentWordOffset`.
     // Remove onclick handlers from virtual keyboard buttons
     keyboardElement.querySelectorAll('.key').forEach(btn => {
         if (!btn.classList.contains('placeholder')) {
            btn.onclick = null; // Remove click handler
            btn.style.cursor = 'default';
            // Optionally disable the button visually as well
             // btn.disabled = true;
             // btn.style.opacity = 0.8;
         }
     });
  }

    // Enables user input (keyboard buttons and physical keys)
   function enableInput() {
        // Re-add onclick handlers for virtual keyboard buttons
        keyboardElement.querySelectorAll('.key').forEach(btn => {
            if (!btn.classList.contains('placeholder')) {
               const keyText = btn.dataset.key;
               if (keyText === ENTER_KEY) {
                   btn.onclick = handleSubmit;
               } else if (keyText === DELETE_KEY) {
                   btn.onclick = handleDelete;
               } else {
                   btn.onclick = () => handleKeyClick(keyText);
               }
               btn.style.cursor = 'pointer';
                btn.disabled = false; // Ensure button is enabled
                btn.style.opacity = ''; // Remove potential disabled opacity
            }
        });
        // Physical keyboard listener remains active, but handlers check state
   }


  // --- Animations & Messages ---
  function animateGuessResult(rowIndex, result) {
     const row = boardElement.querySelectorAll('.row')[rowIndex];
     if (!row) return; // Ensure row exists

     const tiles = row.querySelectorAll('.tile');
     tiles.forEach((tile, index) => {
         const { letter, status } = result[index];
         const tileInner = tile.querySelector('div');

         if (!tileInner) return;

         // Set text and 'filled' class immediately
         tileInner.textContent = letter;
         if (letter) {
            tile.classList.add('filled');
         } else {
             tile.classList.remove('filled');
         }
         // Remove any old status classes just in case
         tile.classList.remove('correct', 'present', 'absent');


         // Apply status class with stagger and potentially a flip animation (CSS needed)
         setTimeout(() => {
             if (status) {
                tile.classList.add(status);
                // You could add a flip animation class here if defined in CSS
                // tile.classList.add('flip'); // Example
             }
         }, index * 150); // Stagger delay for status reveal/animation
     });
     // Optional: Add event listener for animation end if using CSS animations
     // row.addEventListener('animationend', handleAnimationEnd, { once: true });
  }


  function shakeRow(rowIndex) {
    const row = boardElement.querySelectorAll('.row')[rowIndex];
    if (row) {
        row.classList.add('shake');
        row.addEventListener('animationend', () => {
            row.classList.remove('shake');
        }, { once: true });
    }
  }

   function showMessage(msg, duration = 2000) {
        clearTimeout(messageTimeout);
        messageElement.textContent = msg;
        messageElement.classList.add('show');
        // Remove 'hide' class if it was added for indefinite messages
        messageElement.classList.remove('hide');
        if (duration > 0) {
            messageTimeout = setTimeout(() => {
                messageElement.classList.remove('show');
            }, duration);
        }
   }


   // --- Previous Games Modal ---
   function openPreviousGamesModal() {
        previousGamesListElement.innerHTML = ''; // Clear previous list
        const numberOfGamesToShow = Math.min(dayOffset + 1, 100); // Show up to last 100 games (including today)

        // Generate list items backwards from today
        for (let i = 0; i <= dayOffset; i++) { // Iterate from start date up to today
            const gameOffset = i;
            const gameNumber = gameOffset + 1;
            const gameDate = new Date(startDate);
            gameDate.setDate(startDate.getDate() + gameOffset);
            const dateString = gameDate.toLocaleDateString('hy-AM', { year: 'numeric', month: 'numeric', day: 'numeric' }); // Format date as Armenian
            const wordForThisGame = WORDS.length > 0 ? WORDS[gameOffset % WORDS.length] : "սխալ";

            const listItem = document.createElement('li');
            listItem.dataset.gameOffset = gameOffset;
            listItem.textContent = `#${gameNumber} - ${dateString}`;

            // Optionally indicate if the game was played/won/lost based on local storage
             const gameDateKey = `${LOCAL_STORAGE_PREFIX}${gameDate.toISOString().split('T')[0]}`;
             const savedStateJSON = localStorage.getItem(gameDateKey);
             if (savedStateJSON) {
                 try {
                     const state = JSON.parse(savedStateJSON);
                      if (state.targetWord === wordForThisGame) { // Basic validation
                         let statusIndicator = '';
                         if (state.isGameOver) {
                             const lastGuessString = state.guesses.length > 0 ? state.guesses[state.guesses.length - 1].map(g => g.letter).join('') : '';
                             if (splitWord(lastGuessString).join('') === splitWord(wordForThisGame).join('')) {
                                 statusIndicator = ' (✅)'; // Win
                             } else if (state.currentRowIndex >= MAX_ROWS) {
                                  statusIndicator = ' (❌)'; // Loss
                              } else {
                                   statusIndicator = ' (...)'; // Played, but not finished? (Unlikely with isGameOver logic)
                              }
                          } else if (state.guesses.length > 0) {
                                statusIndicator = ' (...)'; // Started but not finished
                          }
                         listItem.textContent += statusIndicator;
                     }
                 } catch (e) {
                     console.error(`Error parsing state for game ${gameNumber}:`, e);
                 }
             }


            // Add click listener to load this game
            listItem.addEventListener('click', () => {
                loadGameByOffset(gameOffset);
                closePreviousGamesModal();
            });

            previousGamesListElement.appendChild(listItem);
        }

         // Reverse the list to show the most recent games first (today at the top)
        const items = Array.from(previousGamesListElement.children);
        items.reverse().forEach(item => previousGamesListElement.appendChild(item));


        // Show the modal
        previousGamesModal.classList.add('visible');
   }

   function closePreviousGamesModal() {
       previousGamesModal.classList.remove('visible');
       // Clear the list content when closing
       // previousGamesListElement.innerHTML = ''; // Keep content until next open for faster display? Or clear to save memory? Let's clear.
        previousGamesListElement.innerHTML = '';
   }

   // Handles clicks on the modal overlay itself to close it
   function handleModalOverlayClick(event) {
       if (event.target === previousGamesModal) {
           closePreviousGamesModal();
       }
   }


  // --- Theme Toggle ---
  toggleBtnTheme.onclick = () => {
    const isDark = document.body.classList.toggle('dark');
    const theme = isDark ? 'dark' : 'light';
    toggleBtnTheme.textContent = isDark ? '☀️' : '🌗';
    localStorage.setItem('theme', theme);
  };

  // --- Dynamic Board Sizing for Small Screens (and large screens too) ---
  function adjustBoardSize() {
      const viewportHeight = window.innerHeight;

      // Get references to non-board elements that occupy vertical space
      const h1 = document.querySelector('h1');
      const subtitle = document.querySelector('.subtitle');
      const keyboard = document.getElementById('keyboard'); // Now a direct child of body
      const mainContentStyle = getComputedStyle(mainContent); // Get style for main content padding
      const boardContainer = document.querySelector('.board-container'); // Need this to get its margins

      // Check if all required elements exist
      if (!h1 || !subtitle || !keyboard || !boardContainer || !boardElement || !mainContent) {
          console.warn("adjustBoardSize: One or more elements not found.");
          return; // Exit if critical elements are missing
      }

      // Calculate the total height occupied by non-board elements including their margins/padding
      let nonBoardHeight = 0;
      const flowElements = [h1, subtitle, keyboard]; // Elements in the normal document flow that take vertical space
      flowElements.forEach(el => {
          const style = getComputedStyle(el);
          nonBoardHeight += el.offsetHeight; // Includes padding and border
          nonBoardHeight += parseFloat(style.marginTop) || 0;
          nonBoardHeight += parseFloat(style.marginBottom) || 0;
      });

       // Also account for padding on the main content div
       nonBoardHeight += parseFloat(mainContentStyle.paddingTop) || 0;
       nonBoardHeight += parseFloat(mainContentStyle.paddingBottom) || 0;
       /* Message container is fixed position, its height doesn't affect flow space
          unless we need to ensure there's space below it, but standard flow should
          push things down correctly if it's positioned fixed.
          Let's re-evaluate if its height should be factored in.
          If it's fixed, it's out of flow. The space it covers *visually* might obscure
          content, but doesn't affect the calculation of available space *between*
          flow elements.
          However, if the message is very tall, it might overlay the top of the board.
          The current fixed position means it doesn't contribute to pushing the board down.
          Let's keep it out of the `nonBoardHeight` calculation for now, as it's common
          for fixed elements to be outside the normal layout calculation.
          If issues arise, we might need to add padding-top to main-content dynamically
          or increase the buffer.
       */


      // Account for the board container's own vertical margins
      const boardContainerStyle = getComputedStyle(boardContainer);
      const boardContainerMarginTop = parseFloat(boardContainerStyle.marginTop) || 0;
      const boardContainerMarginBottom = parseFloat(boardContainerStyle.marginBottom) || 0;
      const boardContainerVerticalMargins = boardContainerMarginTop + boardContainerMarginBottom;

      // Available vertical space *for the board grid itself* (excluding its margins and its container's margins)
      const availableBoardHeight = viewportHeight - nonBoardHeight - boardContainerVerticalMargins;

      // Get the current grid gaps from the board element (accounts for media queries)
      const boardStyle = getComputedStyle(boardElement);
      const rowGap = parseFloat(boardStyle.rowGap) || 0;
      const columnGap = parseFloat(boardStyle.columnGap) || 0;

      // Calculate the maximum possible tile size based on the available board height
      // The board has MAX_ROWS rows and (MAX_ROWS - 1) gaps vertically.
      // We add a small buffer to prevent edge cases causing scrollbars.
      const buffer = 8;
      const maxTileSizeBasedOnHeight = (availableBoardHeight - (MAX_ROWS - 1) * rowGap - buffer) / MAX_ROWS;

      // Calculate the required board width to fit this max tile size horizontally
      const requiredBoardWidthFromHeight = (WORD_LENGTH * maxTileSizeBasedOnHeight) + (WORD_LENGTH - 1) * columnGap;


      // Determine the effective max width for the board.
      // This should be the minimum of the width needed to fit vertically
      // AND the max width allowed by the main content container.
      // The max width of the board container itself is handled by the CSS.
      // The JS calculation is primarily to *shrink* the board when vertical space is limited,
      // ensuring it fits without scroll. If vertical space is ample, we let CSS max-width take over.

       // Get the computed CSS max-width of the board container
       const tempMaxWidth = boardContainer.style.maxWidth; // Save current inline style
       boardContainer.style.maxWidth = ''; // Temporarily remove inline style to get CSS value
       const cssMaxWidthForBoardContainer = parseFloat(getComputedStyle(boardContainer).maxWidth);
       const finalCssMaxWidth = isNaN(cssMaxWidthForBoardContainer) ? Infinity : cssMaxWidthForBoardContainer; // Treat NaN as no CSS limit
       boardContainer.style.maxWidth = tempMaxWidth; // Restore inline style


      // The target width is the smaller of the width required for vertical fit
      // and the CSS max-width defined for the board-container.
      const targetWidth = Math.min(requiredBoardWidthFromHeight, finalCssMaxWidth);


      // Apply the calculated width as max-width to the board container
      // Ensure the calculated size is reasonable and positive
      const minReasonableTileSize = 30;
      const minReasonableBoardWidth = (WORD_LENGTH * minReasonableTileSize) + (WORD_LENGTH - 1) * columnGap;

      if (targetWidth > minReasonableBoardWidth && targetWidth > 0) {
          boardContainer.style.maxWidth = `${targetWidth}px`;
          // console.log(`Adjusted: Viewport H=${viewportHeight.toFixed(1)}, Needed W (Vert)=${requiredBoardWidthFromHeight.toFixed(1)}, CSS MaxW=${finalCssMaxWidth.toFixed(1)}, Target W=${targetWidth.toFixed(1)}`);
      } else {
           boardContainer.style.maxWidth = ''; // Revert to CSS
           // console.log(`Default: Viewport H=${viewportHeight.toFixed(1)}, Needed W (Vert)=${requiredBoardWidthFromHeight.toFixed(1)}, CSS MaxW=${finalCssMaxWidth.toFixed(1)}, Target W=${targetWidth.toFixed(1)} (Reverted)`);
      }
  }


  // --- Start the game ---
  // Use DOMContentLoaded to ensure HTML is ready before running init
  document.addEventListener('DOMContentLoaded', () => {
      // Load layout preference first as it affects keyboard height
      const savedLayoutName = localStorage.getItem(LOCAL_STORAGE_LAYOUT_KEY);
      if (savedLayoutName && LAYOUT_NAMES[savedLayoutName]) {
          currentLayoutName = savedLayoutName;
      } else {
          currentLayoutName = 'phonetic'; // Default layout
      }
      currentLayout = (currentLayoutName === 'phonetic') ? keyboardPhoneticLayout : keyboardAlphabeticalLayout;
      toggleBtnLayout.textContent = LAYOUT_NAMES[currentLayoutName];
      document.body.setAttribute('data-keyboard-layout', currentLayoutName);


      // Load today's game state and build UI
      loadGameByOffset(dayOffset);

      // Initialize global listeners
      init();

      // Adjust size based on initial viewport size (now accounts for correct keyboard height)
      adjustBoardSize();
  });

  // Adjust size whenever the window is resized or layout changes
  window.addEventListener('resize', adjustBoardSize);

</script>

</body>
</html>
