<!DOCTYPE html>
<html lang="hy">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0"/>
  <title>Wordle üá¶üá≤</title>
  <style>
    /* --- Global Reset & Box Sizing --- */
    html {
        box-sizing: border-box;
        height: 100%; /* Ensure html takes full height */
    }
    *, *:before, *:after {
        box-sizing: inherit;
    }

    html, body {
        min-height: 100%; /* Ensure body can fill viewport */
        margin: 0;
        padding: 0; /* Ensure no default padding */
    }
    body {
      font-family: sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      transition: background 0.3s, color 0.3s;
      background-color: var(--bg-color, #fff);
      color: var(--text-color, #000);
    }

    :root {
        --bg-color: #fff;
        --text-color: #000;
        --tile-border-empty: #aaa;
        --tile-border-filled: #666;
        --key-bg: #d3d6da;
        --key-text: #1a1a1b;
        --correct-bg: #538d4e;
        --present-bg: #b59f3b;
        --absent-bg: #3a3a3c;
        --delete-key-bg: #dc3545; /* Red */
        --enter-key-bg: #538d4e; /* Green */
        --tile-text-light: #000;
        --tile-text-dark: #fff;
        --link-color: #007bff;

        /* New CSS Variables for Key Sizing/Spacing */
        --key-gap: 4px; /* Gap between keys */
        --key-height: 48px; /* Desired key height */
        --key-min-height: 40px; /* Minimum height on small screens */
        --key-padding: 2px; /* Padding inside key for letter margin */
    }

    .main-content {
        flex: 1 0 auto; /* Allows shrinking and growing, taking available space */
        width: 100%;
        display: flex;
        flex-direction: column;
        align-items: center;
        max-width: 550px; /* Max width for the main content container */
        margin-left: auto;
        margin-right: auto;
        padding: 0 5px; /* Add some horizontal padding */
        position: relative; /* Needed for absolute positioning of buttons */
    }

    h1 {
      margin-top: 10px;
      margin-bottom: 2px;
      font-size: 1.5rem;
      white-space: nowrap;
    }

    .subtitle {
        font-size: 0.9rem;
        color: #777;
        margin-top: 0;
        margin-bottom: 5px;
    }
    .dark .subtitle {
        color: #aaa;
    }


    .board-container {
        display: flex;
        justify-content: center;
        align-items: center;
        width: 100%;
        max-width: 350px; /* Keep board max-width fixed */
        margin: 8px 0;
    }

    .board {
      display: grid;
      grid-template-rows: repeat(6, 1fr);
      grid-gap: 4px;
      width: 100%;
    }

    .row {
        display: grid;
        grid-template-columns: repeat(5, 1fr);
        grid-gap: 4px;
    }

    .tile {
      width: 100%;
      aspect-ratio: 1 / 1;
      border: 2px solid var(--tile-border-empty);
      font-size: clamp(1.5rem, 6vw, 2rem);
      font-weight: bold;
      display: flex; /* Use flex for centering content */
      align-items: center;
      justify-content: center;
      text-transform: lowercase;
      color: var(--tile-text-light);
      background-color: var(--bg-color);
      transition: background-color 0.3s, border-color 0.3s;
      padding: 2px; /* Add padding around the letter */
      box-sizing: border-box; /* Ensure padding is included in the tile size */
    }
    .tile.filled {
        border-color: var(--tile-border-filled);
    }
    .tile.correct { background-color: var(--correct-bg); color: var(--tile-text-dark); border-color: var(--correct-bg); }
    .tile.present { background-color: var(--present-bg); color: var(--tile-text-dark); border-color: var(--present-bg); }
    .tile.absent { background-color: var(--absent-bg); color: var(--tile-text-dark); border-color: var(--absent-bg); }

    #keyboard {
      display: flex;
      flex-direction: column;
      gap: var(--key-gap); /* Use key-gap variable */
      width: 100%; /* Keyboard takes full width of its container (main-content max-width) */
      /* Remove max-width here, the layout will be centered by margin: auto */
      padding: 0 3px; /* Keep horizontal padding */
      margin: 5px auto 0; /* Center the keyboard block */
      box-sizing: border-box;
    }

    #keyboard-top-row {
        display: flex; /* Use Flexbox for the top row */
        gap: var(--key-gap);
        width: 100%;
        justify-content: center; /* Center items in the top row */
    }

    #keyboard-main-grid {
        display: flex; /* Use flexbox to stack rows */
        flex-direction: column;
        gap: var(--key-gap); /* Use key-gap variable */
        align-items: center; /* Center the keyboard rows horizontally */
        width: 100%; /* Ensure the main grid takes full width of #keyboard */
    }

     /* Each row within the main grid */
     #keyboard-main-grid .keyboard-row {
         display: flex; /* Use flexbox for keys within the row */
         gap: var(--key-gap); /* Use key-gap variable */
         flex-wrap: nowrap; /* Prevent keys from wrapping */
         width: 100%; /* Ensure the row takes full width of main-grid */
         justify-content: center; /* Center keys within the row if they don't fill the width */
     }


    .key {
      /* --- Letter Keys & Placeholders --- */
      height: var(--key-height); /* Set desired height */
      min-height: var(--key-min-height); /* Min height */
      flex: 1 1 auto; /* Allow growth and shrinkage, base size auto */
      /* Flex will distribute width based on available space */
      min-width: 0; /* Allow shrinking below content size */


      font-size: clamp(0.9rem, 3.5vw, 1.2rem); /* Adjusted font size slightly */
      font-weight: bold;
      border: 3px solid transparent;
      border-radius: 4px;
      background-color: var(--key-bg);
      color: var(--key-text);
      cursor: pointer;
      transition: background-color 0.2s, color 0.2s, border-color 0.2s;
      display: flex;
      justify-content: center; /* Center letter horizontally */
      align-items: center; /* Center letter vertically */
      user-select: none;
      touch-action: manipulation;
      text-transform: lowercase;
      padding: var(--key-padding); /* Add padding inside the key */
      box-sizing: border-box; /* Ensure padding is included in flex size */
    }
    .key:hover {
        filter: brightness(90%);
    }

    /* --- Enter/Delete Keys --- */
    .key.enter,
    .key.delete {
      /* These are in the top FLEX row */
      height: var(--key-height); /* Match height of letter keys */
      min-height: var(--key-min-height); /* Match min-height */

      /* Flex basis and grow/shrink ratio */
      flex: 1.5 1 auto; /* Grow 1.5x more than delete, shrink 1x, base auto */
      font-size: clamp(0.7rem, 2.5vw, 0.9rem);
      color: white;
      border-width: 3px;
      border-style: solid;
      padding: var(--key-padding); /* Add padding */
      min-width: 0; /* Allow shrinking */
    }
     .key.delete {
         flex: 1 1 auto; /* Grow 1x, shrink 1x, base auto */
         background-color: var(--delete-key-bg);
         border-color: var(--delete-key-bg);
         white-space: nowrap;
         min-width: 0; /* Allow shrinking */
     }


    .key.placeholder {
        background: transparent;
        pointer-events: none;
        border-color: transparent;
        visibility: hidden; /* Hide the placeholder key visually */
        /* Placeholders need the same flex properties as letter keys */
        height: var(--key-height);
        min-height: var(--key-min-height);
        flex: 1 1 auto;
        padding: var(--key-padding);
        box-sizing: border-box;
        min-width: 0; /* Allow shrinking */
    }

    .key.correct {
      background-color: var(--correct-bg);
      color: var(--tile-text-dark);
      border-color: transparent;
    }
    .key.present {
      background-color: var(--present-bg);
      color: var(--tile-text-dark);
      border-color: transparent;
    }
    .key.absent {
      background-color: var(--absent-bg);
      color: var(--tile-text-dark);
      border-color: transparent;
    }

    .key.correct.has-present {
        border-width: 3px;
        border-style: solid;
        border-color: var(--present-bg); /* Yellow border for correct + present */
    }


    .message-container {
        position: fixed;
        top: 70px;
        left: 50%;
        transform: translateX(-50%);
        min-height: 30px;
        z-index: 10;
        width: 90%;
        max-width: 350px; /* Match board width */
    }
    .message {
      text-align: center;
      font-size: 1em;
      margin-top: 0.5rem;
      padding: 8px 10px;
      font-weight: bold;
      background-color: #333;
      color: white;
      border-radius: 5px;
      visibility: hidden;
      opacity: 0;
      transition: visibility 0s 1.5s, opacity 1.5s linear;
      white-space: normal;
      word-wrap: break-word;
    }
     .message.show {
        visibility: visible;
        opacity: 1;
        transition: opacity 0.3s linear;
     }

    .dark {
        --bg-color: #121213;
        --text-color: #fff;
        --tile-border-empty: #3a3a3c;
        --tile-border-filled: #565758;
        --key-bg: #818384;
        --key-text: #dadce0;
        --tile-text-light: #fff;
        --link-color: #64b5f6;
    }

    .dark .message {
      background-color: #eee;
      color: #121213;
    }
     .dark .key:hover {
         filter: brightness(115%);
     }
     .dark .key.enter:hover, .dark .key.delete:hover {
          filter: brightness(110%);
     }
      .dark .key.correct.has-present:hover {
         filter: brightness(110%);
     }

    .dark .key.correct { background-color: var(--correct-bg); color: var(--tile-text-dark); border-color: transparent;}
    .dark .key.present { background-color: var(--present-bg); color: var(--tile-text-dark); border-color: transparent;}
    .dark .key.absent { background-color: var(--absent-bg); color: var(--tile-text-dark); border-color: transparent;}

    .dark .key.correct.has-present {
        border-color: var(--present-bg);
    }

    /* Styles for the toggle buttons */
    #toggle-theme, #toggle-keyboard {
      position: absolute;
      top: 10px;
      padding: 6px 10px;
      font-size: 0.9rem;
      border-radius: 5px;
      cursor: pointer;
      border: 1px solid #ccc;
      background-color: #eee;
      color: #333;
      z-index: 20;
    }
    #toggle-theme {
        right: 10px;
    }
    #toggle-keyboard {
        right: 60px; /* Position to the left of the theme button */
        white-space: nowrap;
        min-width: 40px; /* Ensure it's not too small */
        text-align: center;
    }

    .dark #toggle-theme, .dark #toggle-keyboard {
        background-color: #333;
        color: white;
        border-color: #555;
    }


    @keyframes shake {
      0%, 100% { transform: translateX(0); }
      10%, 30%, 50%, 70%, 90% { transform: translateX(-5px); }
      20%, 40%, 60%, 80% { transform: translateX(5px); }
    }
    .shake { animation: shake 0.6s ease-in-out; }

    footer {
        flex-shrink: 0; /* Keep footer from shrinking vertically */
        width: 100%;
        text-align: center;
        padding: 8px 0;
        margin-top: 3px;
        font-size: 0.8em;
        color: #555;
    }
    footer a {
        color: var(--link-color);
        text-decoration: none;
    }
    footer a:hover {
        text-decoration: underline;
    }
    .dark footer {
        color: #aaa;
    }

    /* Media Query for very small/short screens */
    @media (max-width: 380px) {
        :root {
           --key-min-height: 36px; /* Slightly smaller min height */
           --key-height: 40px; /* Reduce base height as well */
        }
        h1 {
            font-size: 1.3rem;
            margin-top: 8px;
        }
        .subtitle {
            margin-bottom: 3px;
        }
        .board-container {
            margin: 5px 0;
            /* board max-width remains 350px */
        }
         /* Keyboard max-width remains 100% or initial */
        .board, .row {
            grid-gap: 3px;
        }
        #keyboard {
            gap: var(--key-gap);
            padding: 0 2px; /* Adjust horizontal padding */
            margin-top: 3px;
        }
        #keyboard-top-row, #keyboard-main-grid .keyboard-row {
            gap: var(--key-gap);
        }
         .key.enter, .key.delete {
             min-height: 36px; /* Ensure enter/delete shrink but not too much */
         }
        #toggle-theme, #toggle-keyboard {
            padding: 4px 7px;
            font-size: 0.8rem;
            top: 5px;
        }
        #toggle-theme { right: 5px; }
        #toggle-keyboard { right: 50px; }

        footer {
            padding: 5px 0;
            margin-top: 5px;
            font-size: 0.7em;
        }
        .message-container {
            top: 60px;
            max-width: 300px; /* Slightly reduce message container width */
        }
    }
     /* Media query for wider screens where keys can grow more */
    @media (min-width: 551px) {
        :root {
             /* Adjust key height for potentially wider keys, or keep it consistent */
             --key-height: 55px; /* Larger key height on desktop */
             --key-min-height: 55px; /* Min height matches height */
        }
        #keyboard {
            /* Allow keyboard to be wider than main-content if keys are large */
            max-width: initial;
        }
         .key {
            /* Set a desired base width when there's ample space */
            /* This combined with flex: 1 will make them try to be wider */
             flex-basis: 45px; /* Example desired base width */
         }
         .key.placeholder {
              flex-basis: 45px; /* Placeholder matches */
         }
    }


  </style>
</head>
<body>
  <div class="main-content">
      <h1>Wordle <img src="flag.png" alt="üá¶üá≤" style="height: 0.7em; vertical-align: middle;"></h1>
      <p class="subtitle">by Armen Mkrtchyan</p>

      <button id="toggle-keyboard">‘±‘≤‘≥</button> <!-- Keyboard Toggle Button -->
      <button id="toggle-theme">üåó</button>
      <div class="message-container">
         <div id="message" class="message"></div>
      </div>
      <div class="board-container">
         <div class="board" id="board"></div>
      </div>
      <div id="keyboard">
          <div id="keyboard-top-row"></div>
          <div id="keyboard-main-grid"></div>
      </div>
  </div>

  <footer>
      <a href="https://armblog.net" target="_blank" rel="noopener noreferrer">Armblog.net</a>
  </footer>

<script>
  const boardElement = document.getElementById('board');
  const keyboardTopRowElement = document.getElementById('keyboard-top-row');
  const keyboardMainGridElement = document.getElementById('keyboard-main-grid');
  const keyboardElement = document.getElementById('keyboard');
  const toggleBtn = document.getElementById('toggle-theme');
  const keyboardToggleBtn = document.getElementById('toggle-keyboard'); // Get the new button
  const messageElement = document.getElementById('message');

  // --- Constants ---
  const WORD_LENGTH = 5;
  const MAX_ROWS = 6;
  const ENTER_KEY = '’®’∂’§’∏÷Ç’∂’•’¨';
  const DELETE_KEY = '’ª’∂’ª’•’¨';

  // --- Word List (Assumed 5 letters, lowercase) ---
  // (Keep your large word list here)
  const WORDS = ['÷Ü’∏’ø’∏’∂','’∂’º’∂’°’Ø','’∞’∂’§’´’Ø','’∞’•’≤’∏÷Ç’Ø','’°÷Ä’£’∏’∂','’©÷Ä’©’∏÷Ç’º','’Ø’°’µ’∏÷Ç’∂','’¨’∏÷Ç’Æ’∏÷Ç’¥','’∑’°’∫’´’Ø','’∞÷Ä’∑’•’ª','’®’¥’¢’´’∑','’¥’•’ø’°’≤','’°’æ’•’¨’´','’°’∂’¶’•’∂','’∞’°’∑’´’æ','’©’°÷É’∏÷Ä','’≠’•’¨’°’º','’¨÷Ñ’æ’°’Æ','’§’°’µ’°’Ø','÷Å’•÷Ä’•’Ø','’Ø’ø÷Ä’∏÷Ç’Ø','’Ø’≥’≤’°’Ø','’æ÷Ä’°÷Å’´','÷Ñ’∏÷Ç’º’°’Ø','’¢’∏÷Ä’Ω’°','’Æ’°’≤’´’Ø','’∞’°’ø’´’Ø','’∂’´’∞’°÷Ä','’°÷Ä’±’°’Ø','’©÷Ä’©’∏÷Ç÷Ä','’ø’∏’Ø’∏÷Ç’∂','’•’≤÷á’∂’´','’Ω’°’∫’°’ø','’∂’•’≤’∏÷Ç÷Å','’¢’™’´’∑’Ø','’∏÷Ç’º’•’∂’´','’π’æ’•÷Ä’©','’¥’°’Ω’∏÷Ç÷Ä','’¥’•’©’∏’§','’©’∑’∑’∏÷Å','÷Ñ’∂÷Ñ’∏÷Ç’∑','÷É’•’©’°’Ø','’¥’•’§’´’°','’Ø÷Ä’∏÷Ç’∂’Ø','’Ø’°’©’Ω’°','’Ø’∏’°’¨’°','’£’´’ø’°’Ø','’Ø÷Ä’Ø’•’Ω','’æ’°÷Ä’°’¶','÷É’•’ø’∏÷Ç÷Ä','’Ø’ø÷Ä’´’≥','’∞’°’ø’∏÷Ç’Ø','’Ø’°’≤’∂’´','’∫’°’∫’´’Ø','’•’¨’∏÷Ç’µ’©','’°’Ø’°’¥’°','’¢’∏÷Ç’™’∏÷Ç’¥','’°’∂’Ø’°’∫','’¥’°’¥’∏÷Ç’¨','÷Ö÷Ä’£’°’∂','’°÷Ä÷á’∏’ø','’§’°’Ø’´’π','’©÷á’∂’∏÷Å','’∫’°’ø’´’æ','’¥’•’ø÷Ä’∏','÷Ö’©’µ’°’Ø','’§÷Ä’°’≠’ø','’•’º’°’∂’§','’°÷Ä’Ø’°’Æ','’§’°’¨’°÷Ä','’£’∏÷Ç’¨’∫’°','’≠÷Ä’∏’≠’ø','’Ø’°’∏÷Ç÷Ä’´','÷Ñ’°’∂’∏’∂','’≥’°’≤’°’ø','’£’∂’∏÷Ä’§','÷É’≠÷Ä’∏÷Ç’∂','’§÷Ä’°’¥’°','’º’•’ø’´’∂','’¶’≤’ª’∏÷Ç’¥','’Ø’°’∫’´’π','’°’∫’ø’°’Ø','’ß’Ø÷Ä’°’∂','’¢÷Ä’§’µ’°','’§’°’∞’∏÷Ç’Ø','’∫’≤’ø’∏÷Ä','’§’°’§’°÷Ä','’•÷Ä’∑’´’Ø','’±’µ’∏÷Ç’§’∏','’ª’∏÷Ç’©’°’Ø','’¨’æ’°÷Å÷Ñ','’°÷Ä’Æ’°’©','’∫’∏÷Ç÷Ä’°’Ø','’§’•’Ø’°’∂','’¨’°’æ’°’∑','’£’°’æ’°’©','’¢’∏÷Ç’¨’Ø’´','’Ω’´÷Ä’∏÷Ç’∂','’Ø’°’ø’°’Ø','’¶’∏’§’∏÷Ç’¥','’©’•÷É’∏÷Ç’Ø','’°’∂’ø’•÷Ä','’Ω’°÷É’∏÷Ä','’∞’µ’∏÷Ç’Ω’∂','’∞’°’∂’∏÷Ç’¥','’¢’µ’∏÷Ç’ª’•','’Ω’•’¶’∏’∂','’∂’´’¶’°’Ø','’£÷Ä’∫’°’∂','’¢’¨’≤’∏÷Ç÷Ä','’∫’≤’∫’•’≤','’Ø’∂’≥’´’º','’Ω÷Ä’´’∂’£','’•’≤’´’∂’ª','’∞’°’Ω÷Å’•','’ø’¶÷Ä’∏÷Ç’Ø','’Ω’∫’´÷Ä’ø','’§÷Ä’æ’°’£','’ø’∏’Ø’∏’Ω','’¥’°’£’´’¨','’°÷Ä’¥’°’æ','’æ’Ω’ø’°’∞','’°’∂÷Å’∏÷Ç’¥','’π’°÷Ä’°’¶','’°’¥’¢’∏’≠','’∫’°’∞’∏÷Å','’°’Ø÷Å’´’°','’ø’´’ø’°’∂','’∏÷Ç÷Ä’¢’°’©','’°’∂’£’´÷Ä','’Ø’•’∂’°÷Å','’≠’∏’º’∏’π','’°’≤’°’∂’±','’§’°÷Ä’°’Ø','÷É’°÷É’∏÷Ç’Ø','’£’¥’¢’•’©','’≠’∏’∂’°’æ','’∂’°’≠’∂’´','’£’∂’§’°’Ø','’°’¶’§’°’Ø','’ª’∏’Ø’°’ø','’©’•’∂’´’Ω','’≥’°’∞’´’≥','’¢’∂’∏÷Ç’µ’©','’≠÷Ä’≥’´’©','’©’´÷Ä’°’≠','’ø’°’≥’°÷Ä','’∂’∑’•’∂’´','’°’∂’±÷Ä÷á','’∞’°’ø’∏÷Ç’¥','’£’°÷Ä’∏÷Ç’∂','’≠’∏÷Ç÷Ä’¥’°','’ª’•’º’∏÷Å','’∑’∂’∏÷Ä’∞','’∫’°’ø’´’™','’™’∏’≤’∏’æ','’§’´’•’ø’°','’Ø’°’∂’∏’∂','’≤’°’¶’°’≠','’°’¶’∂’´’æ','’¥’∏’≠’´÷Ä','’≥’°’∑’°’Ø','’¢’∂’°’¶’§','’°’∂’∞’∏’£','’≥’°’£’°÷Ä','’§’∏÷Ç’§’∏÷Ç’Ø','’≠’∏’™’∏’º','’°’ª’¨’´’Ø','÷Ñ’∏’©’∏÷Ç’Ø','’°’∂’±’°’æ','’¢’¥’¢’∏÷Ç’¨','’≠’∂’§’´÷Ä','’Ω’∏÷Ç’¨’∏÷Å','’¢’°’∂’∏÷Ç’Ø','’Ø’°’æ’´’≥','’∞÷Ä’§’•’∞','’Ω’°’¥’¢’∏','’∞’∏’æ’´’æ','’°’º’µ’∏÷Ç’Æ','’Ø’∏’≤’∏’æ','’°÷Ä’≥’´’≥','’Ω’¥’¢’°’Ø','÷Ñ’°’≤÷Å÷Ä','’°’∂’ø’°’∑','’©’°’∂’±÷Ä','’•÷Ä’Ø’´÷Ä','’°’ø’¨’°’Ω','’™’µ’∏÷Ç÷Ä’´','’Ω’ø’∏÷Ç’µ’£','’≠’¨’∏÷Ç÷Ä’§','’´’¥’°’Ω’ø','’•’º’°’Ø’´','’Ø÷Ä’Ø’´’∂','’Ω÷Ä’´’Ø’°','’Ø’°’©’´’¨','’©’°’º’°÷É','’≥’°’Ø’°’ø','’Ø’∏’Ø’´’Ø','’Ω’∏÷Ç’ø’°’Ø','’Ø’¥’°’≠÷Ñ','’°’∂’¢’´’Æ','’≠’≠’∏÷Ç’∂’ª','’¥’ø÷Ä’∏÷Ç’Ø','’Ø÷Ä’∫’°’Ø','’°’≤’µ’∏÷Ç’Ω','’¥’ø÷Ä’°’Ø','’∞÷Ä’©’´’º','’°÷Ä’™’•÷Ñ','’ß’°’Ø’°’∂','÷Ü’´’¶’´’Ø','’æ’°÷Ä’°’Ø','’¢’°÷Å’∏÷Ç’¥','’°’º’æ’°’Ø','’§’∏’∂’∏÷Ä','’∞’∏÷Ç’¶’´’π','’Ø’µ’°’∂÷Ñ','’≠’∂’°’¥’´','’©’°÷É’∏÷Ç÷Ä','’Ø’°÷Ä’∏’ø','’∞’°’¥’•’¥','’π’∂’π’´’∂','’ø’•’Ω’∏÷Ç’π','’∏÷Ç’≤’•÷Ä’±','’∑’°÷Ñ’°÷Ä','’¥’°’¨’∏÷Ç’≠','’Ø’∏’¥’´’Ø','’∞’°’Ω’∏÷Ç’∂','’°’≤’æ’•’Ω','’ø’°÷Ñ’Ω’´','’¶’æ’°÷Ä’©','’§÷Ä’∏’∑’¥','’Æ’°’Æ’∏÷Ç’Ø','’¥’°÷Ñ’∏÷Ç÷Ä','÷Ö’∫’•÷Ä’°','’Ø’∏÷Ç’¶’´’Ø','’Ø’´’©’°’º','’±’æ’°’±÷á','’©’©’•’∂’´','’ß’©’´’Ø’°','’π’°’¥’°’∂','’∂’°’≠’´÷Ä','’¢’¨÷Ä’°’Ø','’¢’∏÷Ç’§’§’°','’°’¢’•’≤’°','’∞’∂’°’∏’≥','’•’¶’°’Ø’´','’§’™’æ’°÷Ä','÷É’°’©’•’©','’∫’ø’∏÷Ç’µ’ø','’°÷Ä’§’°÷Ä','’°’≤÷Å’°’∂','’°’º’∏÷Ç’µ’£','’¨÷Ä’ø’•’Ω','’°’∂’≠’∂’°','’º’•’£’¢’´','’°’Æ’•’¨’´','’∞’∏’æ’°’¶','÷Ñ’°÷Ä’∏’¶','’π’°’¥’´’π','’£÷Ä’•’©’•','’°’≤’¥’∏÷Ç’Ø','’§’™’£’∏’∞','’≠’∏’∑’∏÷Ä','’∑’´’ø’°’Ø','’∞’°’¥’°’º','’¢’°’∂’°’∂','’¥’´’ø’∏÷Ç’¥','’∞’∏÷Ç’™’Ø’∏÷Ç','÷Ö÷Ä’•’∂÷Ñ','’¶’∂’§’°’∂','’Ω’∏’≤’∏÷Ç’∂','’£’∂’°÷Å÷Ñ','÷É’∏’≤’∏÷Å','’¢’∏’æ’°’Æ','÷Ñ’°÷Å’°’≠','’π’¥’∏÷Ç’∑’Ø','’™’°’∂’´÷Ñ','’Æ’≤÷Ä’´’§','’∞’°’Ω’°’Æ','’©’∏’∑’°’Ø','’°’∂’¥’°’∞','’ø’°÷Ä’•÷Å','’¨’•’¥’∏÷Ç÷Ä','’∫’°’∂’§’°','’¥’Ø÷Ä’°’ø','’≠’º’∫’∏’ø','’≠’°’æ’´’Æ','’¢÷Ä’§’∏’ø','’•÷Ä’§’∏÷Ç’¥','’π’•’¶’∏÷Ñ','’∂’∏’ø’°÷Ä','’æ’ø’°’∂’£','’∫’´÷Å÷Å’°','÷Ü’•÷Ä’¥’°','’Æ’∏’æ’°÷É','’°’£’•’∂’ø','’¥’°’º’°’∂','’æ’´’∫’°’Ø','’º’∏÷Ç’¢’¨’´','’∞’∏÷Ç’∑’∏÷Ç’¥','’∫’°’º’°’æ','’≠’¥’¢’°’Ø','’Ω’∫’∏÷Ç’∂’£','’©’º’π’∏÷Ç’∂','’°’ø’µ’°’∂','’¢’•’Ø’∏÷Ä','’¥’°’ø’∏÷Ç’º','’´’∂’•÷Ä’ø','’©’∏÷Ç’©’°’Ø','’°’∂’ø’∏÷Ç’∂','’°’¢’≠’°’¶','’¢’∏’¢’´’Ø','’π’°÷Ä’π’´','’¶’£’•’Ω’ø','’∞’∏÷Ç’¨’´’Ω','’≠’°’æ’°÷Ä','’£’°’¨’°÷Ä','’∂’∏÷Ä’•’Ø','’£’∏’º’∏’¶','’¢’°’¶’∏÷Ç’Ø','’æ’¶’Ø’°’∫','’°’∂’°’¥’∫','’Ω’∂’§’´’Ø','’≠’∏÷Ç’≥’∏÷Ç’≥','’¨’°’¶’•÷Ä','’ø’°÷É’°’Ø','’¶’´’ª’∏’≤','’°’Ø’∏÷Ç’¥’¢','’Ø’∂’∏÷Ç’∂÷Ñ','’Ω’°’¨’´’Ø','’∞’∂’°÷Ä÷Ñ','’£’´’∑’•÷Ä','’£’°’¶’°’∂','’Ø’°’≤’´’∂','’Ø’°’∂’•÷É','’∫’´’ø’°’Ø','’Ω÷Ä’≥’•÷É','’ø’°’æ’´’≤','’Ω’°’¥’´’©','’¥’∏÷Ä’∏÷Ç÷Ñ','’°’¨÷á’∏÷Ä','’•’≤’∏÷Ç’∂’£','’ø’°÷Ä’°’¶','’£’°’¶’°÷Ä','’°’Ø’°’∂’ª','’Ω’∏÷Ç’¨’´’π','’©’©’æ’°’∑','’¢’°÷Å’´’π','’∫’°’ø’°’º','÷Ö÷Ä÷Ä’°’∂','÷Ö’°’¶’´’Ω','’Ø’∏÷Ä’´’¶','’∫’°÷Ä’∏’∂','’∫’°÷Ä’•’Ø','’Ø’°÷Ä’´÷Ñ','’∫’≤’´’∂’±','’©’°÷Ñ’∏÷Ç’∂','’±’°’£’°÷Ä','’•÷Ä’•’≠’°','’∞’°’∑’´’∑','’Ω’≠’ø’∏÷Ä','’°’∂’∞’°’ø','’∫’°’∞’°’Ø','’æ’´’∑’°’∫','’∑÷Ä’ª’°’∂','’Æ’°’¥’∏’∂','’¥’°’Æ’∏÷Ç’∂','’æ’°’µ÷Ä’´','’Æ’´’Æ’°’≤','’¥’´’ª’°’ø','’©’°’¨’°’∂','’∂’°’¥’∏÷Ç’Ω','’°’¥’∏÷Ç÷Ä’´','’æ’°’≤’∏÷Ç÷Å','’∞’∏÷Ç’¥’∏÷Ä','’°’¥’∏÷Ä÷Ü','’≠’∂’∏÷Å’´','’Ω÷É’º’∏÷Å','’¢’°’¶’∏÷Ç’¥','’©’°÷É’∏’∂','’°’∫÷Ä’´’¨','’§’•’¨’ø’°','÷Å’∂÷Å’∏÷Ç’≤','’¶’°’æ’°’Ø','’Ø’°’µ’Ω÷Ä','’¢’∏’¨’∏÷Ç’Ø','’¥’•’∂’°’Ø','÷É÷Ä’Ø’´’π','’≠’≤’≥’∏÷Ç’Ø','’π’•’π’•’∂','’Ω’µ’∏÷Ç’™’•','’°’≥’µ’∏÷Ç’∂','’Ø’°’∑’æ’•','’Ω’ø÷Ä’∏÷Ç’Ø','’¢’°’¨’•’ø','’©’°’∂’°÷Ñ','’Ω’°’∂’´’Ø','’Ø’∑’•’º÷Ñ','’©’¥’¢’∏÷Ç’Ø','’æ’´÷Ä’∏÷Ç’Ω','’¢’º’∂’´’π','÷Ñ’°’¥’´’π','’¨÷Ä’°’ø’∏÷Ç','’£’°’≥’°’≥','’©’∏’æ’´’π','’¥’´’ª’∏÷Å','’¥’∏’ø’´’Ø','’§’´’¥’°’Ø','’¢’°’™’°’Ø','’°’æ’°÷Ä’ø','’§’°’™’°’∂','’¢’Ø’¨’´’Ø','’°÷Ä’©’∏÷Ç’∂','’¥’°’∂÷Ä’ß','’Ø’∏’ø’•’¥','’£’∏’¥’•’∑','’Ω’´’Ω’•’º','’Ω’°’æ’°’∂','÷Ö’§’°’π’∏÷Ç','’Ω’∏’≠’°’Ø','’Æ’´’Æ’°’Ø','’Ω’∏’≠’∏÷Ç’Ø','’®’∂’Ø’•÷Ä','’∂’•÷Ä’Ø’°','’∑’¨’§’´’Ø','’Æ’∫’ø’∏÷Ç’∂','’≥’Ø’∏÷Ç’µ’©','’°÷Ñ’¨’∏÷Ä','’°’Ø’∂’∏÷Å','’£’∂’§’´’Ø','÷Å’∏÷Ç÷Å’∏÷Ç’¥','’Æ’°’£’∏÷Ç’¥','÷Ñ’∂’∂’´’π','’°÷Ä’∑’°’æ','’°’≤’ª’´’Ø','’∏÷Ç’∂’•’¨’´','’Ω’∂’∏÷Ç’∂’§','’ø’≠’¥’°÷Ä','’ø’´’Ø’´’∂','’∞’∫’°÷Ä’ø','’Ω’©÷Ä’•’Ω','’Ω÷Ä’æ’°’Ø','÷Ö’©÷á’°’∂','’¢’∏’≤’∏÷Ñ','’°÷Ä’¥’°’ø','’Ø÷Ä÷Ñ’∏’ø','’Æ’°’∂’∏’©','’°÷Ä’µ’∏÷Ç’∂','’•÷Ä’°’∂’£','’°’≥’∏÷Ç÷Ä’§','’¨’µ’°÷Ä’§','’°’¥’°’µ’´','’¶÷Ä’∏÷Ç’µ÷Å','’Ω’°’¨’∏÷Ä','’•÷Ä’Ø’°’©','’ø’∏’∂’∂’°','’°÷Ä’Æ’´’æ','’§÷Ä’∏÷Ç’µ’©','’∂’µ’°÷Ä’§','’°’∂’£’•’ø','’Ø’°’ø’°÷Ä','’§÷Ä’°÷Å’´','’¨’°÷Ä’∏÷Ç’¥','’Ø’º’∏÷Ç’∂’Ø','’∏÷Ç’≤÷á’∏÷Ä','’¥’°’∂’£’∏','’°’¨’¢’∏’¥','’¢’•’≤’¨’∏÷Ç','’°’∂’∏÷Ç÷Ä’ª','’§’∏÷Ç’Ω’ø÷Ä','’∏’≤’∏÷Ä’Ø','’´’∑’≠’°’∂','’∏’¨’∏÷Ä’ø','’∏÷Ç’¨’∏÷Ç’∂÷Ñ','’°’∂’≥’°÷Ä','’©’∏’∂’´÷Ä','’°’∏÷Ç’§’´’∏','’¢’´’¶’∏’∂','’Ø’∏’≤’°’Ø','÷Å’∏÷Ä’•’∂','÷Ö÷Ñ’Ω’´’§','’Ω’¥’¢’∏÷Ç’Ø','’Ω’°’¥’¢’°','’°’∂’Ø’∏’π','÷Ñ’°’∂’°’Ø','’∞’∏’Ø’•’µ','’æ’°’∞’°’∂','’≠’°’∂’∏÷Ç’©','’∞÷Ä’°’∑÷Ñ','’Ø’∏’∑’´’Ø','’°’∂’¥’´’ø','’¶’∏÷Ä’•’≤','’°÷Ä’±’°’∂','’ø’•’Ω’°’Ø','÷Å’∏’≤’∏÷Ç’∂','’∏’Ω’Ø’∏÷Ä','’§’°’£’°’≤','’°’∫’°’Ø’´','’§’´’∫’∏÷Ç’Ø','’©’°’©’°÷Ä','’¥’Ø’∂’´’Ø','’Ø’∏’Ø’∏’Ω','÷É’∏÷Ç’π’´’Ø','’°’∂’§’∏÷Ç÷Ä','’°’¥÷É’∏÷É','’Ø’∏’¢÷Ä’°','’£’°’£’°’©','’°’∫’∑’°’Æ','’¢÷Ä’´’∂’±','’∂’™’∏÷Ç’µ’£','’•’≤’∂’´’Ø','’Ω’•’∂’°’ø','’º’•’¶’∏÷Ç’Ω','’ª’∂’ª’∏÷Å','’∑’°’∑’Ø’´','’Ø’∏’≥’°’Ø','’°’£’º’°’æ','’´’Ω’¨’°’¥','’§’≤’µ’°’Ø','’¥’•’º’°’Æ','’£’•÷Ä’°’∂','’¶’∂’∂’∏’≤','’©’´’©’•’º','’∑’•÷É’∏÷Ä','’°÷Ñ’Ω’∏÷Ä','’Ω’•’¨’°’æ','’¥’°’∂’∏÷Ç’Ø','’Ω’´’¢’•’≠','’Ω’∫’∏÷Ä’ø','’∫’∂’§’∏÷Ç’Ø','’•÷Ä’¢’•÷Ñ','÷Ñ’´’¥’´’Ø','’∫’°÷Ä’°’∂','’°÷Ä’§’∏÷Ç’Ø','’≠’∂’±’∏÷Ä','’∂’•’≠’∏÷Ç÷Ä','’∞’Ω’ø’°’Ø','’¥’´’ª’∏÷Ç’Ø','’Ω’ø’æ’•÷Ä','’£’•’ø’´’∂','÷É’°÷Ä’∏’Ω','’∞’∂’π’•’≤','’ø’°’ø’´’Ø','’©’∑’æ’°’º','÷Ñ’¨’∏÷Ç’∂’£','’±’°’æ’°÷Ä','’∫’°’¨’°’ø','’°’∂’ª’∏÷Ç÷Ä','’Æ’≤’∏’ø’•','’ø’°’∂’´÷Ñ','’∞’°’Ω’°’Ø','’≠’°’≤’°’≤','’∫’°’Ø’°’Ω','’Ø’°÷Ä’´’≥','’∞’Ω’Ø’´’π','’°’Ø’∏÷Ç’∂÷Ñ','’•÷Ä’•’Ø’∏','’¨’∏÷Ç÷Å’Ø’´','’°’∂’Ω’•’º','’∑’°÷Ä’°’∂','’∞’∏’∫’∏’∫','’ø’°÷Ä’´÷Ñ','’∞’°’¥’°÷Ä','’Ø’∏÷Ç÷Ä’Æ÷Ñ','’°’∂’•’Æ÷Ñ','’∫’°’∑’°÷Ä','’π’≤’ª’´’Ø','’≠’∏÷Ä’°’∂','’æ’´’Ω’Ø’´','’°’∂’Ø’°’≠','’¨’∏÷Ç’Ω’°’∂','’•’≤’µ’°’¥','’°’æ’°’∂’§','’Ø’°÷Ñ’°’æ','’°’¨’µ’∏÷Ç÷Ä','’Ø’°’∫’°÷Ä','’¥’∏÷Ä’•’≠','÷É÷Ä÷É’∏÷Ç÷Ä','’∂’°’¥’°’Ø','’¥’©’•÷Ä÷Ñ','’°’∂÷Å’°’Æ','’§’™’∏’≠÷Ñ','’Ω’Ø’´’¶’¢','’Ø’°’∫’∏÷Å','’•’≤’•’º’∂','’¢’°÷Ä’§’´','’¢’∏÷Ç’™’´’π','’¥’•’≠’°’Ø','’∫’∂’§’∏÷Ç’¥','÷Ä’°’¢’¢’´','’Ω’•’≤’°’∂','’π’°÷É’∏÷Ç’¥','’Æ’∏÷Ç’≤’°’Ø','’Ø’∏’∫’•’Ø','’Æ’°÷Ä’°’æ','÷Å’∂÷Å’∏÷Ç’¥','’°’Ø’∏÷Ä’§','’∏’π’´’∂’π','÷Ñ’´’¥’´’°','’°’Ø÷Å’´’¶','÷Ü’°’∂’ø’°','’©’°’æ’´’∑','’≠’∑’∑’∏÷Å','’¥’∏’Æ’°’Ø','’°’æ’°’¶’•','’Ø÷Ä’≥’°’ø','’Ø’°’∫’´’Ø','’¢÷Ä’∏’∂’¶','’∞’°÷Ä’°’æ','’©’•÷Ä’°’≥','’º’•’™’´’¥','÷Å’∏÷Ç÷Å’°’Ø','’¢’•÷Ä÷Ä’´','’¢’°’™’´’∂','’ø’∏’¥’°’ø','’∂’æ’°’Ω’ø','’∞’°’¥’•’≤','’ø’°’Ø’°’º','’¶’£’°’Ω’ø','’£’•÷Ä’°’≥','’∑÷Ñ’•÷Ä’©','’¨’∏’≤’°÷É','’°’∫’°’£’°','’¢’°’∂’°’Ø','’∞’°÷Ä’´’π','’¶’∏÷Ç’º’∂’°','’º’∏’¢’∏’ø','’∫’°÷Ä’£÷á','’°’∂’¥’•’≤','’∑’º’°’µ’¨','’Ω’≠’•’¥’°','’∞’∏÷Ç’∂’´’Ω','’°’µ’¨’∏÷Ç÷Ä','’Ø’°’¥’°÷Ä','’°÷Ä’§’•’∂','’ø’°’ª’´’Ø','’≠’°÷Ä’°’∂','’π÷Ñ’∂’°’≤','’¢’°÷Ä’±÷Ä','÷Ñ’°’≤’°÷Ñ','’©’¶’•’∂’´','’¢’∑’ø’´’Ø','’°’≤÷Ñ’°’ø','’©’°’≠’´’Æ','’Ø’°’Ø’°’π','’°’∂’§’°’¥','’≠’≥’∏÷Ç’≤’´','’ª÷Ä’æ’•’™','’¨’∏÷Ä’ø’∏÷Ç','’°’æ’µ’∏÷Ç’∂','’°’Ω’∫’•’ø','’Ø’∏’π’∏÷Ç’¥','’Ω’Ø’µ’∏÷Ç’º','’°’∂’¢’°’∂','’Ø’°÷Å’´’∂','’ø’•÷Ñ’Ω’ø','’≠’´’¶’°’≠','’≥’∏÷Ç’º’°’Ø','’∂’∫’°’Ω’ø','’•’≤’•’£’∂','’Ø’∫’π’∏÷Ç’∂','’°’º’∏’≤’ª','’¥’°’µ’´’Ω','’Ø’∂’≥’´’©','’Ø÷Å’∏÷Ä’§','’¶’°’ø’´’Ø','’§’´’¥’∏÷Ç’¥','÷Ö’Ω’Ø’°÷Ä','’∞’°’¥’∏’æ','’∞’°’ø’°’Ø','’≠’¥’´’π÷Ñ','’§’°’∂’°’Ø','’Ø’°÷Ä’°’£','’°’∂’∞’°’¥','’©’º’´’π÷Ñ','’°’¥÷Ä’∏÷Å','’¥’•’¨’´÷Ñ','’Ω’•’§’°’∂','’¨’°’∫’∑’°','’¢’°÷Å’°’ø','’Ø’•’Ω÷Ö÷Ä','’Æ’Æ’∏÷Ç’¥’¢','’£’∏÷Ç’¥’°÷Ä','’Ω÷Ä’¢’´’π','’æ’¶’∂’∏÷Å','’•÷Ä’Ø’°÷Ä','’°’∂’æ’°’≠','’∞’¥’°’µ÷Ñ','’Ω’∂’°’∂’Ø','’¢’°÷Å’´’Ø','’¥’º’°’µ’¨','’¢’´÷Ä’™’°','’¢’°÷Å’´’¨','’Ø’¨’´’¥’°','’¥÷Ä÷Å’∏÷Ç’¥','’∏’∞’¥’°’Ø','’∂’°÷Ä’§’´','’¨’°’ø’ø’•','’¥’∏÷Ç’¥’´’°','’°’º’∂’•’ø','’¥÷Ä÷Ä’´’Ø','’°’≤’•÷Ä’Ω','’∏’π’≠’°÷Ä','’•’¨÷á’ß’ª','’∞’•÷Ä’∏’Ω','’£’∏÷Ç’∂’°’ø','’Ø’•’º’´’Ø','’§’•’≤’´’∂','’Ø’•’º’°’Ω','’Æ’∂’∏÷Ç’∂’§','’≠’∂’°’¥÷Ñ','’°÷Ä’≠’´’æ','’•÷Ä’£’´’π','’∞’°’¶’°÷Ä','’Ø’°÷Ä’°’∫','’∫’°’Ω’´’æ','’ø’°’¢’°’ø','’Æ’´÷Ä’°’∂','’§’∏’¨’°÷Ä','’≠’∏÷Ç’≥’°’∫','’∞’°’æ’°’ø','÷É’°’Ø’°’∂','÷É’°’©’´’¨','’£’∏÷Ç’∑’°’Ø','’Ø’°’≠’´’π','’Ω’°’Ø’°’æ','’∫’°÷Ä’•’∂','’Æ’°’Ø’∏’≤','’¨’∏÷Ç’Ω’´’∂','’º’°’§’´’∏','’Ø÷Ä’Æ’∏’≤','’∞’´’¥’°÷Ä','’Ω’•÷Ä’´’°','’¨’∏’¨’´’Ø','’≠’°’≤’∏’≤','’º’•’∞’°’∂','’°’Ω’∏÷Ç’µ’©','’§’°÷É’∂’´','’∏÷Ç’ø’•’Ω’ø','’°’µ’Ω÷Ö÷Ä','’¶’£’∏÷Ç’µ’∑','’§’∫÷Ä’∏÷Å','’¢’•÷Ä’°’∂','’¥’´’ª’´’∂','’§’∏’§’∏’∑','’°’¥’¢’°÷Ä','’°’∂’ø’´’Ø','’Æ’∏÷Ä’°’Ø','’∞’°’≥’°’≠','’•÷Ä’°’∑’ø','’∑’°’¢’°’©','’∫’°÷Ä’ø÷Ñ','’¢’°’≠’∏÷Ç’¥','’°’≤’∏’©÷Ñ','’£’¶÷Ä’∏÷Å','’°’∂’¶’∏÷Ä','’¨’´’¥’∏’∂','’ø’∂’ª÷Ä’´','’¢’º’∂’°’Ø','’°’∏÷Ç’§’´’ø','’Ω÷Ä’∏÷Ç’∂÷Ñ','’§’§’¥’´’Ø','’°’¨’´’¢’´','’ø’∏’∂’∏÷Ç’Ω','’¨’°’Ø’∏’ø','’¥’∏÷Ä’©’´','’≠÷Ä’©’´’∂','’Ø’•÷Ü’´÷Ä','’¢’°÷Ä’°’Ø','’°’∂’∏’∂’Ω','’Ω’∫’°’Ω÷Ñ','’Ø’°’∂’°’π','’æ÷Ä’±’´’∂','’≠’•’¨’∏÷Ñ','’°’¥÷Ä’°’Ø','’°’Ø’ø’´’æ','’§’°’∞’´’≥','’∑’∏÷Ç’∑’°’∂','’¥’°’ø’´’ø','’∫’°’∂’´÷Ä','’Ø’∏’∫’´’ø','’ø’°’∫’°’Ø','’Ø’°’Ø’°’∏','’æ’´’≥’°’Ø','’≥’∂’∑’∏÷Ç’¥','’°’∂’ø’°’º','’°÷Ä’°÷Ä÷Ñ','’¥’∏’≤’•’Ω','’∑’•÷Ä’•÷É','’∞’∏’æ’´’ø','÷Ü’´’¨’ø÷Ä','’∫’•’∫’Ω’´','’¥’°’Ω’∏’∂','’°’∂’Ø’∏÷Ç’¥','’∏÷Ç’¶’¢’•’Ø','’•’º’µ’°’Ø','’∂’•÷Ä’∏÷Ç’™','’°÷Ä’ª’∏÷Ç’Ø','’©’¥’¢’´’Ø','’Æ’Æ’∏÷Ç’¥’¢','’§’´’¥’°÷Å','’æ’°’∂’∏’≤','’Ø’´’Ω’°’ø','’¨’´’∂’•’¨','’°’º’∂’•’¨','’≠’∏’Ω’•’¨','’∂’Ω’ø’•’¨','’æ’°’¶’•’¨','’©’º’π’•’¨','’¨’∏’≤’°’¨','’Ω’´÷Ä’•’¨','’∞’´’∑’•’¨','’≠’°’≤’°’¨','÷Ö’£’∂’•’¨','’£’ø’∂’•’¨','’¢’°÷Å’•’¨','÷É’°’Ø’•’¨','’Ω’Ø’Ω’•’¨','’°’∫÷Ä’•’¨','’Æ’∂’æ’•’¨','÷É’∏’≠’•’¨','’•÷Ä’£’•’¨','’∫’°÷Ä’•’¨','’™’∫’ø’°’¨'];

  if (WORDS.length === 0) {
      console.error("Word list is empty!");
  }

  // --- Keyboard Layouts ---
  const alphabeticalKeyboardLayout = [
     ['’°', '’¢', '’£', '’§', '’•', '’¶', '’ß', '’®'],
     ['’©', '’™', '’´', '’¨', '’≠', '’Æ', '’Ø', '’∞'],
     ['’±', '’≤', '’≥', '’¥', '’µ', '’∂', '’∑', '’∏'],
     ['’π', '’∫', '’ª', '’º', '’Ω', '’æ', '’ø', '÷Ä'],
     ['÷Å', '’∏÷Ç', '÷É', '÷Ñ', '÷á', '÷Ö', '÷Ü', ''] // Placeholder to help last row alignment
  ];

   // The new phonetic layout based on user's input
  const phoneticKeyboardLayout = [
    ['’ß', '’©', '÷É', '’±', '’ª', '÷á', '÷Ä', '’π', '’≥', '’™'], // 10 keys
    ['÷Ñ', '’∏', '’•', '’º', '’ø', '’®', '’∏÷Ç', '’´', '÷Ö', '’∫', '’≠', '’Æ', '’∑'], // 13 keys
    ['’°', '’Ω', '’§', '÷Ü', '’£', '’∞', '’µ', '’Ø', '’¨'], // 9 keys
    ['’¶', '’≤', '÷Å', '’æ', '’¢', '’∂', '’¥'] // 7 keys
  ];


  // --- Daily Word Logic ---
  const startDate = new Date("2025-04-11");
  const today = new Date();
  today.setHours(0, 0, 0, 0);
  const dayOffset = Math.floor((today - startDate) / (1000 * 60 * 60 * 24));
  const targetWord = WORDS.length > 0 ? WORDS[dayOffset % WORDS.length] : "’Ω’≠’°’¨";
  const parsedTarget = splitWord(targetWord);
  const dateKey = `armenianWordle-${today.toISOString().split('T')[0]}`;
  const layoutStorageKey = 'armenianWordleKeyboardLayout';


  // --- Game State Variables ---
  let guesses = [];
  let currentGuess = [];
  let currentRowIndex = 0;
  let isGameOver = false;
  let messageTimeout;
  let keyStatuses = {}; // Cumulative best status
  let lastGuessSpecificInfo = {}; // Temp info for current turn's highlighting specifics

  // --- Keyboard Layout State ---
  let currentKeyboardLayoutType = 'phonetic'; // Default layout type


  // --- Initialization ---
  function init() {
    loadState(); // Load theme, game state, AND keyboard layout preference
    buildBoard();
    updateKeyboardLayout(); // Build keyboard based on loaded preference
    redrawBoardFromState();
    updateKeyboardHighlight({}); // Initial highlight based on loaded keyStatuses

    // Check for game over state on refresh
    if (isGameOver && currentRowIndex >= MAX_ROWS) {
        const lastGuessString = guesses.length > 0 ? guesses[guesses.length - 1].map(g => g.letter).join('') : '';
        if (splitWord(lastGuessString).join('') !== parsedTarget.join('')) {
             showMessage(`’ä’°÷Ä’ø’∏÷Ç’©’µ’∏÷Ç’∂÷â ‘±’µ’Ω÷Ö÷Ä’æ’° ’¢’°’º’®’ù ${targetWord}`, 0);
             disableInput();
        } else {
             showMessage('üéâ ’Ä’°’≤’©’°’∂’°’Ø üéâ', 0);
             disableInput();
        }
    } else if (isGameOver) {
         showMessage('üéâ ’Ä’°’≤’©’°’∂’°’Ø üéâ', 0);
         disableInput();
    }

    window.addEventListener('keydown', handlePhysicalKey);
    keyboardToggleBtn.onclick = toggleKeyboardLayout; // Add listener to new button
     toggleBtn.onclick = toggleTheme; // Ensure theme toggle listener is attached
  }

  // --- State Management (localStorage) ---
  function saveState() {
    const state = {
      guesses,
      currentRowIndex,
      isGameOver,
      targetWord,
      keyStatuses // Save only the CUMULATIVE keyStatuses
    };
    localStorage.setItem(dateKey, JSON.stringify(state));
    // Keyboard layout is saved separately in updateKeyboardLayout
  }

  function loadState() {
    // Theme
    const savedTheme = localStorage.getItem('theme') || 'light';
    document.body.classList.toggle('dark', savedTheme === 'dark');
    toggleBtn.textContent = savedTheme === 'dark' ? '‚òÄÔ∏è' : 'üåó';

    // Keyboard Layout
    currentKeyboardLayoutType = localStorage.getItem(layoutStorageKey) || 'phonetic'; // Default to phonetic

    // Game State
    const savedStateJSON = localStorage.getItem(dateKey);
    if (savedStateJSON) {
        try {
            const savedState = JSON.parse(savedStateJSON);
            if (savedState.targetWord === targetWord) {
                guesses = savedState.guesses || [];
                currentRowIndex = savedState.currentRowIndex || 0;
                isGameOver = savedState.isGameOver || false;
                keyStatuses = savedState.keyStatuses || {}; // Load cumulative statuses
                // Basic validation for keyStatuses
                for (const key in keyStatuses) {
                   const validStatuses = ['correct', 'present', 'absent', null];
                   if (!validStatuses.includes(keyStatuses[key])) {
                       delete keyStatuses[key];
                   }
                }
            } else {
                console.log("New day or different word detected. Starting fresh.");
                keyStatuses = {}; // Reset key statuses for new word
            }
        } catch (e) {
            console.error("Error loading saved state:", e);
            keyStatuses = {}; // Reset on error
        }
    } else {
        keyStatuses = {}; // Reset if no state found
    }
    lastGuessSpecificInfo = {}; // Always reset this on load

    // Update the keyboard button label based on the loaded layout
    keyboardToggleBtn.textContent = currentKeyboardLayoutType === 'phonetic' ? '‘±‘≤‘≥' : '’ì’Ü‘π‘ø';
  }

   // --- Word Processing ---
   function splitWord(word) {
    const chars = [];
    const lowerWord = String(word || '').toLowerCase();
    for (let i = 0; i < lowerWord.length; i++) {
      if (lowerWord[i] === '’∏' && i + 1 < lowerWord.length && lowerWord[i + 1] === '÷Ç') {
        chars.push('’∏÷Ç');
        i++;
      } else {
        chars.push(lowerWord[i]);
      }
    }
     return chars;
   }

  // --- UI Building ---
  function buildBoard() {
    boardElement.innerHTML = '';
    for (let i = 0; i < MAX_ROWS; i++) {
        const row = document.createElement('div');
        row.className = 'row';
        for (let j = 0; j < WORD_LENGTH; j++) {
            const tile = document.createElement('div');
            tile.className = 'tile';
            row.appendChild(tile);
        }
        boardElement.appendChild(row);
    }
  }

  // --- Modified buildKeyboard to accept layout data and build Flexbox rows ---
  function buildKeyboard(layoutData) {
    keyboardTopRowElement.innerHTML = '';
    keyboardMainGridElement.innerHTML = '';

    // Top Row (Enter/Delete) - Flexbox
    [ENTER_KEY, DELETE_KEY].forEach(keyText => {
        const keyElement = document.createElement('button');
        keyElement.textContent = keyText;
        keyElement.className = 'key';
        if (keyText === ENTER_KEY) {
            keyElement.classList.add('enter');
            keyElement.onclick = handleSubmit;
        } else {
            keyElement.classList.add('delete');
            keyElement.onclick = handleDelete;
        }
        keyboardTopRowElement.appendChild(keyElement);
    });

    // Main Grid - Dynamic Flexbox rows
    layoutData.forEach(rowKeys => {
        const rowElement = document.createElement('div');
        rowElement.className = 'keyboard-row'; // Add a class for the row

        rowKeys.forEach(keyText => {
            const keyElement = document.createElement('button');
            keyElement.textContent = keyText;
            keyElement.className = 'key';
             // Only add data-key if it's not a placeholder
            if (keyText) {
                keyElement.dataset.key = keyText;
                keyElement.onclick = () => handleKeyClick(keyText);
            } else {
                 // This is a placeholder key
                 keyElement.classList.add('placeholder');
                 keyElement.disabled = true; // Disable interaction
                 keyElement.style.cursor = 'default'; // Change cursor
            }
            rowElement.appendChild(keyElement);
        });
        keyboardMainGridElement.appendChild(rowElement);
    });
  }

  // --- Keyboard Layout Toggle Logic ---
  function toggleKeyboardLayout() {
      currentKeyboardLayoutType = currentKeyboardLayoutType === 'phonetic' ? 'alphabetical' : 'phonetic';
      updateKeyboardLayout(); // Update UI and save preference
  }

  function updateKeyboardLayout() {
      const layoutData = currentKeyboardLayoutType === 'phonetic' ? phoneticKeyboardLayout : alphabeticalKeyboardLayout;
      buildKeyboard(layoutData); // Build the keyboard with the selected layout

      // Update the button text to show the *next* layout
      keyboardToggleBtn.textContent = currentKeyboardLayoutType === 'phonetic' ? '‘±‘≤‘≥' : '’ì’Ü‘π‘ø';

      // Re-apply key highlights based on current game state after rebuilding
      updateKeyboardHighlight(lastGuessSpecificInfo);

      // Save the selected layout preference
      localStorage.setItem(layoutStorageKey, currentKeyboardLayoutType);
  }


  // --- UI Updating & State Restoration ---
  function redrawBoardFromState() {
     const rows = boardElement.querySelectorAll('.row');
     rows.forEach((row, rowIndex) => {
        const tiles = row.querySelectorAll('.tile');
        if (rowIndex < guesses.length) {
             const guessData = guesses[rowIndex];
             tiles.forEach((tile, tileIndex) => {
                const letterData = guessData[tileIndex] || { letter: '', status: '' };
                tile.textContent = letterData.letter; // Set text directly
                tile.classList.remove('correct', 'present', 'absent', 'filled');
                if (letterData.letter) {
                     tile.classList.add('filled');
                     if (letterData.status) {
                         tile.classList.add(letterData.status);
                     }
                }
             });
        } else {
              tiles.forEach(tile => {
                 tile.textContent = ''; // Clear text directly
                 tile.classList.remove('correct', 'present', 'absent', 'filled');
              });
        }
     });
  }

  function updateCurrentRowDisplay() {
    if (currentRowIndex >= MAX_ROWS) return;
    const currentRow = boardElement.querySelectorAll('.row')[currentRowIndex];
    const tiles = currentRow.querySelectorAll('.tile');
    tiles.forEach((tile, index) => {
        const letter = currentGuess[index] || '';
        tile.textContent = letter; // Set text directly
        if (letter) {
            tile.classList.add('filled');
        } else {
            tile.classList.remove('filled');
        }
        tile.classList.remove('correct', 'present', 'absent');
    });
  }

  // --- updateKeyboardHighlight uses cumulative AND last guess info ---
  function updateKeyboardHighlight(displayInfoForLastGuess) { // Expects {'letter': {wasCorrect:bool, wasPresent:bool}}
    // Select all keys with a data-key attribute (actual letters)
    keyboardElement.querySelectorAll('.key[data-key]').forEach(keyElement => {
        const letter = keyElement.dataset.key;
        const cumulativeStatus = keyStatuses[letter]; // Cumulative best
        // Get info specifically for the LAST guess result display
        const lastGuessInfo = displayInfoForLastGuess ? displayInfoForLastGuess[letter] : null;

        keyElement.classList.remove('correct', 'present', 'absent', 'has-present');

        // Apply cumulative status first
        if (cumulativeStatus) {
             keyElement.classList.add(cumulativeStatus);
        }

        // If there was a 'present' match for this letter in the LAST guess
        // AND the key's cumulative status is 'correct', add the 'has-present' class for the border
        if (cumulativeStatus === 'correct' && lastGuessInfo && lastGuessInfo.wasPresent) {
             keyElement.classList.add('has-present');
        }
    });
}


   // --- Event Handlers ---
  function handleKeyClick(key) {
    if (isGameOver || currentGuess.length >= WORD_LENGTH) {
        return;
    }
    currentGuess.push(key);
    updateCurrentRowDisplay();
  }

  function handleDelete() {
    if (isGameOver || currentGuess.length === 0) {
        return;
    }
    currentGuess.pop();
    updateCurrentRowDisplay();
  }

  // --- handleSubmit updates cumulative statuses AND calculates last guess info ---
  function handleSubmit() {
    if (isGameOver) return;

    if (currentGuess.length !== WORD_LENGTH) {
      shakeRow(currentRowIndex);
      showMessage("‘±’∂’¢’°’æ’°÷Ä’°÷Ä ’ø’°’º’•÷Ä’´ ÷Ñ’°’∂’°’Ø", 1500);
      return;
    }

    const guessString = currentGuess.join('');

    // Check if the word exists in the dictionary BEFORE checking letter statuses
    if (!WORDS.includes(guessString)) {
        shakeRow(currentRowIndex);
        showMessage("’è’æ’µ’°’¨ ’¢’°’º’® ’¥’•÷Ä ’¢’°’º’°÷Ä’°’∂’∏÷Ç’¥ ’π’Ø’° :(", 1500); // Message for non-existent word
        return; // Stop processing if the word is not valid
    }

    const result = checkGuess(guessString);
    guesses.push(result);

    // Reset temporary info for this turn
    lastGuessSpecificInfo = {};

     let tempGuessSpecificInfo = {}; // Track correct/present within this specific guess result

    result.forEach(({ letter, status }) => {
        // 1. Track specifics for THIS guess result
        if (!tempGuessSpecificInfo[letter]) {
             tempGuessSpecificInfo[letter] = { wasCorrect: false, wasPresent: false };
        }
        if (status === 'correct') tempGuessSpecificInfo[letter].wasCorrect = true;
        if (status === 'present') tempGuessSpecificInfo[letter].wasPresent = true;

        // 2. Update CUMULATIVE best status for the key highlight
        const currentStoredBest = keyStatuses[letter];
        // 'correct' > 'present' > 'absent' > null
        if (status === 'correct') {
            keyStatuses[letter] = 'correct';
        } else if (status === 'present') {
            if (currentStoredBest !== 'correct') {
                keyStatuses[letter] = 'present';
            }
        } else if (status === 'absent') {
             // Before marking absent, ensure it wasn't correct/present in THIS guess
            let trulyAbsentInThisGuess = true;
             for(let item of result) {
                if(item.letter === letter && (item.status === 'correct' || item.status === 'present')) {
                   trulyAbsentInThisGuess = false;
                    break;
                }
            }
             // Mark absent only if it wasn't seen as correct/present anywhere before (cumulative)
             // AND it was truly absent in this specific guess
            if (!currentStoredBest && trulyAbsentInThisGuess) {
                keyStatuses[letter] = 'absent';
            }
        }
    });

    // 3. Store the temporary guess specific info for potential use in updateKeyboardHighlight
    // (Used specifically for the correct+present border edge case in dark mode)
    lastGuessSpecificInfo = tempGuessSpecificInfo;


    animateGuessResult(currentRowIndex, result);
    // Pass the info calculated specifically for THIS guess to the highlight function
    updateKeyboardHighlight(lastGuessSpecificInfo);

    currentRowIndex++;
    currentGuess = [];
    saveState(); // Save the updated CUMULATIVE keyStatuses

    setTimeout(() => {
        checkWinLoss(guessString);
    }, WORD_LENGTH * 150); // Delay checkWinLoss until animation finishes
  }


  function handlePhysicalKey(e) {
     if (isGameOver) return;
     let key = e.key;
     // Allow Enter, Backspace, Delete
     if (key.length > 1 && key !== 'Backspace' && key !== 'Delete' && key !== 'Enter') {
         // For other special keys (Shift, Ctrl, Alt, etc.), just ignore
         return;
     }
     key = key.toLowerCase();

     if (key === 'enter') {
         e.preventDefault(); // Prevent default form submission if any
         handleSubmit();
     } else if (key === 'backspace' || key === 'delete') {
          e.preventDefault(); // Prevent browser back navigation
         handleDelete();
     } else {
         // Handle regular letter input
         // Define allowed characters for physical keyboard input
         // Include all unique characters from both keyboard layouts + '’∏÷Ç' specific logic
         const allowedChars = new Set();
         // Add all unique characters from the layouts, filtering out empty strings
         [...alphabeticalKeyboardLayout.flat(), ...phoneticKeyboardLayout.flat()].filter(char => char).forEach(char => allowedChars.add(char));
         allowedChars.add('’∏÷Ç'); // Ensure '’∏÷Ç' is considered a valid input unit

         // Handle '’∏÷Ç' input via 'u' key (common phonetic shortcut)
         // Check if 'u' was pressed AND if '’∏÷Ç' is an allowed character unit
         if (key === 'u' && allowedChars.has('’∏÷Ç')) {
             if (currentGuess.length < WORD_LENGTH) {
                 handleKeyClick('’∏÷Ç');
                 e.preventDefault(); // Prevent typing 'u' character
             }
         }
         // Handle single letter inputs
         // Check if it's a single character AND if it's in our set of allowed characters
         else if (key.length === 1 && allowedChars.has(key)) {
            if (currentGuess.length < WORD_LENGTH) {
                handleKeyClick(key);
                 e.preventDefault(); // Prevent typing the character into something else
            }
         }
     }
  }


  // --- Game Logic ---
  function checkGuess(guessString) {
     const guessChars = splitWord(guessString);
     const result = [];
     const targetCopy = [...parsedTarget]; // Create a mutable copy

     // Pass 1: Find Correct matches (letter and position)
     for (let i = 0; i < WORD_LENGTH; i++) {
         const letter = guessChars[i];
         if (letter === targetCopy[i]) {
             result[i] = { letter: letter, status: 'correct' };
             targetCopy[i] = null; // Mark this position in targetCopy as used
         } else {
             // Initialize with letter and empty status, will fill in Pass 2
             result[i] = { letter: letter, status: '' };
         }
     }

     // Pass 2: Find Present and Absent matches
     for (let i = 0; i < WORD_LENGTH; i++) {
         if (result[i].status === 'correct') {
             // Already marked as correct, skip
             continue;
         }

         const letter = guessChars[i];
         const indexInTargetCopy = targetCopy.indexOf(letter);

         if (indexInTargetCopy !== -1) {
             // Letter is in the target word but not in the correct position
             result[i].status = 'present';
             targetCopy[indexInTargetCopy] = null; // Mark this letter in targetCopy as used
         } else {
             // Letter is not in the target word (or already used up by correct/present matches)
             result[i].status = 'absent';
         }
     }
     return result;
  }

  function checkWinLoss(lastGuessString) {
     if (splitWord(lastGuessString).join('') === parsedTarget.join('')) {
         showMessage('üéâ ’Ä’°’≤’©’°’∂’°’Ø üéâ', 5000);
         isGameOver = true;
         disableInput();
         saveState();
     } else if (currentRowIndex >= MAX_ROWS) {
          showMessage(`’ä’°÷Ä’ø’∏÷Ç’©’µ’∏÷Ç’∂÷â ‘±’µ’Ω÷Ö÷Ä’æ’° ’¢’°’º’®’ù ${targetWord}`, 10000);
          isGameOver = true;
          disableInput();
          saveState();
     }
  }

  function disableInput() {
     console.log("Game Over - Input Disabled");
     window.removeEventListener('keydown', handlePhysicalKey);
     keyboardElement.querySelectorAll('.key').forEach(btn => {
         // Only disable interactive keys, not placeholders
         if (!btn.classList.contains('placeholder')) {
            btn.onclick = null; // Remove click handler
            btn.style.cursor = 'default';
         }
     });
  }


  // --- Animations & Messages ---
  function animateGuessResult(rowIndex, result) {
     const row = boardElement.querySelectorAll('.row')[rowIndex];
     const tiles = row.querySelectorAll('.tile');
     tiles.forEach((tile, index) => {
         const { letter, status } = result[index];

         if (letter) {
            tile.classList.add('filled');
         } else {
             tile.classList.remove('filled');
         }

         // Set text and apply status class with stagger
         setTimeout(() => {
             tile.textContent = letter; // Set text directly on the tile
             if (status) {
                tile.classList.add(status);
             }
         }, index * 150); // Stagger delay for coloring/status
     });
  }


  function shakeRow(rowIndex) {
    const row = boardElement.querySelectorAll('.row')[rowIndex];
    if (row) {
        row.classList.add('shake');
        row.addEventListener('animationend', () => {
            row.classList.remove('shake');
        }, { once: true });
    }
  }

   function showMessage(msg, duration = 2000) {
        clearTimeout(messageTimeout);
        messageElement.textContent = msg;
        messageElement.classList.add('show');
        if (duration > 0) {
            messageTimeout = setTimeout(() => {
                messageElement.classList.remove('show');
            }, duration);
        }
   }

  // --- Theme Toggle ---
  function toggleTheme() {
    const isDark = document.body.classList.toggle('dark');
    const theme = isDark ? 'dark' : 'light';
    toggleBtn.textContent = isDark ? '‚òÄÔ∏è' : 'üåó';
    localStorage.setItem('theme', theme);
  }


  // --- Start the game ---
  init();

</script>

</body>
</html>
