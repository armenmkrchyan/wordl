<!DOCTYPE html>
<html lang="hy">
<head>
  <meta charset="UTF-8" />
  <meta property="og:title" content="Wordle üá¶üá≤" />
  <meta property="og:description" content="‘≥’∏÷Ç’∑’°’Ø’•÷Ñ ÷Ö÷Ä’æ’° ’¢’°’º’®" />
  <meta property="og:image" content="wordle.png" />
  <meta property="og:url" content="https://wordle.am" />
  <meta property="og:type" content="website" />
  <meta property="og:site_name" content="Wordle üá¶üá≤">
  <meta property="og:locale" content="hy_AM">
  <meta name="keywords" content="Wordle, ’Ä’°’µ’•÷Ä’•’∂, ‘Ω’°’≤, ‘≤’°’º, ‘≤’°’º’°’≠’°’≤, Armenian Wordle, ’ï÷Ä’æ’° ’¢’°’º, Armblog, Armen Mkrtchyan">
  <meta itemprop="image" content="https://wordle.am/wordle.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="author" content="Armen Mkrtchyan">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="Wordle üá¶üá≤">
  <meta name="twitter:description" content="‘≥’∏÷Ç’∑’°’Ø’•÷Ñ ÷Ö÷Ä’æ’° ’¢’°’º’®">
  <meta name="twitter:image" content="https://wordle.am/wordle.png">
  <meta name="twitter:url" content="https://wordle.am">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0"/>
  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
  <link rel="manifest" href="/site.webmanifest">
  <title>Wordle üá¶üá≤</title>
  <style>
    /* --- Global Reset & Box Sizing --- */
    html {
        box-sizing: border-box;
        height: 100%; /* Ensure html takes full height */
        overflow-y: auto; /* Allow scrolling if content exceeds viewport */
    }
    *, *:before, *:after {
        box-sizing: inherit;
    }

    html, body {
        min-height: 100%; /* Ensure body can fill viewport */
        margin: 0;
        padding: 0; /* Ensure no default padding */
    }
    body {
      font-family: sans-serif;
      display: flex;
      flex-direction: column; /* Stack children vertically */
      align-items: center; /* Center children horizontally */
      transition: background 0.3s, color 0.3s;
      background-color: var(--bg-color, #fff);
      color: var(--text-color, #000);
    }

    :root {
        --bg-color: #fff;
        --text-color: #000;
        --tile-border-empty: #aaa;
        --tile-border-filled: #666;
        --key-bg: #d3d6da;
        --key-text: #1a1a1b;
        --correct-bg: #538d4e;
        --present-bg: #b59f3b;
        --absent-bg: #3a3a3c;
        --delete-key-bg: #dc3545; /* Red */
        --enter-key-bg: #538d4e; /* Green */
        --tile-text-light: #000;
        --tile-text-dark: #fff;
        --link-color: #007bff;
        --popup-bg: #f8f9fa;
        --popup-text: #212529;
        --popup-border: #dee2e6;
        --popup-overlay-bg: rgba(0, 0, 0, 0.5);
        --popup-close-color: #6c757d;
        --popup-link-hover-bg: #e9ecef;
    }

    .main-content {
        flex: 1 1 auto; /* Allows growing and shrinking, takes available space */
        width: 100%;
        display: flex;
        flex-direction: column; /* Stack children vertically */
        align-items: center; /* Center children horizontally */
        max-width: 550px; /* Max width for the main content area */
        margin-left: auto;
        margin-right: auto;
        padding-left: 5px;
        padding-right: 5px;
        padding-bottom: 10px; /* Added some padding to the bottom of main-content */
        /* Ensure main-content aligns children even if they don't fill the width */
        align-self: center;
        position: relative; /* Needed for absolute positioning of child buttons */
    }

    .header-container {
        display: flex;
        align-items: baseline; /* Align title and game number */
        justify-content: center;
        flex-wrap: wrap; /* Allow wrapping on very small screens */
        gap: 0.5em; /* Space between title and game number */
        margin-top: 10px;
        margin-bottom: 2px;
        position: relative; /* For absolute positioning of buttons below */
        width: 100%; /* Take full width to contain elements */
    }

    h1 {
      /* Removed margins, handled by header-container */
      margin: 0;
      font-size: 1.5rem;
      white-space: nowrap;
    }

    #game-number-display {
        font-size: 0.9rem;
        font-weight: bold;
        color: var(--link-color);
        cursor: pointer;
        text-decoration: none;
        border-bottom: 1px dashed var(--link-color);
        margin-left: 5px; /* Space from title */
        white-space: nowrap;
    }
    #game-number-display:hover {
        text-decoration: none;
        border-bottom-style: solid;
    }
    .dark #game-number-display {
        color: var(--link-color); /* Keep link color distinct in dark mode */
        border-bottom-color: var(--link-color);
    }

    .subtitle {
        width: 100%; /* Ensure subtitle takes full width */
        text-align: center; /* Center subtitle text */
        font-size: 0.9rem;
        color: #777;
        margin-top: 0;
        margin-bottom: 5px;
    }
    .dark .subtitle {
        color: #aaa;
    }
     .subtitle a {
        color: inherit; /* Inherit color from subtitle */
        /* Removed text-decoration: none; */
     }
     .subtitle a:hover {
        text-decoration: underline; /* Keep underline on hover */
     }


    .board-container {
        display: flex;
        justify-content: center;
        align-items: center;
        width: 100%; /* Board container takes full width of main-content */
        /* Removed max-width here - JS will control it */
        /* max-width: 350px; */
        margin: 8px 0; /* Keep vertical margins */
        flex: 1 1 auto; /* Allow board container to grow/shrink within main-content */
        min-height: 0; /* Allow flex item to shrink below content size */
    }

    .board {
      display: grid;
      grid-template-rows: repeat(6, 1fr);
      grid-gap: 4px;
      width: 100%; /* Board takes full width of its container */
      /* The height will be determined by width due to tile aspect ratio */
    }

    .row {
        display: grid;
        grid-template-columns: repeat(5, 1fr);
        grid-gap: 4px;
    }

    .tile {
      width: 100%;
      aspect-ratio: 1 / 1;
      border: 2px solid var(--tile-border-empty);
      font-size: clamp(1.5rem, 6vw, 2rem);
      font-weight: bold;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      text-transform: lowercase;
      color: var(--tile-text-light);
      background-color: var(--bg-color);
      transition: background-color 0.3s, border-color 0.3s;
    }
    .tile > div {
        display: flex;
        align-items: center;
        justify-content: center;
        width: 100%;
        height: 100%;
        color: inherit;
    }
    .tile.filled {
        border-color: var(--tile-border-filled);
    }
    .tile.correct { background-color: var(--correct-bg); color: var(--tile-text-dark); border-color: var(--correct-bg); }
    .tile.present { background-color: var(--present-bg); color: var(--tile-text-dark); border-color: var(--present-bg); }
    .tile.absent { background-color: var(--absent-bg); color: var(--tile-text-dark); border-color: var(--absent-bg); }

    #keyboard {
      flex-shrink: 0; /* Prevent keyboard from shrinking */
      width: 100%;
      max-width: 550px; /* Align keyboard with main content */
      margin-left: auto;
      margin-right: auto;
      display: flex;
      flex-direction: column;
      gap: 4px;
      padding: 0 3px;
      margin-top: 5px;
      margin-bottom: 20px; /* Changed bottom margin to 20px */
      align-self: center; /* Center keyboard horizontally */
    }

    #keyboard-top-row {
        display: grid;
        /* Make Enter and Delete columns equal size */
        grid-template-columns: 1fr 1fr;
        gap: 3px;
    }

    #keyboard-main-grid {
        display: grid;
        /* Default to Alphabetical grid columns, overridden by data attribute */
        grid-template-columns: repeat(8, 1fr);
        gap: 3px;
    }

    /* Specific grid columns for Phonetic layout main grid */
    body[data-keyboard-layout="phonetic"] #keyboard-main-grid {
         grid-template-columns: repeat(10, 1fr); /* Phonetic layout rows have 10 slots */
         gap: 3px; /* Maintain consistent gap */
    }

     /* Placeholder key styling - visible only in layouts that need it for alignment */
     .key.placeholder {
        background: transparent;
        pointer-events: none;
        border-color: transparent;
        visibility: hidden; /* Hidden by default */
     }

    body[data-keyboard-layout="phonetic"] #keyboard-main-grid .key.placeholder {
        visibility: visible; /* Make placeholder visible in phonetic layout */
        background: rgba(0,0,0,0.03); /* Subtle background */
     }


    .key {
      min-height: 40px;
      /* Adjusted font-size clamp to allow single letters to be larger */
      font-size: clamp(1.2rem, 5vw, 1.8rem);
      font-weight: bold;
      border: 3px solid transparent;
      border-radius: 4px;
      background-color: var(--key-bg);
      color: var(--key-text);
      cursor: pointer;
      transition: background-color 0.2s, color 0.2s, border-color 0.2s;
      display: flex;
      justify-content: center;
      align-items: center;
      user-select: none;
      touch-action: manipulation;
      text-transform: lowercase;
      padding: 0;
      min-width: 0;
    }
    .key:hover {
        filter: brightness(90%);
    }

    .key.enter,
    .key.delete {
      /* Increased font size for Enter/Delete keys */
      font-size: clamp(0.9rem, 3.5vw, 1.2rem); /* Adjusted clamp values */
      color: white;
      border-width: 3px;
      border-style: solid;
    }
    .key.enter {
        background-color: var(--enter-key-bg);
        border-color: var(--enter-key-bg);
        white-space: nowrap;
    }
    .key.delete {
         background-color: var(--delete-key-bg);
         border-color: var(--delete-key-bg);
         white-space: nowrap;
    }


    .key.correct {
      background-color: var(--correct-bg);
      color: var(--tile-text-dark);
      border-color: transparent;
    }
    .key.present {
      background-color: var(--present-bg);
      color: var(--tile-text-dark);
      border-color: transparent;
    }
    .key.absent {
      background-color: var(--absent-bg);
      color: var(--tile-text-dark);
      border-color: transparent;
    }

    .key.correct.has-present {
        border-width: 3px;
        border-style: solid;
        /* Using a different color for visibility, you might adjust this */
        border-color: #ffff00; /* Example: Yellow border */
    }


    .message-container {
        position: fixed;
        top: 70px; /* Adjust if necessary */
        left: 50%;
        transform: translateX(-50%);
        min-height: 30px;
        z-index: 1000; /* Above popup overlay */
        width: 90%;
        max-width: 350px;
    }
    .message {
      text-align: center;
      font-size: 1em;
      margin-top: 0.5rem;
      padding: 8px 10px;
      font-weight: bold;
      background-color: #333;
      color: white;
      border-radius: 5px;
      visibility: hidden;
      opacity: 0;
      transition: visibility 0s 1.5s, opacity 1.5s linear;
      white-space: normal;
      word-wrap: break-word;
    }
     .message.show {
        visibility: visible;
        opacity: 1;
        transition: opacity 0.3s linear;
     }

    .dark {
        --bg-color: #121213;
        --text-color: #fff;
        --tile-border-empty: #3a3a3c;
        --tile-border-filled: #565758;
        --key-bg: #818384;
        --key-text: #dadce0;
        --tile-text-light: #fff;
        --link-color: #64b5f6;
        --popup-bg: #2c2c2e;
        --popup-text: #eaeaeb;
        --popup-border: #444;
        --popup-overlay-bg: rgba(0, 0, 0, 0.7);
        --popup-close-color: #aaa;
        --popup-link-hover-bg: #3a3a3c;
    }

    .dark .message {
      background-color: #eee;
      color: #121213;
    }
     .dark .key:hover {
         filter: brightness(115%);
     }
     .dark .key.enter:hover, .dark .key.delete:hover {
          filter: brightness(110%);
     }
      .dark .key.correct.has-present:hover {
         filter: brightness(110%);
     }

    .dark .key.correct { background-color: var(--correct-bg); color: var(--tile-text-dark); border-color: transparent;}
    .dark .key.present { background-color: var(--present-bg); color: var(--tile-text-dark); border-color: transparent;}
    .dark .key.absent { background-color: var(--absent-bg); color: var(--tile-text-dark); border-color: transparent;}

    .dark .key.correct.has-present {
        border-color: var(--present-bg); /* Yellow border */
    }


    /* Theme and Layout Button Positioning */
    /* Position these absolutely within the main-content area */
    .main-content > #toggle-theme {
      position: absolute;
      top: 10px; /* Adjusted position slightly */
      right: 10px; /* Position Theme button on the right */
      margin-bottom: 0; /* Remove margin as position is absolute */
      padding: 6px 10px;
      font-size: 0.9rem;
      border-radius: 5px;
      cursor: pointer;
      border: 1px solid #ccc;
      background-color: #eee;
      color: #333;
      z-index: 20;
    }
    .dark .main-content > #toggle-theme {
        background-color: #333;
        color: white;
        border-color: #555;
    }

    .main-content > #toggle-layout {
      position: absolute;
      top: 10px; /* Adjusted position slightly */
      left: 10px; /* Position Layout button on the left */
      margin-bottom: 0; /* Remove margin as position is absolute */
      padding: 6px 7px;
      font-size: 0.9rem;
      border-radius: 5px;
      cursor: pointer;
      border: 1px solid #ccc;
      background-color: #eee;
      color: #333;
      z-index: 20;
       min-width: 80px; /* Added min-width to prevent text wrap */
       text-align: center; /* Center text in button */
    }
     .dark .main-content > #toggle-layout {
        background-color: #333;
        color: white;
        border-color: #555;
    }

    /* --- Popup Styles --- */
    .popup-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: var(--popup-overlay-bg);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 900; /* Below message container */
        padding: 15px; /* Padding around content */
    }
    .popup-content {
        background-color: var(--popup-bg);
        color: var(--popup-text);
        padding: 20px;
        border-radius: 8px;
        border: 1px solid var(--popup-border);
        max-width: 90%;
        width: 400px; /* Max width for the popup */
        max-height: 80vh; /* Limit height */
        overflow-y: auto; /* Allow scrolling for list */
        position: relative;
        box-shadow: 0 4px 15px rgba(0,0,0,0.2);
    }
    .popup-content h2 {
        margin-top: 0;
        margin-bottom: 15px;
        text-align: center;
        font-size: 1.3rem;
    }
    .popup-close {
        position: absolute;
        top: 10px;
        right: 15px;
        font-size: 1.8rem;
        font-weight: bold;
        color: var(--popup-close-color);
        cursor: pointer;
        line-height: 1;
    }
    .popup-close:hover {
        color: var(--text-color); /* Use main text color on hover */
    }
    #past-games-list {
        list-style: none;
        padding: 0;
        margin: 0;
    }
    #past-games-list li a {
        display: block;
        padding: 8px 12px;
        margin-bottom: 5px;
        background-color: transparent;
        color: var(--link-color);
        text-decoration: none;
        border-radius: 4px;
        transition: background-color 0.2s;
        font-size: 0.95rem;
    }
     .dark #past-games-list li a {
        color: var(--link-color); /* Ensure link color is visible */
     }
    #past-games-list li a:hover {
        background-color: var(--popup-link-hover-bg);
        text-decoration: underline;
    }

    @keyframes shake {
      0%, 100% { transform: translateX(0); }
      10%, 30%, 50%, 70%, 90% { transform: translateX(-5px); }
      20%, 40%, 60%, 80% { transform: translateX(5px); }
    }
    .shake { animation: shake 0.6s ease-in-out; }


    /* Media Query for very small/short screens */
    @media (max-width: 340px), (max-height: 600px) {
        .header-container {
            margin-top: 8px;
        }
        h1 {
            font-size: 1.3rem; /* Further reduce */
        }
        #game-number-display {
            font-size: 0.8rem;
        }
        .subtitle {
            margin-bottom: 3px;
        }
         .main-content {
            padding-bottom: 5px; /* Reduce bottom padding for very short screens */
         }
        .board-container {
            margin: 5px 0;
            /* max-width controlled by JS */
        }
        .board, .row {
            grid-gap: 3px; /* Further reduce */
        }
        #keyboard {
            gap: 3px;
            padding: 0 2px;
            margin-top: 3px;
            margin-bottom: 15px; /* Adjusted bottom margin for small screens */
        }
        /* Adjust gaps/columns for smaller screens if needed, though JS might handle size */
         #keyboard-main-grid, #keyboard-top-row {
            gap: 2px; /* Further reduce default gap */
        }
        body[data-keyboard-layout="phonetic"] #keyboard-main-grid {
             grid-template-columns: repeat(10, 1fr); /* Maintain 10 columns */
             gap: 2px; /* Use the smaller gap */
        }


        .key {
            min-height: 36px; /* Further reduce */
            /* Adjusted font size for small screens */
            font-size: clamp(1rem, 3.5vw, 1.3rem); /* Adjusted clamp values */
        }
        .key.enter, .key.delete {
             /* Increased font size for Enter/Delete on small screens */
            font-size: clamp(0.8rem, 3vw, 1.1rem); /* Adjusted clamp values */
        }
        /* Adjust button positions relative to main-content padding/width */
        .main-content > #toggle-theme {
            padding: 4px 7px;
            font-size: 0.8rem;
            top: 2px; /* Adjust based on header changes */
            right: 5px; /* Maintain right position */
        }
        .main-content > #toggle-layout {
            padding: 4px 7px;
            font-size: 0.8rem;
            top: 2px; /* Adjust based on header changes */
            left: 5px; /* Adjust position to the left */
             min-width: 70px; /* Adjust min-width */
        }
        .message-container {
            top: 60px; /* Adjust if needed */
        }
        .popup-content {
            width: 95%; /* Allow popup to use more width */
            padding: 15px;
        }
         .popup-content h2 {
            font-size: 1.2rem;
         }
         #past-games-list li a {
             font-size: 0.9rem;
             padding: 6px 10px;
         }
    }

        /* --- Horizontal Orientation Fix for Mobile (Revised for svh and Board Sizing) --- */
    @media (orientation: landscape) and (max-height: 600px) {
        html { /* Apply svh to html element first */
             height: 100svh; /* Small viewport height - accounts for visible browser UI */
             max-height: 100svh;
             overflow: hidden;
        }
        body {
            height: 100%; /* Takes 100% of html's 100svh */
            max-height: 100%;
            overflow: hidden; /* Prevent overall page scrolling */
            display: flex;
            flex-direction: row;    /* .main-content (left) | #keyboard (right) */
            align-items: stretch;   /* Make columns take full available height of body's content box */
            justify-content: center;/* Center columns if they together are narrower than viewport */
            padding: 3px;           /* Small body padding (3px top/bottom, 3px left/right) */
            gap: 8px;               /* Space between left and right columns */
            box-sizing: border-box; /* Body's padding is INCLUDED in its height/width */
        }

        /* Left Column: Header + Board Area */
        .main-content {
            flex: 1 1 45%;          /* Adjust basis/ratio as needed, aim for board area */
            max-width: 380px;       /* Cap width to prevent board becoming excessively wide */
            height: 100%;           /* Stretches to body's content-box height */
            display: flex;
            flex-direction: column; /* Stack header then board-container vertically */
            align-items: center;    /* Center children horizontally */
            justify-content: flex-start; /* Align children (header, board) to the top of this column */
            padding: 0;
            margin: 0;
            overflow: hidden;       /* No scroll for this entire column */
            box-sizing: border-box;
        }

        .main-content > .header-container {
            flex-shrink: 0;
            width: 100%;
            margin-top: 0;
            margin-bottom: clamp(1px, 0.1svh, 1px); /* Minimal bottom margin, svh based */
        }
        .main-content > .header-container h1 {
            font-size: clamp(1rem, 2.8svh, 1.3rem); /* Responsive title with svh */
            margin: 0;
        }
        .main-content > .header-container #game-number-display {
            font-size: clamp(0.7rem, 2svh, 0.9rem); /* svh based */
        }

        .main-content > .subtitle {
            flex-shrink: 0;
            width: 100%;
            font-size: clamp(0.65rem, 1.8svh, 0.8rem); /* svh based */
            margin-top: 0;
            margin-bottom: clamp(1px, 0.2svh, 2px); /* Minimal, svh based */
        }
        
        .main-content > #toggle-theme {
            top: clamp(2px, 0.5svh, 4px); 
            right: clamp(2px, 0.5svh, 4px);
            padding: clamp(2px, 0.6svh, 4px) clamp(3px, 0.8svh, 6px); 
            font-size: clamp(0.7rem, 1.8svh, 0.9rem); /* svh based */
        }
        .main-content > #toggle-layout {
            top: clamp(2px, 0.5svh, 4px); 
            left: clamp(2px, 0.5svh, 4px);
            padding: clamp(2px, 0.6svh, 4px) clamp(3px, 0.8svh, 6px);
            font-size: clamp(0.7rem, 1.8svh, 0.9rem); /* svh based */
        }

        .board-container {
            flex-grow: 1;           /* Take remaining vertical space in .main-content */
            width: 100%;
            max-width: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: clamp(1px, 0.2svh, 2px) 0 0 0; /* Minimal top margin, svh based */
            min-height: 0;          /* Crucial for flex-grow to allow shrinking */
            overflow: hidden;       /* No scrollbars within board-container */
        }

        .board {
            display: grid;
            grid-template-rows: repeat(6, 1fr);
            grid-gap: clamp(2px, 0.4svh, 3px);  /* Responsive gap based on svh */
            height: 100%; /* Fill the allocated height from .board-container */
            width: auto;  /* Width will be determined by height and aspect-ratio */
            aspect-ratio: 5 / 6.1; /* Adjust if tiles aren't perfectly square after svh fix */
            max-width: 100%;
        }
        
        .tile {
            width: 100%;
            aspect-ratio: 1 / 1;
            border-width: 1px;
            font-size: clamp(0.8rem, 2.8svh, 1.6rem); /* Responsive font relative to svh */
            display: flex; align-items: center; justify-content: center;
        }
        .tile > div { 
            line-height: 1;
        }

        /* Right Column: Keyboard */
        #keyboard {
            flex: 1 1 50%;
            max-width: 480px;
            height: auto;
            align-self: center;
            display: flex;
            flex-direction: column;
            justify-content: center;
            padding: 0 2px;
            margin: 0;
            gap: clamp(2px, 0.4svh, 3px); /* svh based */
            box-sizing: border-box;
        }
        
        .key {
            min-height: clamp(28px, 4.8svh, 38px); /* Keys scale with svh */
            font-size: clamp(0.7rem, 2.3svh, 1.2rem); /* svh based */
            border-radius: 3px;
        }
        .key.enter, .key.delete {
             font-size: clamp(0.6rem, 1.9svh, 1rem); /* svh based */
        }

        .message-container {
            top: 3px;
            left: 50%;
            transform: translateX(-50%);
            width: auto; 
            min-width: 140px;
            max-width: 280px;
            padding: 3px 5px;
            z-index: 1000;
        }
        .message {
            font-size: clamp(0.7rem, 1.7svh, 0.9rem); /* svh based */
            padding: clamp(4px, 0.8svh, 6px) clamp(6px, 1svh, 8px); /* svh based */
            margin-top: 0;
        }
    }

  </style>
</head>
<body>
  <div class="main-content">
      <!-- Header Container -->
      <div class="header-container">
         <h1>Wordle <img src="flag.png" alt="üá¶üá≤" style="height: 0.7em; vertical-align: middle;"></h1>
         <!-- Game Number Display -->
         <span id="game-number-display">‘Ω’°’≤ #...</span>
      </div>
      <!-- Subtitle -->
      <p class="subtitle">by <a href="https://www.armblog.net" target="_blank">Armen Mkrtchyan</a></p>

      <!-- Controls -->
      <button id="toggle-theme">üåó</button>
      <button id="toggle-layout"></button>

      <!-- Message Container -->
      <div class="message-container">
         <div id="message" class="message"></div>
      </div>

      <!-- Board -->
      <div class="board-container">
         <div class="board" id="board"></div>
      </div>
  </div>

  <!-- Keyboard -->
  <div id="keyboard">
      <div id="keyboard-top-row"></div>
      <div id="keyboard-main-grid"></div>
  </div>

  <!-- Past Games Popup -->
  <div id="past-games-popup" class="popup-overlay" style="display: none;">
    <div class="popup-content">
      <span class="popup-close" id="popup-close-button">√ó</span>
      <h2>’Ü’°’≠’∏÷Ä’§ ’≠’°’≤’•÷Ä’®</h2>
      <ul id="past-games-list">
        <!-- Dynamically populated -->
        <li><a href="#">‘Ω’°’≤ #1 - 2025-05-02</a></li>
        <li><a href="#">‘Ω’°’≤ #2 - 2025-05-03</a></li>
      </ul>
    </div>
  </div>


<script>
  const boardElement = document.getElementById('board');
  const keyboardTopRowElement = document.getElementById('keyboard-top-row');
  const keyboardMainGridElement = document.getElementById('keyboard-main-grid');
  const keyboardElement = document.getElementById('keyboard');
  const toggleBtnTheme = document.getElementById('toggle-theme');
  const toggleBtnLayout = document.getElementById('toggle-layout');
  const messageElement = document.getElementById('message');
  const mainContent = document.querySelector('.main-content');
  const gameNumberDisplay = document.getElementById('game-number-display'); // New element
  const pastGamesPopup = document.getElementById('past-games-popup'); // New element
  const pastGamesList = document.getElementById('past-games-list'); // New element
  const popupCloseButton = document.getElementById('popup-close-button'); // New element

  // --- Constants ---
  const WORD_LENGTH = 5;
  const MAX_ROWS = 6;
  const ENTER_KEY = '’®’∂’§’∏÷Ç’∂’•’¨';
  const DELETE_KEY = '’ª’∂’ª’•’¨';
  const LOCAL_STORAGE_LAYOUT_KEY = 'armenianWordleLayout';
  const LOCAL_STORAGE_HISTORY_KEY = 'armenianWordleHistory'; // Key for past game metadata
  const START_DATE_STRING = "2025-05-02"; // Keep as string for consistency

  // --- Word List ---
  const WORDS = [['’°’æ’µ’∏÷Ç’∂','’°÷Ä’™’•÷Ñ','’Ø’°÷Ä’°’£','’Ø’°’≤’∂’´','’Æ’°’£’∏÷Ç’¥','’≠’•’¨’∏÷Ñ','’°’∂’£’´÷Ä','’∂’°’¥’∏÷Ç’Ω','’∂’°’¥’°’¶!','’ø’°’∂’´÷Ñ','’§’°’£’°’≤','’Ω’∏÷Ç’¨’∏÷Å','’°’Ø’∏÷Ä’§','’Æ’°’¥’•’¨','’∞’°’¥’°÷Ä!','’Ø’º’∂’°’ø!','’¢’°÷Ä’±÷Ä','’∏’ø’∂’°’Ø','÷Ö’©÷á’°’∂','’©’°’Ø’∏÷Å!','’∑’´’ø’°’Ø!','’Ω’ø’•÷Ä’ª','’≤’°’¶’°’≠!','’æ’•÷Ä’´’∂','’∏÷Ç’∂’•’¨’´','’¶’∂’∂’•’¨','’∞’°’∂’∏÷Ç’¥!','’Ø’°’ø’°÷Ä','’Æ’´’Æ’°’≤','’Æ’°’Æ’∏÷Ç’Ø','’¶’∏’§’∏÷Ç’¥','’£’∏÷Ç’∂’°’ø!','’§÷Ä’°’¥’°!','’∫’∂’§’∏÷Ç’Ø!','’°’∂’ø’•÷Ä!','’Æ’°’æ’°’¨','’∏’¨’∏÷Ä’ø','’¶’£’°’Ω’ø','’ª’∏÷Ç’©’°’Ø','÷Ñ’°÷Ä’°÷É','’∞’∂’∏’ø’´!','’Ø÷Ä’Æ’∏’≤','’ø’°’∑’•’¨','’∫’°÷Ä’°’∫!','’¢’º’∂’°’Ø','’°’æ’¨’•’¨!','’∂’¶’∏’æ÷Ñ','’∞’°’ø’∏÷Ç’¥!','÷Ü’°’£’∏’ø','’Ø’°’©’Ω’°','’Ω’©÷Ä’•’Ω!','’∞’°’ø’∏÷Ä','’∑’º’°’µ’¨!','’¢’°÷Å’´’¨','÷Ñ’Æ’∂’∏’≤','’¥’°’ø’°’≤','’Æ’°’¥’∏’∂','’∂’∫’°’Ω’ø','’≥’°’∞’´’≥','’Ø’•’∂’°÷Å','’Ω’°’¥’¢’°!','’Ω’ø’æ’•÷Ä','÷Ñ’´’¥’´’°','÷Ñ’∂’∂’•’¨','’∂’∏÷Ä’•’Ø!','’Ø’°’©’∏’§!','’∑÷É’æ’•’¨!','’Ω’°’Ω’°’∂!','’∑’∂’∏÷Ä’∞','’ª’∂’ª’•’¨','’∂’•÷Ä’Ø’°!','’Ø’¥’°’≠÷Ñ','÷É÷Ä’Ø’•’¨','’Ω’°’∫’°’ø','’°’∂’¥’°’∞!','’∞’•’Æ’°’∂!','’π÷É’¨’°’≠!','’°’£’º’°’æ','’°÷Ä’µ’∏÷Ç’∂','’≠’∏’∑’∏÷Ä','÷É’°÷É’∏÷Ç’Ø','’≠’∏÷Ç’≥’°’∫','’Ø÷Ä’∫’°’Ø','’°’∂÷Å’∏÷Ç’¥','’Ø’°’©’´’¨','’°’∫÷Ä’•’¨','’ø’æ’µ’°’¨','’ø’°÷Ä’°’¶','÷Ñ’°’∂’°’Ø','’¨’°’Ø’∏’ø!','’™’≠’ø’•’¨','’¥’∏’≠’´÷Ä','’π’°’¥’´’π','÷Ö’¥’•’£’°','’¢’Ø’¨’´’Ø!','’ø’∏’∂’•’¨','’∂’´’∞’°÷Ä','’Ø’°’≠’•’¨','’∂’•’≤’∏÷Ç÷Å','’∏’Ω’Ø’µ’°!','’ø’•’Ω’∏÷Ç’π','’¥’´’ª’°’ø','’¥’∏÷Ç’¥’´’°!','’°÷Ñ’Ω’∏÷Ä','’°÷Ä’§’∏÷Ç’Ø','’§’°’ª’•’¨!','’£’∏’¥’•’∑','’≥’¶’¥’•’¨','’Æ’∂’Æ’≤’°','÷Ü’´’¨’ø÷Ä','’Ω’°’º’°’Æ!','’≠÷Ä’©’´’∂','’•’¨÷á’ß’ª','’°÷Ä’Ø’°’Æ','’¢’•’≤’¨’∏÷Ç!','’¢÷Ä’§’•’¨!','’∂’•÷Ä’•’¨','÷Ñ÷Ä÷Ñ’´’ª','’¨’°÷Å’•’¨','’Ø’∏’π’∏÷Ç’¥','’Æ’∂’æ’•’¨','’Æ’°÷Ä’´÷Ä','’£’∏’∞’°÷Ä!','’≠’∂’°’¥’´','’∂’°’≠’´÷Ä','’∂’∂’ª’•’¨','’∞÷Ä’∑’•’ª','’•÷Ä’£’´’π','’Ω’∫’∏÷Ä’ø','’Æ’•’Æ’•’¨','’∏÷Ç’º’•’∂’´','’¶’∏÷Ä’•’≤!','’¥’∏÷Ä’©’´!','’æ’≥’º’•’¨','’Ø’ø÷Ä’•’¨','’∞’°÷Ä’°’æ','’Æ’∏÷Ä’°’Ø','’¥’°÷Ñ’∏÷Ç÷Ä','’°÷Ä’ª’∏÷Ç’Ø!','’ø’°’ª’´’Ø','’Ω’∏÷Ç’ø’°’Ø','÷É÷Ä’Ø’´’π','’≥’Ø’∏÷Ç’µ’©','’ß’Ø÷Ä’°’∂','’§’´’¥’∏÷Ç’¥','’Æ’∏÷Ç’≤’°’Ø','’©’¥’¢’∏÷Ç’Ø','’°÷Ä’£’∏’∂!','’Ω’Ø’´’¶’¢','’Ø’•’Ω÷Ö÷Ä','’°’Ω’∏÷Ç’µ’©','’¨÷Ñ’æ’°’Æ!','’£’°’¶’°÷Ä','’¶’∂’∂’∏’≤!','’Ω’´÷Ä’∏’≤!','’∫’°’Ω’´’æ!','’¶’≤’ª’∏÷Ç’¥','÷É’°÷Ä’∏’Ω','’π’≤’ª’´’Ø','’©’º’π’∏÷Ç’∂','’ø’°÷Ä’°÷É','’¢’∏÷Ä’∏’ø!','’∞’∂’°÷Ä÷Ñ','’∑’°÷Ñ’°÷Ä','’∑’°’≤’°÷É','’Ø’°÷Ä’´’≥','’¥’∏’ø’´’Ø!','’≠’°’∂’∏÷Ç’©','’Ω’´’¢’•’≠!','’∂’Ω’ø’•’¨','’∫’≤’ø’∏÷Ä!','’¢’°’∂’∏÷Ç’Ø','’π÷Ñ’∂’°’≤!','’°’Ø’∏÷Ç’∂÷Ñ','’∞’°’Ω÷Å’•','’§’∏’∂’∏÷Ä','÷É’∑÷Ä’•’¨','’¥÷Ä÷Å’∏÷Ç’¥!','’°’≤÷Ñ’°’ø','÷Ñ’°’∂’∏’∂','’∂’∏’≠’°’¶!','’¨÷Ä’ø’•’Ω','’∫’°’ø’°’º','’Ω’´÷Ä’°’Æ!','’°’∂’£’•’ø!','’°’≤’∏’©÷Ñ','’¥’Ø’∂’´’Ø!','’Ω’∏’≤’∏÷Ç’∂','’Ø’´’©’°’º!','’Ø’°’µ’Ω÷Ä','’§’´’ø’•’¨','’©’º’π’•’¨','’¥’°’º’°’∂','’Ω’∂’∏’ø’´','’ø’°÷Ä’´÷Ñ','’¥’´’ª’´’∂!','’¥’°’Æ’∏÷Ç’∂','’ø’°÷É’°’Ø','’•÷Ä’•’Ø’∏','’°’≥’µ’∏÷Ç’∂','’ø’•÷Ñ’Ω’ø','’∞÷Ä’©’´’º','’§’°’∂’°’Ø','’¨’æ’°÷Å÷Ñ','’Ø’∏’¥’´’Ø!','’°’∂’¶’•’∂!','’¢’µ’∏÷Ç’ª’•','’ø’∏’Ø’∏÷Ç’∂','’¥’•’§’°’¨!','’Ω’Ø’Ω’•’¨','’¢’º’∂’´’π','’¥’•’ø’°’≤','÷Ö’Ω’¥’°’∂','’¨’°’∫’∑’°','’¥’´’ø’∏÷Ç’¥','’¢’°÷Ä’°’Ø','’°÷Ä’Æ’´’æ','÷É’°’µ’ø’•','’Ø’∫’π’•’¨','’∞’∫’°÷Ä’ø','’¢’°’™’´’∂','’π’¥’∏÷Ç’∑’Ø','’§’°’µ’°’Ø','’°’¥’°’µ’´!','’¢’∏’™’∏’™','’≠’∂’§’´÷Ä','’Ø’´’ø’•’¨!','’Ø’∏’ø’•’¥!','’®’¥’¢’´’∑','’∞’∂’°’∏’≥','’∂’º’∂’°’Ø','÷Ä’°’¢’¢’´','’°’ø’µ’°’∂','’∑’°’æ’´’≤','’°’≤’æ’•’Ω','’©’¥’¢’´÷Ä','’•’º’°’∂’§','’∞’°’¨’∏÷Å!','’¥÷Ä’Ω’•’¨','’π’´’∂’°÷Ä!','’≠’∂’°’¥÷Ñ','’∏’Ω’ø’°’∂!','’©÷Ä’©’∏÷Ç÷Ä','’°’º’æ’°’Ø!','’±’°’æ’°÷Ä','’∫’∏’π’°’ø!','’¨’∏’≤’°’Ø','’®’∂’ø’´÷Ä','’•÷Ä’Ø’°÷Ä!','’°’µ’Ω÷Ö÷Ä','’∑÷Ä’ª’•’¨','’°’∂’∏’∂’Ω!','’£÷Ä’∫’°’∂','’æ’´’∫’°’Ø','’∫’°’∞’•’¨','’™’∏’≤’∏’æ','’Ø’°’∫’´’π!','’∂’™’∏÷Ç’µ’£','’¢’∂’°’¶’§','’π’•’¶’∏÷Ñ','’Ø’¨’´’¥’°','’§’™’£’∏’∞','’Ω’∂’∏÷Ç’∂’§','’°’Æ’°’∂÷Å!','’Ø’°’∫’°÷Ä','’∞’°’Ω’°’Æ!','’•’¨’∏÷Ç’µ’©','÷Ü’•÷Ä’¥’°','÷É’∏÷Ä’•’¨','’Ø’´’Ω’°’ø!','’£’∂’§’°’Ø','’•’¶’•÷Ä÷Ñ!','’§’•’≤’´’∂','’Ω÷Ä’¢’°’∂','’°’¥’¢’∏’≠','’•÷Ä’°’∂’£','’≠’°’∑’•’¨!','’©÷Ä’¥’•’¨!','’¢’∑’ø’´’Ø','’°÷Ä’Æ’°’©','’©’∑’∑’°’¨!','’°’¢’•’≤’°','’°’∫÷Ä’´’¨','’Ω’´÷Ä’∏÷Ç’∂','’∞’°’Ω’°’Ø','’¨÷Ä’°’ø’∏÷Ç','÷Ö÷Ä÷Ä’°’∂','’ø’´’Ø’´’∂','’≥’´÷Ä’°’∂','’Ø’∏’∫’´’ø','÷Ñ’∏÷Ç’º’°’Ø','’•÷Ä’Ø’°’©','÷Ñ’°’∑’•’¨','’°’∂’∞’°’¥!','’¥’°’¨’∏÷Ç’≠','’°’∂’¢’´’Æ!','’¥÷Ä÷Å’•’¨!','’¢’•÷Ä÷Ä’´','’°’∫’ø’°’Ø','’Ø’•’º’°’Ω','÷Å’∏’≤’∏÷Ç’∂','’∞’°’ø’∏÷Ç’Ø!','’¨’∏÷Ä’ø’∏÷Ç!','÷Å’∂’∏÷Ä÷Ñ','’°’º’∂’•’ø','÷Å’°’æ’∏’ø','’°’¥÷Ä’∏÷Å','’°÷Ä’≥’´’≥','’´’∂’•÷Ä’ø!','’Ø’°÷Å’´’∂','’Ω’∏’≤’°’¨','’∞’°’¥’•’≤','’∫’≤’∫’•’≤','’Ø’∏’∑’´’Ø','’°’∂’§’•’¥!','’ø’°’Ø’°’º','’≥’∂’∑’∏÷Ç’¥','’¨’∏’≤’°’¨','’Ø÷Ä’Ø’•’Ω','’£’∂’§’´’Ø!','’∞’µ’∏÷Ç’Ω’∂','’∂’°’≠’∂’´','’∑’•÷É’∏÷Ä','’•÷Ä’•’≠’°','÷É’°’©’´’¨','’¥’•’ø÷Ä’∏','’∑’∏÷Ç’∑’°’∂','’∫’≤’´’∂’±','’æ’´’Ω’Ø’´','’∞’Ω’ø’°’Ø','’°÷Ü’≤’°’∂!','’∫’°÷Ä’£÷á','’Ø’´’Ω’•’¨','’∫’°’£’•’¨!','’•’≤’•’£’∂','÷É’≠÷Ä’∏÷Ç’∂','’ø’°÷Ä’•÷Å','’π’∏’¢’°’∂!','÷Ñ’•÷Ä’•’¨','’∑÷Ä’ª’°’∂','’æ’•’¶’´÷Ä','’Ø÷Ä’∏÷Ç’∂’Ø','’≥’°’Ø’°’ø','’∫’°÷Ä’°’∂','’§’°’∞’´’≥','’¢’°÷Å’°’ø','’°’Ø’∏÷Ç’¥’¢','’∞’∏’æ’°’¶','’°’Ω’∏÷Ä’´!','’¢’´’¢’°÷Ä!','’©’°÷É’•’¨!','’∂’∏’ø’°÷Ä!','’§’∏’£’¥’°!','’°÷Ä÷á’∏’ø!','’°’¨’µ’∏÷Ç÷Ä','’¢’°’¶’∏÷Ç’Ø','’ø’°’∑’•’≤','’ø’•’Ω’´’¨','’Ø’ø÷Ä’∏÷Ç’Ø!','’∏’≤’∏÷Ä’Ø','’•’≤’•’º’∂!','’¨’∏÷Ç’Æ’∏÷Ç’¥','’¢’°’∂’°’Ø','’°’¥’¢’°÷Ä','’Ω’°’∂’´’Ø!','’º’•’ø’´’∂','’∫’∂’§’•’¨','’¥’•’§’´’°!','’Æ’´÷Ä’°’∂','’Ø’µ’°’∂÷Ñ','’¢’∏’¢’´’Ø!','’∂’•’≠’•’¨','’∞’∏÷Ç’™’Ø’∏÷Ç!','’∞’∏’£’∏÷Å!','’°÷Ä’∑’°’æ','’£’•’ø’°’Ø!','’§’™’æ’°÷Ä','’∂’æ’°’Ω’ø!','’∫’•’∫’•’∂!','’¢’•’Ø’∏÷Ä','’∞’´’¥’°÷Ä','’¨’∏÷Ç÷Å’Ø’´','’©’∏’∂’´÷Ä','’¥’∏’§’•’¥!','’≠’≤’≥’°’¨','’°’≤’¥’∏÷Ç’Ø','’ø’°’æ’°÷Ä','’Ø’°’∏÷Ç÷Ä’´!','’ø’∂’ª÷Ä’´','’Ω’ø’•’≤’∂','’£’•’ø’´’∂','’Ω’°’æ’°’∂','’°’ø’¨’°’Ω!','’±’£’ø’•’¨','’∞’°’¶’°’¨!','’≠’´’¶’°’≠','÷É÷Ä÷É’∏÷Ç÷Ä','’¥’ø’∂’•’¨!','’ª’∏’Ø’°’ø','’¶÷Ä’∏÷Ç’µ÷Å','’≠÷Ä’∏’≠’ø!','÷Ñ’°’¥’•’¨','’¢÷Ä’§’µ’°!','’°’≤’°’∂’±','’¥’´’ª’∏÷Ç’Ø','’°÷Ä’¥’°’ø','’°’Ø’∂’∏÷Å','’Ø’•÷Ü’´÷Ä!','’¥’´’∂’π÷á!','’¥’°÷Ä’•’¨!','’∞’∏÷Ç’∑’∏÷Ç’¥','’≠’°’≤’°’¨','’π’°÷É’•’¨','’¢÷Ä’§’∏’ø!','’≠’≠’∏÷Ç’∂’ª','’Ø’∂’∏÷Ç’∂÷Ñ','’Ø’°’∑’æ’•!','’¥’´’ª’∏÷Å','’∂’•÷Ä’∏÷Ç’™','’Ø’°’∂’°’π','’°÷Ä’±’°’∂','÷Ö÷Ä’£’°’∂','’°’≤’µ’∏÷Ç’Ω','’Ø’°÷Ä’°’ø!','’§’°’™’°’∂','’£’¶÷Ä’∏÷Å!','÷É’∏÷Ç’π’´’Ø','’Ω’∏’æ’°’Æ','’Æ’´’Æ’°’Ø','÷É’°’Ø’°’∂','’¥’°’ø’´’ø','’©’•÷É’∏÷Ç’Ø','’©’´’©’•’º','’£’∏÷Ç’¥’°÷Ä','’•÷Ä÷á’°’Ø!','’¥’•’©’∏’§','÷Ñ’Æ’∂’•’¨','’ø’°’æ’´’≤','’Æ’∏’æ’°÷É','’¢’°÷Ä’§’´','’´’¥’°’Ω’ø','÷É’Ω’≠’•’¨','’°’∫’°’£’°','’∞’∏’æ’´’æ','’º’∏÷Ç’¢’¨’´!','’≠’°’æ’´’Æ','’∫’°÷Ä’ø÷Ñ','’∏’∞’¥’°’Ø','’§’°’Ø’´’π!','’±’°’£’°÷Ä','’π’°÷Ä’´÷Ñ','’Ø’∂’≥’´’©','’¥’°’Ω’∏’∂!','’±’£’æ’•’¨!','’∞’°’¥’∏’æ!','’π’∂’π’´’∂!','’æ’°’∞’°’∂','’∏’π’´’∂’π!','’¥’°÷Ü’´’°!','’æ’¶’∂’∏÷Å','’Ω÷Ä’≥’•’¨','’Ω’∏’≠’∏÷Ç’Ø','’°’Ø÷Å’´’¶!','’¨’•’¥’∏÷Ç÷Ä!','’¢’°÷Å’•’¨','’ª÷Ä’∞’∏’Ω','’∫’∂’§’∏÷Ç’¥!','’¢’°÷Å’∏÷Ç’¥','’©’º’´’π÷Ñ','’º’°’¢’´’¶!','’Ø’Ω’Ø’´’Æ','’§’°÷É’∂’´','’¢’´÷Ä’™’°!','’¢’´’¶’∏’∂','÷Å’∏÷Ç÷Å’°’Ø','’°÷Ä’§’°÷Ä','’¥’°’£’´’¨','’∂’µ’°÷Ä’§','’∏’º’∂’°’¨!','’∞’•’ø’´’∂!','’§÷Ä’∏’∑’¥','’Ω’¥’¢’∏÷Ç’Ø!','’¥’•’º’°’Æ!','’¥’∏’¨’∏÷Ä!','’≠’º’∫’∏’ø!','’§’≤’µ’°’Ø','’°’Ø’°’∂’ª','’∞’°’¥’•’¥','’•÷Ä’§’∏÷Ç’¥','’≥’∏÷Ç’º’°’Ø','’º’•’£’¢’´!','’¥’°’¥’∏÷Ç’¨','’Ω’∫’´÷Ä’ø','’©’°÷Ä’°’≠','’Ø’º’º’°’¨!','’§÷Ä’°’≠’ø','÷É’°’Ø’•’¨','’≠’¥’¢’°’Ø','’¥’°’¶’∏’ø!','’∫’ø’∏÷Ç’µ’ø','’°’∂’Ø’∏÷Ç’¥','’Ø’∏’≥’°’Ø','’¥’°’∂’∏÷Ç’Ø','’°’∂’¢’°’∂!','’∞’°’≥’°÷Ä!','’•÷Ä’§’´’Ø','’∏’π’≠’°÷Ä','’Ø’°’µ’∏÷Ç’∂!','’∞’°’ø’°’Ø','’¨÷Ñ’µ’°’¨!','’∞’¥’°’µ÷Ñ','’¥’°’∂÷Ä’ß','’¢’∏’≤’∏÷Ñ','’¢’¥’¢’∏÷Ç’¨!','’Ø’∑’•’º÷Ñ','’ø’∏’∂’∂’°','’Ø’∏’°’¨’°','’¨’∏’¨’´’Ø','’°’∂’∞’∏’£!','’Ø’°’µ’°’∂','’æ’°’º’∏’§','’°’∂’∏÷Ç÷Ä’ª','’∏÷Ä’Ω’°’¨','’Ø’°’¥’°÷Ä','’•÷Ä’´’∂’ª','’©’¶’•’∂’´','’©’°’©’°÷Ä!','’¨’∏’¢’¢’´!','’§’°’§’°÷Ä','’∂’•’≠’∏÷Ç÷Ä','’£’°’£’°’©','’∫’°÷Ä’•’¨','’æ’°÷Ä’°’Ø','’§’´’•’ø’°!','’Ω÷Ä’≥’•÷É','’°’º’µ’∏÷Ç’Æ','’≥’∏’∫’°’∂','’©’°’º’°÷É!','’Ω’Ø’µ’∏÷Ç’º','’Ø’°’¥’°÷Å!','’Ω’•÷Ä’´’°!','’æ’°÷Ä’•’¨','’ª’´’∞’°’§!','’∫’°÷Ä’•’Ø','’≥’°’≤’°’ø','’°÷Ä’±’°’Ø','’≠’≤’≥’∏÷Ç’Ø','÷Ñ’∂’∂’´’π','’≠’∏÷Ç’≥’∏÷Ç’≥','’≠÷Ä’≥’´’©','’¨’µ’°÷Ä’§','’π’•’π’•’∂','’§’°’∞’∏÷Ç’Ø','’Ω’´’Ω’•’º!','’Ø’º’æ’•’¨!','÷Ö’©’µ’°’Ø','’∂’°÷Ä’§’´!','’∞’∂’§’´’Ø','’≥’°’£’°÷Ä','’π’°’¥’°’∂!','÷Å’°’æ’•’¨','’∞’∏’Ω’•’¨','’Ø÷Å’∏÷Ä’§','’æ’°’Ω’°’¨','’∑’°’¢’°’©','’¥’´’°’µ’∂!','’∞’°’¶’°÷Ä','’¶’£’∏÷Ç’µ’∑!','’∫’°’ø’´’™','’°’≤’°’∂’§','’©’∏÷Ç’©’°’Ø','’Ω’°’¥’´’©!','’Ω’°’¥’¢’∏!','’¶’æ’°÷Ä’©','’°’∂’≠’∂’°!','’¢’™’´’∑’Ø','’∞’∏’£’∂’°!','’¢’°÷Å’´’π','’¥’¶’Ø’´’©','÷Ñ’∂÷Ñ’∏÷Ç’∑','’¨’°÷Å’∏’≤!','’®’∂’Ø’•÷Ä','’Ø’°÷Ä’°’∫','’£’°’æ’°’©','’∑’¨’§’´’Ø','’Ø’∏’≤’∏’æ','’∞’º’π’°’Ø','÷Ö’£’∂’•’¨','÷Ö÷Ñ’Ω’´’§','’¨’°’¶’•÷Ä!','’∞’°’∑’´’æ','’Ø’°÷Ä’•’¨','’ø’°’∂’£’∏','’§÷Ä’æ’°’£','÷Ü’∏’ø’∏’∂','’°’∂’¥’´’ø!','’ø’∂’ø’•’Ω','’≠’∏÷Å’•’¨','’Æ’∏÷Ä’°’¨!','’°’≥’∏÷Ç÷Ä’§','’°’¶’§’•’¨!','’Ø’≥’≤’°’Ø!','’•÷Ä’£’•’¨','’∞’∏’Ø’•’µ!','’æ’°’∂’∏’≤','’Ω÷Ä’∏÷Ç’∂÷Ñ','’æ’¶’Ø’°’∫','’∫’´’ø’°’Ø','’¢÷Ä’´’∂’±','’°’≤’•÷Ä’Ω!','’∞’°÷Ä’´’π','’°÷Ñ’¨’∏÷Ä','’¥’´’¶’•’¨!','’Ω’ø’æ’°÷Ä','’¨’∏’≤’°÷É','’£’¥’¢’•’©','’°’∂’¶’∏÷Ä!','’Ω÷Ä’´’∂’£','’≥’°’∑’°’Ø','’°’º’∂’•’¨!','’¢’¨’©’°’Ø','’ª’∂’ª’∏÷Å','÷Ñ’°’¥’´’π','’£’°÷Ä’∏÷Ç’∂','’∫’°’∑’°÷Ä','’≠’¨’∏÷Ç÷Ä’§','’§’∏÷Ç’Ω’ø÷Ä','’ª’•’º’∏÷Å','’ø’´’∫’´’Ø','’´’Ω’¨’°’¥','’¶’£’•’Ω’ø','’Ø’°’Ø’°’∏!','’Æ’°’≤’´’Ø','’°’∂’ø’´’Ø!','’§’§’¥’´’Ø','’©’°’∂’°÷Ñ','’∑’•÷Ä’•÷É','’©’æ’°’∂÷Ñ!','’∂’´’¶’°’Ø','’£’•÷Ä’°’≥','’§’•’Ø’°’∂!','’π’∏÷Ä’∏÷Å!','’§’∏’¨’°÷Ä!','’£’•÷Ä’°’∂','’Ø’º’∏÷Ç’∂’Ø','’∑’∂’π’•’≤!','’Ø’∏÷Ä’•’Ø!','÷Å’•÷Ä’•’Ø','’∏÷Ç’¶’¢’•’Ø!','’°’∂’Ø’°’∫!','’¨’°÷Ä’∏÷Ç’¥','’∂’°’æ’°’Ø','’ø’∏’∂’∏÷Ç’Ω','’•’≤’∏÷Ç’∂’£','’©’°’∂’±÷Ä','’£’°’¨’´÷Ñ!','’•’≤’µ’°’¥','’°’∂’©’´’æ!','’∞’°’∑’´’∑!','’¨’´’¶’•’¨!','’Ø’ø÷Ä’∏’∂','’Ø’∏’¢÷Ä’°!','’•’º’°’Ø’´!','’≠’°’º’°’ø','’°’∂’§’°’¥','’Æ’°’¨’•’¨!','’¢’°’™’°’Ø','’ª÷Ä’æ’•’™','’∂’∏÷Ä’´÷Å!','’Ω’∫’∏÷Ç’∂’£','’æ’∏’Ø’°’¨','’∞’Ω’Ø’´’π','’∫’°’∞’°’Ø','’ø’Ø’¨’∏÷Ä','’¶’∏’§’•’¨','’°’µ÷Ä’∏÷Å!','’Ω’•’≤’°’∂','’Ø’∏÷Ç’¶’´’Ø!','’ø’´’ø’°’∂','’∏’Ω’ø÷Ä’•','’Ω’ø’∏÷Ç’µ’£','’∞’°’ø’´’Ø','’∏’≤’¢’°’¨!','÷Ñ’°’¥’∏÷Å','’°÷Ä’≠’´’æ','’Ω’•’∂’°’ø!','’§’´’¥’°’Ø','’¢’∏÷Ç’™’´’π!','’©’∏’∑’°’Ø','’ø’•’Ω’°’Ø','÷Ñ’¨’∏÷Ç’∂’£','’Ω’•’¨’°’æ!','’£’ø’∂’•’¨','’°’¶’∂’´’æ','’Ø’°’≠’´’π!','’Ω’¥’¢’°’Ø','’∂’´’Ø’•’¨!','’§’°’ø’•’¨','’°’º’∏÷Ç’µ’£!','’Ω’°÷É’∏÷Ä','’°’ª’¨’´’Ø!','’∫’°÷Ä’•’∂','’æ’°’≤’∏÷Ç÷Å','’∏÷Ç’≤÷á’∏÷Ä','’¥’°’∂’£’∏','’≠’∏÷Ä’°’∂','’°’Æ’•’¨’´','÷É’•’ø’∏÷Ç÷Ä','’∫’∏÷Ç÷Ä’°’Ø','÷É’∏’≠’•’¨','’Ω’´÷Ä’•’¨','’æ’°’µ÷Ä’´','’ø’°’≥’°÷Ä','’§’´’∫’∏÷Ç’Ø','’®’¥’∫’•’¨','’•÷Ä’°’∑’ø','’Ø’°’æ’´’≥','’∏÷Ç’ø’•’Ω’ø','’¥’∏÷Ä’∏÷Ç÷Ñ','’°’¥÷É’∏÷É!','÷Ñ’∏’¨’•’ª','’•’º’µ’°’Ø','’≠’∏’Ω’•’¨','’¥’°’µ’´’Ω','’£’´’∑’•÷Ä','’≥’°÷Ñ’•’¨!','’°÷Ä’¥’°’æ','’Æ’Æ’∏÷Ç’¥’¢','’°’≤÷Å’°’∂','’∫’°’Ø’°’Ω!','’¢’∏÷Ç’™’∏÷Ç’¥','’°’¢’≠’°’¶!','’ø’°’º’•’≠','’∞’°’æ’°’∂!','’æ’°’£’∏’∂','’¢’∏÷Ä’Ω’°!','’¶’°’æ’°’Ø','’°’Ø’ø’´’æ','’Ω’°’¨’∏÷Ä','’•÷Ä’∑’´’Ø','’©’•÷Ä’°’≥','’•÷Ä’Ø’´÷Ä','’©’∏’æ’´’π!','’¢’º’∂’•’¨','’Ω÷Ä’æ’°’Ø','’Ø÷Ä’Ø’´’∂!','’§’™’∏’≠÷Ñ','’¶’´’ª’∏’≤!','’Ω’≠’•’¥’°!','’Ω’∏’≠’°’Ø','’£’´’ø’°’Ø','’Ø’°’ø’°’Ø','’´’∑’≠’°’∂','’¥’•’º’•’¨!','’∑’°’∫’´’Ø','’Ω’ø÷Ä’∏÷Ç’Ø','’Ø’°÷Ñ’°’æ','’Æ’°’∂’∏’©','’Ø’°÷Ä’∏’ø','’æ’°’º’•’¨','’©÷Ä’ª’•’¨','’∫’´÷Å÷Å’°!','’£’∂’°÷Å÷Ñ','’æ’°’º’´’π','’ø’°’∫’°’Ø','’≠’∏’∂’°’æ!','’∑’´’∂’•’¨!','’ß’©’´’Ø’°!','’°’∂’Ø’°’≠!','’¢’∏’Ω’∏÷Ä','’°’¨÷á’∏÷Ä','’°’º’∏’≤’ª','’£’°’≥’°’≥','’Ø÷Ä’Æ’•’¨','’∫’°’∂’´÷Ä','’¨’°’æ’°’∑','’°’¥’∏÷Ç÷Ä’´!','÷Å’∂÷Å’∏÷Ç’¥','’Ω÷Ä’¢’´’π','’∏÷Ç’≤’•÷Ä’±','’∑’´÷Ä’´’¥','’∞’•’≤’∏÷Ç’Ø','’Ø’∏÷Ä’°’Æ!','÷Å’°’¥’°÷Ñ','’°’≤’ª’´’Ø','÷Ü’´’¶’´’Ø','’∏÷Ç’¨’∏÷Ç’∂÷Ñ','’™’µ’∏÷Ç÷Ä’´','’£’ø’°’Æ’∏','’Ø’°’∂’∏’∂','’°’æ’°÷Ä’ø','÷Ñ’´’¥’´’Ø','’æ÷Ä’±’´’∂','’∂’°’¥’°’Ø','’¥’©’•÷Ä÷Ñ','’§’•’¨’ø’°!','’¨’∏÷Ç’Ω’´’∂','’∞’•’≤’•’≤','’¢’∂’∏÷Ç’µ’©','’§’∂’π’´’Ø!','’°’∂’±’°’æ!','’¥’•’∂’°’Ø!','’æ’´’≥’°’Ø','’Ø’°’∫’´’Ø','’©’´÷Ä’°’≠','’©’°÷Ñ’∏÷Ç’∂','’∞’∏÷Ç’¶’´’π!','÷Å’∏÷Ä’•’∂','÷Ö’∫’•÷Ä’°','’ø’°’¢’°’ø','’¶’°’ø’´’Ø','’©’°’≠’´’Æ','’¥’Ø÷Ä’°’ø','’¢’∏’¨’∏÷Ç’Ø','’¢’°’≠’∏÷Ç’¥','’Ω’∏÷Ç’¨’´’π','’∞’∏’∫’∏’∫','’Ø’∏’ø’∏’∑!','÷Ñ’∏’©’∏’©','’Ø’∂÷Ñ’•’¨','’Ω’•’¶’∏’∂!','’π’°÷Ä’π’´!','’Ø’°’∂’•÷É','’°’æ’°’∂’§','’º’•’¶’∏÷Ç’Ω!','’¥’•’¨’´÷Ñ!','’≥’°’¥÷É’°!','’©’¨÷É’°’ø!','’°’∂’°’¥’∫!','’°’∂’•’Æ÷Ñ','’∞’°’æ’°’ø','’∞’°’¨’æ’°!','’∞÷Ä’§’•’∞','’Ω’∂’°’∂’Ø','’∂’°’µ’•’¨!','’Æ’∏÷Ä’°’∂!','’ø’°’ø’´’Ø','’Ø’°÷Ä’∏’≤!','’©’º’π’∏’≤!','’∑÷Ñ’•÷Ä’©','’¨’∏÷Ç’Ω’°’∂','÷Ö’§’°’π’∏÷Ç','’°’∫’°’Ø’´','’¶’∏÷Ç’º’∂’°!','’∫’°’ø’´’æ','’æ’´’∑’°’∫','’Ø’∏’Ø’´’Ø!','’≠’¥’´’π÷Ñ','’∫’∏’∫’∏÷Ñ!','’¥’∏÷Ä’•’≠!','÷Å’∂÷Å’∏÷Ç’≤','’™’°’∂’´÷Ñ','’©’°’¨’°’∂','’©’∑’æ’°’º','÷Ñ’°’≤’°÷Ñ','’Ω’°’¨’´’Ø','’≠’Ω’ø’´’æ!','’°’∂’≥’°÷Ä!','’∫’°’∞’∏÷Å','÷Ñ’∏’π’•’¨','÷Ñ’°÷Ä’∏’¶','’ø’°÷Ñ’Ω’´','’≠’≥’∏÷Ç’≤’´','’≠’∏’º’∏’π','’©’°÷É’∏÷Ä','’Ø’∏÷Ç÷Ä’Æ÷Ñ','’§’∏’§’∏’∑!','÷Ö’°’¶’´’Ω','’£’∏’º’∏’¶','’∏÷Ç÷Ä’¢’°’©','’°’µ÷Ä’•’¨','’∞’∂’π’•’≤','’Ω÷É’º’•’¨','’£’°’¨’°÷Ä','’Ø’ø÷Ä’´’≥','’•’¨’∂’•’¨!','’±’µ’∏÷Ç’§’∏','’º’•’∞’°’∂','’©’©’æ’°’∑','’∑’∂’π’•’¨','’∞’°’ø’•’¨','’≠’∏’™’∏’º!','’Ø÷Ä’≥’°’ø!','’Ø’∏’π’•’¨!','’Ø’°÷Ä’´÷Ñ','’£’∂’∏÷Ä’§','’°’∂’Ø’∏’π!','’©’°’æ’´’∑','’≠’°’æ’°÷Ä','’ø’´’∫’°÷Ä','’•’≤’´’∂’ª','÷Ñ’∏’©’∏÷Ç’Ø','’ø’°’∫’°’∂','’≠’°’≤’∏’≤','’∂’∑’ø’°÷Ä!','’¥’°’ø’∏÷Ç’º','’Æ’°’Ø’∏’≤!','’∞’•÷Ä’∏’Ω','’∫’°’º’°’æ!','’°’∂’°’¨’´!','’∞’°’¥’°’º!','’©÷á’∂’∏÷Å','’°’¥’∏÷Ä÷Ü!','’∞’∏’æ’´’ø','’π’∏÷É’´’Ø!','’ø’¶÷Ä’∏÷Ç’Ø','’¢÷Ä’∏’∂’¶','’¥’ø÷Ä’°’Ø','’±’æ’°’±÷á!','’£’∏÷Ç’¨’∫’°','’§’´’¥’•’¨','’¢’¨÷Ä’°’Ø!','’ª’°’∞’•’¨!','’≠’°’π’•’¨','’•’≤÷á’∂’´','’©’°÷É’∏’∂','’¨’´’Ω’•’º!','’∞’°’≥’°’≠!','’Ω’µ’∏÷Ç’™’•','’°’∂’ø’°’º','’Ø’•’º’´’Ø!','’æ’ø’°’∂’£','’∞’´’∑’•’¨','’Ω÷É’º’∏÷Å','’Ω’ø’´’∂÷Ñ','’≠’•’¨’°’º!','’¢’•÷Ä’•’¨!','’ø’∏’¥’°’ø','’•’¶’°’Ø’´','’§’∫÷Ä’∏÷Å','’£’°’¶’°’∂','’æ’°÷Ä’´’π','’°’∂’ø’∏÷Ç’∂!','’±’∏’≤’´’Ø','’°’∂’æ’°’≠!','’¶’∂’§’°’∂','’©’°÷É’∏÷Ç÷Ä','’£’∏’º’°’¨!','÷É’∏’≤’∏÷Å','’∞’∏’¨’∏’æ!','’Ω’°’Ø’°’æ!','’º’°’§’´’∏','’∫’´’©’∏’∂!','’¥’∏’Æ’°’Ø','’Ω’´’£’°÷Ä!','’≠’°’¢’•’¨','’£’∏÷Ç’∑’°’Ø','’∞÷Ä’°’∑÷Ñ','’°’¶’§’°’Ø','÷Ñ’°’≤÷Å÷Ä','’¶’∏’¥’¢’´!','’Æ’≤÷Ä’´’§','’Æ’∫’ø’∏÷Ç’∂!','’∫’°’∂’§’°','’¥÷Ä÷Ä’´’Ø','’π’°÷É’∏÷Ç’¥!','÷Å’∏÷Ç÷Å’∏÷Ç’¥','÷Ö’Æ’µ’°’¨','’•’≤’∂’´’Ø','’¥’ø÷Ä’∏÷Ç’Ø!','’¥’∏’§’•’¨!','÷Ñ’°’æ’•’¨','’∞’°’π’°’∂!','’ø’∏’Ø’∏’Ω','’°’∂’Ω’•’º!','’¥’∏’≤’•’Ω','÷É’•’©’°’Ø','’¢’°’¨’•’ø!','’¥’º’°’µ’¨','’©’©’•’∂’´','’©’°’¨’´’¢!','’§÷Ä’°÷Å’´!','’º’∏’¢’∏’ø','’¢’°÷Ä’´÷Ñ','’Ω’∂’§’´’Ø','÷Ñ’°÷Å’°’≠','’Ø’∂’≥’´’º','’¨’´’∂’•’¨!','’≠’∑’∑’∏÷Å!','’∞’∏÷Ç’∂’´’Ω','’Ø’°’Ø’°’π','’∞’∏÷Ä’°’∂','’æ’°÷Ä’°’¶','’∑’°÷Ä’°’∂','’©’∑’∑’∏÷Å!','’Ø’æ’°÷Ä÷Å!','’∫’°’∫’´’Ø','’Ø’°’≤’´’∂','’°’∂’±÷Ä÷á','’Ø’°’æ’°’ø','’©’•’∂’´’Ω','’§’°’¨’°÷Ä','’≠’°÷Ä’°’∂!','’π’æ’•÷Ä’©','’∞’∂’π’•’¨!','’°’æ’•’¨’´!','÷Ñ’°’æ’∏÷Ä','’∂’∑’•’∂’´','’∫’°÷Ä’∏’∂','’∞’∏÷Ç’¥’∏÷Ä','’∫’ø’ø’•’¨','’Æ’∂’∏÷Ç’∂’§','’™’∫’ø’°’¨','’Ø’∫’π’∏÷Ç’∂','’Ω’∫’°’Ω÷Ñ','’æ’°’¶’•’¨','’Æ’°’Æ’°’∂!','’Ø÷Ä÷Ñ’∏’ø!','’¢’•÷Ä’°’∂','’°’∂’§’∏÷Ç÷Ä!','’¢’∏’æ’•’¨!','÷É’°’©’•’©','’¢’°’¨’´’Ø!','’Ω÷Ä’¢’•’¨','’≥’°’∑’•’¨','’°’ø’°’≤’±','’¥’°’Ω’∏÷Ç÷Ä','’§’´’¥’°÷Å!','’∞’∏÷Ç’¨’´’Ω','’ø’≠’¥’°÷Ä','’§’°÷Ä’°’Ø','’Ø’∏÷Ä’´’¶','’º’•’™’´’¥','’æ÷Ä’°÷Å’´','’≠’°’≤’°’≤','’£÷Ä’£’´’º!','’≠’∂’∏÷Å’´','’Ø’°’∫’∏÷Å','’©’¥’¢’´’Ø!','’∫’°’¨’°’ø!','’∏’Ω’Ø’∏÷Ä','’£’°’æ’°’º','’°÷Ä’©’∏÷Ç’∂!','’Æ’≤’∏’ø’•!','’∞’°’æ’°÷Ñ','’°’Ω’∫’•’ø','’Ω’≠’ø’∏÷Ä','’Ω÷Ä’´’Ø’°','’©’°’≤’•’¨','’∞’°’Ω’∏÷Ç’∂','’Æ’°÷Ä’°’æ','’¥’•’≠’°’Ø','’§’∏÷Ç’§’∏÷Ç’Ø','’Ø’∏’≤’°’Ø','’¢’°÷Å’´’Ø','’¨’Æ’∏÷Ä’§','’©’¥÷Ä’°’Æ!','’≠’∂’±’∏÷Ä','’∂’•’ø’•’¨','’£’´’¨’°’Ω!','÷Ö÷Ä’•’∂÷Ñ','’§÷Ä’∏÷Ç’µ’©','’°’¥÷Ä’°’Ø','’Ø’°÷Ä’Æ÷Ä','’¢’°’∂’°’∂','’°÷Ä’°÷Ä÷Ñ','’Ø’∏’Ø’∏’Ω']];
  if (WORDS.length === 0) console.error("Word list is empty!");

  // --- Correctly Sorted LOWERCASE Armenian Letters ---
  const sortedLetters = ['’°', '’¢', '’£', '’§', '’•', '’¶', '’ß', '’®','’©', '’™', '’´', '’¨', '’≠', '’Æ', '’Ø', '’∞','’±', '’≤', '’≥', '’¥', '’µ', '’∂', '’∑', '’∏','’π', '’∫', '’ª', '’º', '’Ω', '’æ', '’ø', '÷Ä','÷Å', '’∏÷Ç', '÷É', '÷Ñ', '÷á', '÷Ö', '÷Ü'];
  const allLetters = [...sortedLetters];

  // --- Keyboard Layout Definitions ---
  const keyboardAlphabeticalLayout = [sortedLetters.slice(0, 8),sortedLetters.slice(8, 16),sortedLetters.slice(16, 24),sortedLetters.slice(24, 32),[...sortedLetters.slice(32), '']];
  const keyboardPhoneticLayout = [['’ß', '’©', '÷É', '’±', '’ª', '÷á', '÷Ä', '’π', '’≥', '’™'],['÷Ñ', '’∏', '’•', '’º', '’ø', '’∏÷Ç', '’´', '÷Ö', '’∫', '’≠'],['’°', '’Ω', '’§', '÷Ü', '’£', '’∞', '’µ', '’Ø', '’¨', '’Æ'],['’¶', '’≤', '÷Å', '’æ', '’¢', '’∂', '’¥', '’∑', '’®', '']];
  const LAYOUT_NAMES = {'alphabetical': '‘±‘≤‘≥ ‚å®Ô∏è','phonetic': '‘±’ç‘¥ ‚å®Ô∏è'};

  // --- Game Date and Word Logic ---
  let effectiveDate; // The date we are actually displaying/loading state for
  let isViewingPastGame = false; // Flag to indicate if we loaded from URL param
  let targetWord;
  let parsedTarget;
  let dateKey; // localStorage key for the game state of the effectiveDate
  let dayOffset; // Offset for the effectiveDate
  let gameNumber; // Game number for the effectiveDate

    // --- Game Date and Word Logic (UTC Version with Dictionary Words) ---
  function setupDateAndWord(dateString = null) {
      // Define Start Date components from the string
      const startYear = parseInt(START_DATE_STRING.substring(0, 4));
      const startMonth = parseInt(START_DATE_STRING.substring(5, 7)) - 1; // Month is 0-indexed for Date.UTC
      const startDay = parseInt(START_DATE_STRING.substring(8, 10));
      // Get Start Date as milliseconds since epoch at UTC midnight
      const startDateUTC = Date.UTC(startYear, startMonth, startDay, 0, 0, 0, 0);

      // Get Today's Date at UTC midnight
      const now = new Date(); // Current moment
      const todayUTC = Date.UTC(now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate(), 0, 0, 0, 0); // Today's midnight UTC

      let effectiveDateUTC; // This will hold the UTC milliseconds for the date we are loading
      isViewingPastGame = false; // Reset flag

      if (dateString) {
          // Parse the incoming date string as UTC midnight
          const parts = dateString.split('-');
          let requestedDateUTC = NaN;
          if (parts.length === 3) {
               const reqYear = parseInt(parts[0]);
               const reqMonth = parseInt(parts[1]) - 1; // 0-indexed month
               const reqDay = parseInt(parts[2]);
               if (!isNaN(reqYear) && !isNaN(reqMonth) && !isNaN(reqDay)) {
                    requestedDateUTC = Date.UTC(reqYear, reqMonth, reqDay, 0, 0, 0, 0);
               }
          }

          if (!isNaN(requestedDateUTC) && requestedDateUTC <= todayUTC && requestedDateUTC >= startDateUTC) {
              effectiveDateUTC = requestedDateUTC;
              isViewingPastGame = true;
          } else {
              console.warn(`Invalid, future, or too early date requested: ${dateString}. Loading today's game.`);
              effectiveDateUTC = todayUTC;
              isViewingPastGame = false;
              if (window.history.replaceState) {
                   window.history.replaceState(null, '', window.location.pathname);
              }
          }
      } else {
          effectiveDateUTC = todayUTC;
          isViewingPastGame = false;
      }

      // --- Calculate offset and game number based purely on UTC difference ---
      const diffMillis = effectiveDateUTC - startDateUTC;
      dayOffset = diffMillis >= 0 ? Math.floor(diffMillis / (1000 * 60 * 60 * 24)) : -1;
      gameNumber = dayOffset + 1;

      effectiveDate = new Date(effectiveDateUTC); // Create Date object for formatting/reference

      // *** Filter WORDS list to get only potential daily targets ***
      const dailyTargetWords = WORDS.filter(word => !word.endsWith('!'));

      if (dailyTargetWords.length === 0) {
           console.error("CRITICAL ERROR: No words available for daily targets after filtering! Check the WORDS list and the '!' suffix usage.");
           // Decide how to handle this - throw error, use fallback, etc.
           targetWord = "’Ω’≠’°’¨"; // Fallback
           // Potentially invalidate dayOffset/gameNumber if no targets exist
           dayOffset = -1;
           gameNumber = '?';
      } else if (dayOffset < 0) {
           // Handle invalid date offset (before start date)
           console.warn(`Calculated dayOffset ${dayOffset} is invalid (before start date). Using fallback word.`);
           targetWord = "’Ω’≠’°’¨";
           gameNumber = '?'; // Indicate invalid game number
      } else {
           // Select the target word using the dayOffset MODULO the length of the FILTERED list
           targetWord = dailyTargetWords[dayOffset % dailyTargetWords.length];
           // Optional: Add a warning if the offset is surprisingly large, though modulo handles it
           // if (dayOffset >= dailyTargetWords.length) {
           //      console.warn(`Day offset ${dayOffset} exceeds length of daily words list (${dailyTargetWords.length}). Wrap-around applied.`);
           // }
      }

      // Now parse the selected targetWord (which should NOT have '!')
      parsedTarget = splitWord(targetWord);

      // Generate the dateKey using the YYYY-MM-DD format derived from UTC components
      const keyYear = effectiveDate.getUTCFullYear();
      const keyMonth = String(effectiveDate.getUTCMonth() + 1).padStart(2, '0');
      const keyDay = String(effectiveDate.getUTCDate()).padStart(2, '0');
      const effectiveDateStringForKey = `${keyYear}-${keyMonth}-${keyDay}`;
      dateKey = `armenianWordle-${effectiveDateStringForKey}`;

      // Update the display
      gameNumberDisplay.textContent = `‘Ω’°’≤ #${gameNumber}`;
      if (isViewingPastGame) {
          gameNumberDisplay.title = `‘¥’´’ø’∏÷Ç’¥ ’•÷Ñ ${effectiveDateStringForKey} ’≠’°’≤’®÷â ’ç’•’≤’¥’•÷Ñ’ù ’¢’°÷Å’•’¨’∏÷Ç ’∫’°’ø’¥’∏÷Ç’©’µ’∏÷Ç’∂’®÷â`;
      } else {
          gameNumberDisplay.title = `’ç’•’≤’¥’•÷Ñ’ù ’ø’•’Ω’∂’•’¨’∏÷Ç ’°’∂÷Å’°’Æ ’≠’°’≤’•÷Ä’®÷â`;
      }
      // console.log(`[Setup UTC Dict] Word selected for offset ${dayOffset} from ${dailyTargetWords.length} daily words: ${targetWord}`);
  }

  function getGameNumberForDate(date) {
      const startDate = new Date(START_DATE_STRING);
      date.setHours(0, 0, 0, 0);
      const offset = Math.floor((date - startDate) / (1000 * 60 * 60 * 24));
      return offset + 1;
  }

  // --- Game State Variables ---
  let guesses = [];
  let currentGuess = [];
  let currentRowIndex = 0;
  let isGameOver = false;
  let messageTimeout;
  let keyStatuses = {};
  let currentLayoutName = localStorage.getItem(LOCAL_STORAGE_LAYOUT_KEY) || 'phonetic';
  let currentLayout = (currentLayoutName === 'phonetic') ? keyboardPhoneticLayout : keyboardAlphabeticalLayout;


   // --- State Management (localStorage) ---
  function saveState() {
    // Allow saving state regardless of whether it's today or a past game.
    // The dateKey ensures it saves to the correct day's storage slot.

    const state = {
      guesses,
      currentRowIndex,
      isGameOver,
      targetWord, // Save the target word for this date's state
      keyStatuses
    };
    localStorage.setItem(dateKey, JSON.stringify(state)); // Use dateKey for the specific day being played/viewed
    // console.log(`Saved state for ${dateKey}, isGameOver: ${isGameOver}`);

    // Save layout preference separately, always allowed
    localStorage.setItem(LOCAL_STORAGE_LAYOUT_KEY, currentLayoutName);

    // --- Update MAIN History List (Only when CURRENT day's game ends) ---
    // This check REMAINS crucial: Only add to the official history popup list
    // when the game corresponding to the ACTUAL CURRENT DATE is finished.
    const todayForHistoryCheck = new Date();
    todayForHistoryCheck.setHours(0, 0, 0, 0);
    const isEffectiveDateToday = effectiveDate.getTime() === todayForHistoryCheck.getTime();

    if (isGameOver && isEffectiveDateToday) { // Only update history if game over AND it's today's game
        try {
            // console.log(`Updating history list because today's game (#${gameNumber}) finished.`);
            const historyString = localStorage.getItem(LOCAL_STORAGE_HISTORY_KEY);
            let history = historyString ? JSON.parse(historyString) : [];
            if (!Array.isArray(history)) history = [];

            const currentDateString = effectiveDate.toISOString().split('T')[0]; // Should be today's date string
            const currentGameNumber = gameNumber; // Should be today's game number

            const existingEntryIndex = history.findIndex(entry => entry.date === currentDateString);
            const newEntry = { date: currentDateString, number: currentGameNumber };

            if (existingEntryIndex > -1) {
                history[existingEntryIndex] = newEntry;
            } else {
                history.push(newEntry);
            }

            history.sort((a, b) => new Date(b.date) - new Date(a.date));
            localStorage.setItem(LOCAL_STORAGE_HISTORY_KEY, JSON.stringify(history));
            // console.log("Saved history:", history);

        } catch (e) {
            console.error("Error saving game history:", e);
        }
    } else if (isGameOver && !isEffectiveDateToday) {
         // console.log(`Finished a past game (${dateKey}), NOT updating main history list.`);
    }
  }


  function loadState() {
    // Theme
    const savedTheme = localStorage.getItem('theme') || 'dark';
    document.body.classList.toggle('dark', savedTheme === 'dark');
    toggleBtnTheme.textContent = savedTheme === 'dark' ? '‚òÄÔ∏è' : 'üåó';

    // Layout Preference
    const savedLayoutName = localStorage.getItem(LOCAL_STORAGE_LAYOUT_KEY);
    if (savedLayoutName && LAYOUT_NAMES[savedLayoutName]) {
        currentLayoutName = savedLayoutName;
    } else {
        currentLayoutName = 'phonetic';
    }
    currentLayout = (currentLayoutName === 'phonetic') ? keyboardPhoneticLayout : keyboardAlphabeticalLayout;
    toggleBtnLayout.textContent = LAYOUT_NAMES[currentLayoutName];
    document.body.setAttribute('data-keyboard-layout', currentLayoutName);

    // --- Load Game State for the effectiveDate ---
    const savedStateJSON = localStorage.getItem(dateKey); // Use the key for the specific date
    if (savedStateJSON) {
        // Saved state EXISTS for this date (today or past)
        try {
            const savedState = JSON.parse(savedStateJSON);
            guesses = savedState.guesses || [];
            currentRowIndex = savedState.currentRowIndex || 0;
            // *** Load isGameOver directly from the saved state ***
            isGameOver = savedState.isGameOver || false;
            keyStatuses = savedState.keyStatuses || {};
            // Validate keyStatuses
            for (const key in keyStatuses) {
               const validStatuses = ['correct', 'present', 'absent', null];
               if (!validStatuses.includes(keyStatuses[key])) {
                   delete keyStatuses[key];
               }
            }
             // console.log(`Loaded state for ${dateKey}: isGameOver=${isGameOver}`);

        } catch (e) {
            console.error(`Error loading saved state for ${dateKey}:`, e);
            resetGameState(); // Reset if state is corrupted
            isGameOver = false; // Ensure playable if state was corrupt
        }
    } else {
        // No saved state found for this date
        // Reset game variables for a fresh start for this date's word
        resetGameState();
        // *** Ensure isGameOver is false, allowing play ***
        isGameOver = false;
        // console.log(`No saved state found for ${dateKey}. Initializing fresh game. isGameOver=${isGameOver}`);
    }
    // currentGuess should always be reset on load, regardless of state found
    currentGuess = [];
  }


  // --- Initialization ---
  function init() {
    const urlParams = new URLSearchParams(window.location.search);
    const dateParam = urlParams.get('date');

    setupDateAndWord(dateParam); // Determine effectiveDate, targetWord, isViewingPastGame etc.

    loadState(); // Load state (if exists) for effectiveDate. Sets isGameOver based on loaded state or defaults to false.

    buildBoard();
    buildKeyboard(); // Build keyboard based on loaded layout
    redrawBoardFromState(); // Display loaded guesses or empty board
    updateKeyboardHighlight(); // Update keyboard based on loaded keyStatuses

    // --- Conditional Input Disabling & Messaging ---
    if (isGameOver) {
        // Game is over EITHER because today's game was finished OR loaded state for a past game showed it was finished.
        disableInput();

        // Show final message based on the loaded state (which loadState populated)
        const lastGuessString = guesses.length > 0 ? guesses[guesses.length - 1].map(g => g.letter).join('') : '';
        const wordForMessage = (localStorage.getItem(dateKey) ? JSON.parse(localStorage.getItem(dateKey)).targetWord : null) || targetWord; // Use saved target if possible, else current

        if (splitWord(lastGuessString).join('') === splitWord(wordForMessage).join('')) {
            showMessage('üéâ ’Ä’°’≤’©’°’∂’°’Ø üéâ', 0); // Indefinite
        } else {
            // If lost or loaded a completed-lost game
             showMessage(`‘Ω’°’≤’∂ ’°’æ’°÷Ä’ø’æ’°’Æ ’ß÷â ‘≤’°’º’®’ù ${wordForMessage}`, 0); // Indefinite, generalized message
        }
         if (isViewingPastGame) {
              console.log(`Viewing completed past game: ${effectiveDate.toISOString().split('T')[0]}`);
         }

    } else {
        // Game is NOT over. It's either today's game in progress, or a past game loaded fresh.
        // Ensure input is enabled (default state, no need to explicitly enable unless previously disabled)

        if (isViewingPastGame) {
             // It's a past game, but no saved state or saved state wasn't finished. Allow playing.
             showMessage(`‘Ω’°’≤ #${gameNumber} (${effectiveDate.toISOString().split('T')[0]})`, 3000); // Informational message
             console.log(`Playing past game: ${effectiveDate.toISOString().split('T')[0]}`);
        } else {
             // It's today's game, in progress or just started.
             // console.log("Playing today's game.");
             // No initial message needed unless resuming mid-game, maybe? (Currently no specific message for this)
        }
    }


    // Add general event listeners
    window.addEventListener('keydown', handlePhysicalKey);
    toggleBtnLayout.addEventListener('click', switchLayout);
    gameNumberDisplay.addEventListener('click', openPastGamesPopup);
    popupCloseButton.addEventListener('click', closePastGamesPopup);
    pastGamesPopup.addEventListener('click', (e) => {
        if (e.target === pastGamesPopup) closePastGamesPopup();
    });
  }


  function resetGameState() {
      guesses = [];
      currentGuess = [];
      currentRowIndex = 0;
      isGameOver = false; // Reset game over status
      keyStatuses = {};
      // Don't reset isViewingPastGame here, it's determined by URL
  }


   // --- Word Processing ---
   function splitWord(word) {
    const chars = [];
    const lowerWord = String(word || '').toLowerCase();
    for (let i = 0; i < lowerWord.length; i++) {
      if (lowerWord[i] === '’∏' && i + 1 < lowerWord.length && lowerWord[i + 1] === '÷Ç') {
        chars.push('’∏÷Ç');
        i++;
      } else {
        chars.push(lowerWord[i]);
      }
    }
     return chars;
   }

  // --- UI Building ---
  function buildBoard() {
    boardElement.innerHTML = '';
    for (let i = 0; i < MAX_ROWS; i++) {
        const row = document.createElement('div');
        row.className = 'row';
        for (let j = 0; j < WORD_LENGTH; j++) {
            const tile = document.createElement('div');
            tile.className = 'tile';
            tile.innerHTML = '<div></div>';
            row.appendChild(tile);
        }
        boardElement.appendChild(row);
    }
  }

  function buildKeyboard() {
    keyboardTopRowElement.innerHTML = '';
    keyboardMainGridElement.innerHTML = '';

    // Top Row
    [ENTER_KEY, DELETE_KEY].forEach(keyText => {
        const keyElement = document.createElement('button');
        keyElement.textContent = keyText;
        keyElement.className = 'key';
        if (keyText === ENTER_KEY) {
            keyElement.classList.add('enter');
            keyElement.onclick = handleSubmit;
        } else {
            keyElement.classList.add('delete');
            keyElement.onclick = handleDelete;
        }
        keyboardTopRowElement.appendChild(keyElement);
    });

    // Main Grid - Use the currentLayout
    currentLayout.forEach(rowKeys => {
        rowKeys.forEach(keyText => {
            const keyElement = document.createElement('button');
            keyElement.textContent = keyText;
            keyElement.className = 'key';
            if (!keyText) {
                 keyElement.classList.add('placeholder');
                 keyElement.disabled = true;
                 keyElement.style.cursor = 'default';
                 keyElement.dataset.key = '';
            } else {
                keyElement.dataset.key = keyText;
                keyElement.onclick = () => handleKeyClick(keyText);
            }
            keyboardMainGridElement.appendChild(keyElement);
        });
    });
    document.body.setAttribute('data-keyboard-layout', currentLayoutName);
  }

    // --- Keyboard Layout Switcher ---
    function switchLayout() {
        currentLayoutName = (currentLayoutName === 'phonetic') ? 'alphabetical' : 'phonetic';
        currentLayout = (currentLayoutName === 'phonetic') ? keyboardPhoneticLayout : keyboardAlphabeticalLayout;
        toggleBtnLayout.textContent = LAYOUT_NAMES[currentLayoutName];
        buildKeyboard();
        adjustBoardSize();
        updateKeyboardHighlight();
        // Save layout preference immediately, not tied to game state saving
         localStorage.setItem(LOCAL_STORAGE_LAYOUT_KEY, currentLayoutName);
    }


  // --- UI Updating & State Restoration ---
  function redrawBoardFromState() {
     const rows = boardElement.querySelectorAll('.row');
     rows.forEach((row, rowIndex) => {
        const tiles = row.querySelectorAll('.tile');
        if (rowIndex < guesses.length) {
             const guessData = guesses[rowIndex];
             tiles.forEach((tile, tileIndex) => {
                const tileInner = tile.querySelector('div');
                if (!tileInner) return;
                const letterData = guessData[tileIndex] || { letter: '', status: '' };
                tileInner.textContent = letterData.letter;
                tile.classList.remove('correct', 'present', 'absent', 'filled');
                if (letterData.letter) {
                     tile.classList.add('filled');
                     if (letterData.status) {
                         tile.classList.add(letterData.status);
                     }
                }
             });
        } else {
              // Clear rows below current guess or loaded state
              tiles.forEach(tile => {
                 const tileInner = tile.querySelector('div');
                 if (tileInner) tileInner.textContent = '';
                 tile.classList.remove('correct', 'present', 'absent', 'filled');
              });
        }
     });
      // Ensure the current guess row is also cleared if redraw happens after loading state
      if (currentRowIndex < MAX_ROWS && currentRowIndex >= guesses.length) {
          updateCurrentRowDisplay(); // This will clear the row if currentGuess is empty
      }
  }


  function updateCurrentRowDisplay() {
    if (isGameOver || currentRowIndex >= MAX_ROWS) return; // Don't update if game is over
    const currentRow = boardElement.querySelectorAll('.row')[currentRowIndex];
    if (!currentRow) return; // Safety check
    const tiles = currentRow.querySelectorAll('.tile');
    tiles.forEach((tile, index) => {
        const tileInner = tile.querySelector('div');
        if (!tileInner) return;
        const letter = currentGuess[index] || '';
        tileInner.textContent = letter;
        if (letter) {
            tile.classList.add('filled');
        } else {
            tile.classList.remove('filled');
        }
        tile.classList.remove('correct', 'present', 'absent');
    });
  }

  function updateKeyboardHighlight() {
    keyboardElement.querySelectorAll('.key[data-key]').forEach(keyElement => {
        const letter = keyElement.dataset.key;
        if (!letter) return;
        const cumulativeStatus = keyStatuses[letter];
        keyElement.classList.remove('correct', 'present', 'absent', 'has-present');
        if (cumulativeStatus) {
            keyElement.classList.add(cumulativeStatus);
        }
    });
  }


   // --- Event Handlers ---
  function handleKeyClick(key) {
    // Allow adding letters only if game is not over and current guess is not full
    if (isGameOver || currentGuess.length >= WORD_LENGTH) {
        return;
    }
    currentGuess.push(key);
    updateCurrentRowDisplay();
  }

  function handleDelete() {
    // Allow delete only if game is not over and there are letters to delete
    if (isGameOver || currentGuess.length === 0) {
        return;
    }
    currentGuess.pop();
    updateCurrentRowDisplay();
  }

    // --- Event Handlers ---
  // ... (handleKeyClick, handleDelete remain the same) ...

  function handleSubmit() {
    if (isGameOver) return;

    if (currentGuess.length !== WORD_LENGTH) {
      shakeRow(currentRowIndex);
      showMessage("‘±’∂’¢’°’æ’°÷Ä’°÷Ä ’ø’°’º’•÷Ä’´ ÷Ñ’°’∂’°’Ø", 1500);
      return;
    }

    const guessString = currentGuess.join('');

    // *** Updated Validation Check ***
    // Check if the guess exists in the original WORDS list,
    // either exactly as typed or with the '!' dictionary suffix.
    const isValidWord = WORDS.includes(guessString) || WORDS.includes(guessString + '!');

    if (!isValidWord) {
        shakeRow(currentRowIndex);
        showMessage("’è’æ’µ’°’¨ ’¢’°’º’® ’¥’•÷Ä ’¢’°’º’°÷Ä’°’∂’∏÷Ç’¥ ’π’Ø’° :(", 1500);
        return; // Exit if word is not valid at all
    }

    // --- Word is valid, proceed with checking guess against targetWord ---
    // Note: checkGuess compares against `parsedTarget`, which comes from `targetWord` (guaranteed not to have '!')
    const result = checkGuess(guessString);
    guesses.push(result);

    // Update cumulative key statuses
    result.forEach(({ letter, status }) => {
        const currentStatus = keyStatuses[letter];
        if (status === 'correct') keyStatuses[letter] = 'correct';
        else if (status === 'present' && currentStatus !== 'correct') keyStatuses[letter] = 'present';
        else if (status === 'absent' && !currentStatus) keyStatuses[letter] = 'absent';
    });

    // Animate and update display
    animateGuessResult(currentRowIndex, result);
    updateKeyboardHighlight(); // Update keyboard based on cumulative state

    // Proceed to next row or end game after animation delay
    setTimeout(() => {
        currentRowIndex++;
        currentGuess = [];
        // Check win/loss first, then save state
        checkWinLoss(guessString); // This will set isGameOver if needed
        saveState(); // Save state after checking win/loss (respects isViewingPastGame flag for history update)

    }, WORD_LENGTH * 150 + 300); // Wait for tile animation + a little buffer
  }


  function handlePhysicalKey(e) {
     if (isGameOver) return; // Check isGameOver flag
     let key = e.key;
     // Ignore modifier keys, function keys, etc. Allow Enter, Backspace, Delete.
     if (e.altKey || e.ctrlKey || e.metaKey || key.startsWith('F') || key.length > 1 && !['Backspace', 'Delete', 'Enter'].includes(key)) {
         return;
     }
     key = key.toLowerCase();

     if (key === 'enter') {
         handleSubmit();
     } else if (key === 'backspace' || key === 'delete') {
         handleDelete();
     } else {
         // Check if the pressed key is a valid Armenian letter.
         if (allLetters.includes(key)) {
              handleKeyClick(key); // Let handleKeyClick check length limit
         }
     }
  }


  // --- Game Logic ---
  function checkGuess(guessString) {
     const guessChars = splitWord(guessString);
     const result = [];
     const targetCopy = [...parsedTarget];
     for(let i = 0; i < WORD_LENGTH; i++) result[i] = { letter: guessChars[i], status: '' };
     for (let i = 0; i < WORD_LENGTH; i++) {
         if (guessChars[i] === parsedTarget[i]) {
             result[i].status = 'correct'; targetCopy[i] = null;
         }
     }
     for (let i = 0; i < WORD_LENGTH; i++) {
         if (result[i].status === 'correct') continue;
         const letter = guessChars[i];
         const indexInTarget = targetCopy.indexOf(letter);
         if (indexInTarget !== -1) {
             result[i].status = 'present'; targetCopy[indexInTarget] = null;
         } else {
             result[i].status = 'absent';
         }
     }
     return result;
  }

  function checkWinLoss(lastGuessString) {
     // This function now primarily sets the isGameOver flag and shows messages.
     // saveState() handles the actual saving and history update based on isGameOver.
     let gameEnded = false;
     if (splitWord(lastGuessString).join('') === parsedTarget.join('')) {
         showMessage('üéâ ’Ä’°’≤’©’°’∂’°’Ø üéâ', 5000); // Shorter duration for win on current day
         isGameOver = true;
         gameEnded = true;
         disableInput(); // Disable input immediately on win
     } else if (currentRowIndex >= MAX_ROWS) {
          showMessage(`’ä’°÷Ä’ø’∏÷Ç’©’µ’∏÷Ç’∂÷â ‘±’µ’Ω÷Ö÷Ä’æ’° ’¢’°’º’®’ù ${targetWord}`, 0); // Indefinite duration for loss
          isGameOver = true;
          gameEnded = true;
          disableInput(); // Disable input immediately on loss
     }
     // If game ended, saveState will handle history logging.
  }

  function disableInput() {
     // console.log("Input Disabled. isGameOver:", isGameOver, "isViewingPastGame:", isViewingPastGame);
     // Set flag just to be sure, although checkWinLoss or loading past game should do it
     isGameOver = true;
     // Remove event listeners that allow input modification
     window.removeEventListener('keydown', handlePhysicalKey); // Best practice to remove listener
     keyboardElement.querySelectorAll('.key').forEach(btn => {
         // Keep click listeners for layout/theme/game number
         if (btn.classList.contains('enter') || btn.classList.contains('delete') || btn.dataset.key) {
             btn.onclick = null; // Remove letter/enter/delete handlers
             btn.style.cursor = 'default';
             // btn.disabled = true; // Optional: visually disable
             // btn.style.opacity = 0.7;
         }
     });
     // Re-attach physical key listener IF input needs to be re-enabled (not currently used, but for future)
     // window.addEventListener('keydown', handlePhysicalKey);
  }


  // --- Animations & Messages ---
  function animateGuessResult(rowIndex, result) {
     const row = boardElement.querySelectorAll('.row')[rowIndex];
     if (!row) return;
     const tiles = row.querySelectorAll('.tile');
     tiles.forEach((tile, index) => {
         const { letter, status } = result[index];
         const tileInner = tile.querySelector('div');
         if (!tileInner) return;
         tileInner.textContent = letter;
         tile.classList.add('filled');
         tile.classList.remove('correct', 'present', 'absent');
         setTimeout(() => {
             if (status) tile.classList.add(status);
         }, index * 150);
     });
  }


  function shakeRow(rowIndex) {
    const row = boardElement.querySelectorAll('.row')[rowIndex];
    if (row) {
        row.classList.add('shake');
        row.addEventListener('animationend', () => row.classList.remove('shake'), { once: true });
    }
  }

   function showMessage(msg, duration = 2000) {
        clearTimeout(messageTimeout);
        messageElement.textContent = msg;
        messageElement.classList.add('show');
        // If duration is 0 or less, message stays until cleared or replaced
        if (duration > 0) {
            messageTimeout = setTimeout(() => {
                messageElement.classList.remove('show');
            }, duration);
        }
   }

  // --- Theme Toggle ---
  toggleBtnTheme.onclick = () => {
    const isDark = document.body.classList.toggle('dark');
    localStorage.setItem('theme', isDark ? 'dark' : 'light');
    toggleBtnTheme.textContent = isDark ? '‚òÄÔ∏è' : 'üåó';
  };

    // --- Past Games Popup Logic (UTC Version - Includes Today) ---
  function openPastGamesPopup() {
      try {
          pastGamesList.innerHTML = ''; // Clear previous list

          // Define Start Date components
          const startYear = parseInt(START_DATE_STRING.substring(0, 4));
          const startMonth = parseInt(START_DATE_STRING.substring(5, 7)) - 1; // 0-indexed
          const startDay = parseInt(START_DATE_STRING.substring(8, 10));
          // Get Start Date as milliseconds since epoch at UTC midnight
          const startDateUTC = Date.UTC(startYear, startMonth, startDay, 0, 0, 0, 0);

          // Get Today's Date at UTC midnight
          const now = new Date();
          const todayUTC = Date.UTC(now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate(), 0, 0, 0, 0);

          // console.log(`[Popup UTC] Today UTC: ${new Date(todayUTC).toISOString()}, StartDate UTC: ${new Date(startDateUTC).toISOString()}`);

          // Check if start date is valid relative to today
          if (isNaN(startDateUTC) || startDateUTC > todayUTC) {
               pastGamesList.innerHTML = `<li>‘Ω’°’≤’•÷Ä’® ’Ω’Ø’Ω’æ’∏÷Ç’¥ ’•’∂ ${START_DATE_STRING}-’´÷Å÷â</li>`;
               pastGamesPopup.style.display = 'flex';
               return;
          }

          // Calculate offset for today based on UTC difference
          const todayOffset = Math.floor((todayUTC - startDateUTC) / (1000 * 60 * 60 * 24));
          // Today's game number is offset + 1
          const todaysGameNumber = todayOffset + 1;

          // console.log(`[Popup UTC] Today Offset: ${todayOffset}, Today's Game Number: ${todaysGameNumber}`);

          // Check if there are any games to list (today's game number should be >= 1)
          if (todaysGameNumber < 1) {
              // Should not happen if start date is valid and not in the future
              pastGamesList.innerHTML = '<li>‘Ω’°’≤’•÷Ä’´ ÷Å’∏÷Ç÷Å’°’Ø’® ’Ω’ø’•’≤’Æ’•’¨’´’Ω ’Ω’≠’°’¨÷â</li>';
          } else {
              const items = []; // Store items to reverse later
              // console.log(`[Popup UTC] Loop range: i = 1 to ${todaysGameNumber}`); // Adjusted log

              // *** Loop from game 1 up to AND INCLUDING today's game number ***
              for (let i = 1; i <= todaysGameNumber; i++) {
                  // Calculate the offset for game number 'i'
                  const gameOffset = i - 1; // Game #1 -> offset 0, Game #19 -> offset 18
                  // Calculate the date for this offset in UTC milliseconds
                  const gameDateUTC = startDateUTC + (gameOffset * 1000 * 60 * 60 * 24);
                  // Create a Date object from UTC milliseconds to easily extract components
                  const gameDate = new Date(gameDateUTC);

                  // Get date components using UTC methods
                  const year = gameDate.getUTCFullYear();
                  const month = String(gameDate.getUTCMonth() + 1).padStart(2, '0');
                  const day = String(gameDate.getUTCDate()).padStart(2, '0');
                  const gameDateString = `${year}-${month}-${day}`; // Format as YYYY-MM-DD

                  // Log the last generated item for verification
                  // if (i === todaysGameNumber) {
                  //      console.log(`[Popup UTC] Last item generated (Today): i=${i}, offset=${gameOffset}, date=${gameDateString}`);
                  // }

                  // Create list item and link
                  const li = document.createElement('li');
                  const a = document.createElement('a');
                  a.href = `${window.location.pathname}?date=${gameDateString}`; // Link uses the calculated YYYY-MM-DD
                  a.textContent = `‘Ω’°’≤ #${i} - ${gameDateString}`;
                  a.title = `‘¥’´’ø’•’¨ ${gameDateString} ’≠’°’≤’®`;

                  // Optionally, add a visual indicator if this entry is for the currently viewed game
                  const isThisTheCurrentlyViewedGame = effectiveDate && gameDateUTC === effectiveDate.getTime();
                  if (isThisTheCurrentlyViewedGame) {
                      a.style.fontWeight = 'bold'; // Example: Make the current game link bold
                      // a.textContent += " (’®’∂’©’°÷Å’´’Ø)"; // Example: Add text indicator
                  }


                  li.appendChild(a);
                  items.push(li); // Add to array
              }
              // Reverse the list so today's game is at the top
              items.reverse().forEach(item => pastGamesList.appendChild(item));
          }

          pastGamesPopup.style.display = 'flex'; // Show the popup
      } catch (e) {
          console.error("Error generating past games list:", e);
          pastGamesList.innerHTML = '<li>’ä’°’ø’¥’∏÷Ç’©’µ’∏÷Ç’∂’® ’¢’•’º’∂’•’¨’´’Ω ’Ω’≠’°’¨ ’ø’•’≤’´ ’∏÷Ç’∂’•÷Å’°’æ÷â</li>';
          pastGamesPopup.style.display = 'flex'; // Show popup even if error generating list
      }
  }

  function closePastGamesPopup() {
      pastGamesPopup.style.display = 'none';
  }


  // --- Dynamic Board Sizing ---
  function adjustBoardSize() {
      // (This function remains the same as your provided version)
      const viewportHeight = window.innerHeight;
      const h1 = document.querySelector('h1'); // Part of header-container now
      const headerContainer = document.querySelector('.header-container'); // Use container height
      const subtitle = document.querySelector('.subtitle');
      const keyboard = document.getElementById('keyboard');
      const mainContentStyle = getComputedStyle(mainContent);
      const boardContainer = document.querySelector('.board-container');

      // Adjust element checks if structure changed significantly
      if (!headerContainer || !subtitle || !keyboard || !boardContainer || !boardElement || !mainContent) {
          console.warn("adjustBoardSize: One or more elements not found.");
          return;
      }

      let nonBoardHeight = 0;
      // Use headerContainer instead of just h1
      const flowElements = [headerContainer, subtitle, keyboard];
      flowElements.forEach(el => {
          const style = getComputedStyle(el);
          nonBoardHeight += el.offsetHeight;
          nonBoardHeight += parseFloat(style.marginTop) || 0;
          nonBoardHeight += parseFloat(style.marginBottom) || 0;
      });

       nonBoardHeight += parseFloat(mainContentStyle.paddingTop) || 0;
       nonBoardHeight += parseFloat(mainContentStyle.paddingBottom) || 0;

      const boardContainerStyle = getComputedStyle(boardContainer);
      const boardContainerMarginTop = parseFloat(boardContainerStyle.marginTop) || 0;
      const boardContainerMarginBottom = parseFloat(boardContainerStyle.marginBottom) || 0;
      const boardContainerVerticalMargins = boardContainerMarginTop + boardContainerMarginBottom;

      const availableBoardHeight = viewportHeight - nonBoardHeight - boardContainerVerticalMargins;

      const boardStyle = getComputedStyle(boardElement);
      const rowGap = parseFloat(boardStyle.rowGap) || 0;
      const columnGap = parseFloat(boardStyle.columnGap) || 0;

      const buffer = 8;
      const maxTileSizeBasedOnHeight = Math.max(0, (availableBoardHeight - (MAX_ROWS - 1) * rowGap - buffer) / MAX_ROWS);
      const requiredBoardWidthFromHeight = (WORD_LENGTH * maxTileSizeBasedOnHeight) + (WORD_LENGTH - 1) * columnGap;

      const tempMaxWidth = boardContainer.style.maxWidth;
      boardContainer.style.maxWidth = '';
      const cssMaxWidthForBoardContainer = parseFloat(getComputedStyle(boardContainer).maxWidth);
      // Ensure main content's max-width is also considered if it's smaller
      const mainContentMaxWidth = parseFloat(mainContentStyle.maxWidth) || Infinity;
      const finalCssMaxWidth = Math.min(
            isNaN(cssMaxWidthForBoardContainer) ? Infinity : cssMaxWidthForBoardContainer,
            mainContentMaxWidth
          );
      boardContainer.style.maxWidth = tempMaxWidth;

      const targetWidth = Math.min(requiredBoardWidthFromHeight, finalCssMaxWidth);

      const minReasonableTileSize = 30;
      const minReasonableBoardWidth = (WORD_LENGTH * minReasonableTileSize) + (WORD_LENGTH - 1) * columnGap;

      if (targetWidth > minReasonableBoardWidth && targetWidth > 0) {
          boardContainer.style.maxWidth = `${targetWidth}px`;
      } else {
           boardContainer.style.maxWidth = ''; // Revert to CSS if calculated is too small or invalid
           // console.log(`Reverted to CSS max-width. Calculated target: ${targetWidth.toFixed(1)}px`);
      }
  }


  // --- Start the game ---
  document.addEventListener('DOMContentLoaded', () => {
      init();
      adjustBoardSize();
  });
  window.addEventListener('resize', adjustBoardSize);

</script>

</body>
</html>
