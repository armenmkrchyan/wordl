<!DOCTYPE html>
<html lang="hy">
<head>
  <meta charset="UTF-8" />
  <meta property="og:title" content="Wordle 🇦🇲" />
  <meta property="og:description" content="Գուշակեք օրվա բառը" />
  <meta property="og:image" content="wordle.png" />
  <meta property="og:url" content="https://wordle.am" />
  <meta property="og:type" content="website" />
  <meta property="og:site_name" content="Wordle 🇦🇲">
  <meta property="og:locale" content="hy_AM">
  <meta name="keywords" content="Wordle, Հայերեն, Խաղ, Բառ, Բառախաղ, Armenian Wordle, Օրվա բառ, Armblog, Armen Mkrtchyan">
  <meta itemprop="image" content="https://wordle.am/wordle.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="author" content="Armen Mkrtchyan">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="Wordle 🇦🇲">
  <meta name="twitter:description" content="Գուշակեք օրվա բառը">
  <meta name="twitter:image" content="https://wordle.am/wordle.png">
  <meta name="twitter:url" content="https://wordle.am">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0"/>
  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
  <link rel="manifest" href="/site.webmanifest">
  <title>Wordle 🇦🇲</title>
  <style>
    /* --- Global Reset & Box Sizing --- */
    html {
        box-sizing: border-box;
        height: 100%;
        overflow-y: auto;
    }
    *, *:before, *:after {
        box-sizing: inherit;
    }

    html, body {
        min-height: 100%;
        margin: 0;
        padding: 0;
    }
    body {
      font-family: sans-serif;
      display: flex;
      flex-direction: column; /* Default: .main-content above #keyboard */
      align-items: center;
      transition: background 0.3s, color 0.3s;
      background-color: var(--bg-color, #fff);
      color: var(--text-color, #000);
    }

    :root {
        --bg-color: #fff;
        --text-color: #000;
        --tile-border-empty: #aaa;
        --tile-border-filled: #666;
        --key-bg: #d3d6da;
        --key-text: #1a1a1b;
        --correct-bg: #538d4e;
        --present-bg: #b59f3b;
        --absent-bg: #3a3a3c;
        --delete-key-bg: #dc3545;
        --enter-key-bg: #538d4e;
        --tile-text-light: #000;
        --tile-text-dark: #fff;
        --link-color: #007bff;
        --popup-bg: #f8f9fa;
        --popup-text: #212529;
        --popup-border: #dee2e6;
        --popup-overlay-bg: rgba(0, 0, 0, 0.5);
        --popup-close-color: #6c757d;
        --popup-link-hover-bg: #e9ecef;
    }

    .main-content { /* Default: contains header, buttons, message, board */
        flex: 1 1 auto;
        width: 100%;
        display: flex;
        flex-direction: column;
        align-items: center;
        max-width: 550px;
        margin-left: auto;
        margin-right: auto;
        padding-left: 5px;
        padding-right: 5px;
        padding-top: 10px; /* Provides initial space for header */
        padding-bottom: 10px;
        align-self: center;
        position: relative; /* For its absolute children (buttons, message-container if fixed) */
    }

    .header-container { /* Child of .main-content by default */
        display: flex;
        align-items: baseline;
        justify-content: center;
        flex-wrap: wrap;
        gap: 0.5em;
        margin-top: 0; /* .main-content parent has padding-top */
        margin-bottom: 2px;
        width: 100%;
    }

    h1 {
      margin: 0;
      font-size: 1.5rem;
      white-space: nowrap;
    }

    #game-number-display {
        font-size: 0.9rem;
        font-weight: bold;
        color: var(--link-color);
        cursor: pointer;
        text-decoration: none;
        border-bottom: 1px dashed var(--link-color);
        margin-left: 5px;
        white-space: nowrap;
    }
    #game-number-display:hover {
        text-decoration: none;
        border-bottom-style: solid;
    }
    .dark #game-number-display {
        color: var(--link-color);
        border-bottom-color: var(--link-color);
    }

    .subtitle { /* Child of .main-content by default */
        width: 100%;
        text-align: center;
        font-size: 0.9rem;
        color: #777;
        margin-top: 0;
        margin-bottom: 5px;
    }
    .dark .subtitle { color: #aaa; }
    .subtitle a { color: inherit; }
    .subtitle a:hover { text-decoration: underline; }

    /* ORIGINAL DEFAULT POSITIONING for Toggle Buttons (Children of .main-content) */
    .main-content > #toggle-theme {
      position: absolute;
      top: 10px; /* Relative to .main-content padding edge */
      right: 10px; /* Relative to .main-content padding edge */
      margin-bottom: 0;
      padding: 6px 10px;
      font-size: 0.9rem;
      border-radius: 5px;
      cursor: pointer;
      border: 1px solid #ccc;
      background-color: #eee;
      color: #333;
      z-index: 20;
    }
    .dark .main-content > #toggle-theme {
        background-color: #333;
        color: white;
        border-color: #555;
    }

    .main-content > #toggle-layout {
      position: absolute;
      top: 10px; /* Relative to .main-content padding edge */
      left: 10px; /* Relative to .main-content padding edge */
      margin-bottom: 0;
      padding: 6px 7px;
      font-size: 0.9rem;
      border-radius: 5px;
      cursor: pointer;
      border: 1px solid #ccc;
      background-color: #eee;
      color: #333;
      z-index: 20;
       min-width: 80px;
       text-align: center;
    }
     .dark .main-content > #toggle-layout {
        background-color: #333;
        color: white;
        border-color: #555;
    }

    .board-container {
        display: flex;
        justify-content: center;
        align-items: center;
        width: 100%;
        margin: 8px 0;
        flex: 1 1 auto;
        min-height: 0;
    }

    .board {
      display: grid;
      grid-template-rows: repeat(6, 1fr);
      grid-gap: 4px;
      width: 100%;
    }

    .row {
        display: grid;
        grid-template-columns: repeat(5, 1fr);
        grid-gap: 4px;
    }

    .tile {
      width: 100%;
      aspect-ratio: 1 / 1;
      border: 2px solid var(--tile-border-empty);
      font-size: clamp(1.5rem, 6vw, 2rem);
      font-weight: bold;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      text-transform: lowercase;
      color: var(--tile-text-light);
      background-color: var(--bg-color);
      transition: background-color 0.3s, border-color 0.3s;
    }
    .tile > div { display: flex; align-items: center; justify-content: center; width: 100%; height: 100%; color: inherit; }
    .tile.filled { border-color: var(--tile-border-filled); }
    .tile.correct { background-color: var(--correct-bg); color: var(--tile-text-dark); border-color: var(--correct-bg); }
    .tile.present { background-color: var(--present-bg); color: var(--tile-text-dark); border-color: var(--present-bg); }
    .tile.absent { background-color: var(--absent-bg); color: var(--tile-text-dark); border-color: var(--absent-bg); }

    #keyboard { /* Sibling of .main-content */
      flex-shrink: 0;
      width: 100%;
      max-width: 550px;
      margin-left: auto;
      margin-right: auto;
      display: flex;
      flex-direction: column;
      gap: 4px;
      padding: 0 3px;
      margin-top: 5px;
      margin-bottom: 20px;
      align-self: center;
    }

    #keyboard-top-row { display: grid; grid-template-columns: 1fr 1fr; gap: 3px; }
    #keyboard-main-grid { display: grid; grid-template-columns: repeat(8, 1fr); gap: 3px; }
    body[data-keyboard-layout="phonetic"] #keyboard-main-grid { grid-template-columns: repeat(10, 1fr); gap: 3px; }
    .key.placeholder { background: transparent; pointer-events: none; border-color: transparent; visibility: hidden; }
    body[data-keyboard-layout="phonetic"] #keyboard-main-grid .key.placeholder { visibility: visible; background: rgba(0,0,0,0.03); }

    .key {
      min-height: 40px;
      font-size: clamp(1.2rem, 5vw, 1.8rem);
      font-weight: bold;
      border: 3px solid transparent;
      border-radius: 4px;
      background-color: var(--key-bg);
      color: var(--key-text);
      cursor: pointer;
      transition: background-color 0.2s, color 0.2s, border-color 0.2s;
      display: flex; justify-content: center; align-items: center;
      user-select: none; touch-action: manipulation; text-transform: lowercase;
      padding: 0; min-width: 0;
    }
    .key:hover { filter: brightness(90%); }
    .key.enter, .key.delete {
      font-size: clamp(0.9rem, 3.5vw, 1.2rem); color: white;
      border-width: 3px; border-style: solid;
    }
    .key.enter { background-color: var(--enter-key-bg); border-color: var(--enter-key-bg); white-space: nowrap; }
    .key.delete { background-color: var(--delete-key-bg); border-color: var(--delete-key-bg); white-space: nowrap; }
    .key.correct { background-color: var(--correct-bg); color: var(--tile-text-dark); border-color: transparent; }
    .key.present { background-color: var(--present-bg); color: var(--tile-text-dark); border-color: transparent; }
    .key.absent { background-color: var(--absent-bg); color: var(--tile-text-dark); border-color: transparent; }
    .key.correct.has-present { border-width: 3px; border-style: solid; border-color: #ffff00; }

    .message-container { /* Positioned fixed relative to viewport */
        position: fixed;
        top: 70px; left: 50%; transform: translateX(-50%);
        min-height: 30px; z-index: 1000; width: 90%; max-width: 350px;
    }
    .message {
      text-align: center; font-size: 1em; margin-top: 0.5rem; padding: 8px 10px;
      font-weight: bold; background-color: #333; color: white; border-radius: 5px;
      visibility: hidden; opacity: 0; transition: visibility 0s 1.5s, opacity 1.5s linear;
      white-space: normal; word-wrap: break-word;
    }
    .message.show { visibility: visible; opacity: 1; transition: opacity 0.3s linear; }

    .dark {
        --bg-color: #121213; --text-color: #fff;
        --tile-border-empty: #3a3a3c; --tile-border-filled: #565758;
        --key-bg: #818384; --key-text: #dadce0; --tile-text-light: #fff;
        --link-color: #64b5f6; --popup-bg: #2c2c2e; --popup-text: #eaeaeb;
        --popup-border: #444; --popup-overlay-bg: rgba(0, 0, 0, 0.7);
        --popup-close-color: #aaa; --popup-link-hover-bg: #3a3a3c;
    }
    .dark .message { background-color: #eee; color: #121213; }
    .dark .key:hover { filter: brightness(115%); }
    .dark .key.enter:hover, .dark .key.delete:hover { filter: brightness(110%); }
    .dark .key.correct.has-present:hover { filter: brightness(110%); }
    .dark .key.correct { background-color: var(--correct-bg); color: var(--tile-text-dark); border-color: transparent; }
    .dark .key.present { background-color: var(--present-bg); color: var(--tile-text-dark); border-color: transparent; }
    .dark .key.absent { background-color: var(--absent-bg); color: var(--tile-text-dark); border-color: transparent; }
    .dark .key.correct.has-present { border-color: var(--present-bg); }

    /* --- Popup Styles --- */
    .popup-overlay {
        position: fixed; top: 0; left: 0; width: 100%; height: 100%;
        background-color: var(--popup-overlay-bg); display: flex;
        justify-content: center; align-items: center; z-index: 900; padding: 15px;
    }
    .popup-content {
        background-color: var(--popup-bg); color: var(--popup-text); padding: 20px;
        border-radius: 8px; border: 1px solid var(--popup-border); max-width: 90%;
        width: 400px; max-height: 80vh; overflow-y: auto; position: relative;
        box-shadow: 0 4px 15px rgba(0,0,0,0.2);
    }
    .popup-content h2 { margin-top: 0; margin-bottom: 15px; text-align: center; font-size: 1.3rem; }
    .popup-close { position: absolute; top: 10px; right: 15px; font-size: 1.8rem; font-weight: bold; color: var(--popup-close-color); cursor: pointer; line-height: 1; }
    .popup-close:hover { color: var(--text-color); }
    #past-games-list { list-style: none; padding: 0; margin: 0; }
    #past-games-list li a { display: block; padding: 8px 12px; margin-bottom: 5px; background-color: transparent; color: var(--link-color); text-decoration: none; border-radius: 4px; transition: background-color 0.2s; font-size: 0.95rem; }
    .dark #past-games-list li a { color: var(--link-color); }
    #past-games-list li a:hover { background-color: var(--popup-link-hover-bg); text-decoration: underline; }

    @keyframes shake {
      0%, 100% { transform: translateX(0); }
      10%, 30%, 50%, 70%, 90% { transform: translateX(-5px); }
      20%, 40%, 60%, 80% { transform: translateX(5px); }
    }
    .shake { animation: shake 0.6s ease-in-out; }

    /* Media Query for very small/short screens (PORTRAIT small) */
    @media (max-width: 340px), (max-height: 600px) and (orientation: portrait) {
        .main-content { padding-top: 8px; padding-bottom: 5px; }
        .header-container { margin-top: 0; }
        h1 { font-size: 1.3rem; }
        #game-number-display { font-size: 0.8rem; }
        .subtitle { margin-bottom: 3px; }
        .board-container { margin: 5px 0; }
        .board, .row { grid-gap: 3px; }
        #keyboard { gap: 3px; padding: 0 2px; margin-top: 3px; margin-bottom: 15px; }
        #keyboard-main-grid, #keyboard-top-row { gap: 2px; }
        body[data-keyboard-layout="phonetic"] #keyboard-main-grid { grid-template-columns: repeat(10, 1fr); gap: 2px; }
        .key { min-height: 36px; font-size: clamp(1rem, 3.5vw, 1.3rem); }
        .key.enter, .key.delete { font-size: clamp(0.8rem, 3vw, 1.1rem); }
        .main-content > #toggle-theme { padding: 4px 7px; font-size: 0.8rem; top: 2px; right: 5px; }
        .main-content > #toggle-layout { padding: 4px 7px; font-size: 0.8rem; top: 2px; left: 5px; min-width: 70px; }
        .message-container { top: 60px; }
        .popup-content { width: 95%; padding: 15px; }
        .popup-content h2 { font-size: 1.2rem; }
        #past-games-list li a { font-size: 0.9rem; padding: 6px 10px; }
    }

        /* --- Horizontal Orientation Fix for Mobile (using absolute positioning for header parts) --- */
    @media (orientation: landscape) and (max-height: 600px) {
        html { height: 100svh; max-height: 100svh; overflow: hidden; }
        body {
            height: 100%; max-height: 100%; overflow: hidden;
            display: flex; flex-direction: row; /* .main-content (left) | #keyboard (right) */
            align-items: stretch; justify-content: center;
            padding: 3px; gap: 8px; box-sizing: border-box;
            position: relative; /* Crucial for absolute positioning of header elements from .main-content */
        }
        
        /* Define landscape positioning guides (can be thought of as columns) */
        /* For simplicity, let's use direct calc() values, assuming a ~45/55 or 50/50 split */
        /* Right "column" for header and keyboard conceptually starts after left column and gap */
        /* Left column (.main-content) is flex: 1 1 45% */
        /* Right column (#keyboard) is flex: 1 1 50% */
        /* Gap is 8px. Body padding is 3px. */

        /* Let's calculate a starting point for the right-side content area (header & keyboard) */
        /* Approx left edge of right content area = left_column_width + gap + body_padding_left */
        /* This is still an estimation game for absolute positioning. 
           A common strategy is to make right "column" take a percentage width and position from right. */


        /* Left Column: BOARD + MESSAGE_CONTAINER (message container positioning adapted) */
        .main-content { /* This is the LEFT column, board and messages */
            flex: 1 1 45%; max-width: 380px; height: 100%;
            display: flex; flex-direction: column;
            align-items: center; justify-content: flex-start;
            padding: 0; margin: 0; overflow: hidden;
            position: relative; 
        }

        .main-content > .message-container, .message-container {
            position: absolute;
            top: clamp(1px, 0.2svh, 3px);
            left: 50%;
            transform: translateX(-50%);
            width: 90%;
            max-width: calc(100% - 10px);
            min-height: auto;
            z-index: 100;
        }
        .message-container .message {
            font-size: clamp(0.7rem, 1.7svh, 0.9rem);
            padding: clamp(3px, 0.6svh, 5px) clamp(5px, 0.8svh, 7px);
            margin-top: 0;
        }


        .board-container {
            flex-grow: 1; width: 100%; max-width: 100%;
            display: flex; align-items: center; justify-content: center;
            margin: 0; 
            margin-top: clamp(30px, 5svh, 40px); /* Space below message container */
            min-height: 0; overflow: hidden;
        }
        .board {
            display: grid; grid-template-rows: repeat(6, 1fr);
            grid-gap: clamp(2px, 0.4svh, 3px);
            height: 100%; width: auto; aspect-ratio: 5 / 6.15; max-width: 100%;
        }
        .tile {
            width: 100%; aspect-ratio: 1 / 1; border-width: 1px;
            font-size: clamp(0.8rem, 2.6svh, 1.5rem);
            display: flex; align-items: center; justify-content: center;
        }
        .tile > div { line-height: 1; }

        /* == HEADER ELEMENTS (Children of .main-content in HTML): Repositioned to top-right area of BODY == */
        .main-content > .header-container,
        .main-content > .subtitle,
        .main-content > #toggle-layout,
        .main-content > #toggle-theme {
            position: absolute; /* Relative to body */
            z-index: 30;
            /* Ensure their default 'left' from portrait is overridden if needed */
            left: auto; 
            right: auto; 
        }

        /* The header TEXT blocks (H1/Game#, Subtitle) */
        /* These will span the width of the keyboard column visually */
        .main-content > .header-container,
        .main-content > .subtitle {
            /* Position from right edge of screen towards the middle */
            right: 3px; /* Body padding on the right */
            /* Assume the keyboard (#keyboard) will have flex-basis 50% and max-width 480px */
            /* The text block should match this visually */
            width: min(calc(50% - 3px - 4px), 470px); /* 50% viewport - right padding - half inter-column gap; capped */
            /* If keyboard is 50%, then roughly left edge would be "50% + 4px (half_gap) + 3px (body_padding)" from LEFT */
            /* So, for blocks to be *centered* above keyboard, their "left" could be set similarly */
            left: calc(50% + 4px + 3px); /* Start from middle + half_gap + body padding */
            text-align: center;
            padding-left: 5px; padding-right: 5px; /* Inner padding for the text blocks */
        }

        .main-content > .header-container {
            top: clamp(3px, 0.5svh, 5px); /* Align to top of body content area */
            margin-top: 0; margin-bottom: 0;
            justify-content: center;
        }
        .main-content > .header-container h1 { font-size: clamp(0.9rem, 2.5svh, 1.2rem); }
        .main-content > .header-container #game-number-display { font-size: clamp(0.6rem, 1.8svh, 0.8rem); }

        .main-content > .subtitle {
            top: calc(clamp(3px, 0.5svh, 5px) + clamp(1.1rem, 3svh, 1.5rem)); /* Below H1 block */
            margin-top: 0; margin-bottom: 0;
            font-size: clamp(0.6rem, 1.7svh, 0.75rem);
        }

        /* The TOGGLE BUTTONS will be at the top corners of the area defined by keyboard column */
        .main-content > #toggle-layout { /* Top-left of keyboard area */
            top: clamp(3px, 0.5svh, 5px);
            /* Position it at the "left" of the conceptual right column */
            left: calc(50% + 4px + 3px + clamp(1px, 0.2svh, 3px)); /* middle + half_gap + body_pad + small_offset */
            right: auto;
            font-size: clamp(0.7rem, 1.8svh, 0.9rem);
            padding: clamp(2px, 0.6svh, 4px) clamp(3px, 0.8svh, 6px);
        }
        .main-content > #toggle-theme { /* Top-right of screen / keyboard area */
            top: clamp(3px, 0.5svh, 5px);
            right: clamp(3px, 0.5svh, 5px); /* Body right padding + small_offset */
            left: auto;
            font-size: clamp(0.7rem, 1.8svh, 0.9rem);
            padding: clamp(2px, 0.6svh, 4px) clamp(3px, 0.8svh, 6px);
        }


        /* Right Column: KEYBOARD ONLY (header visually above it via absolute positioning) */
        #keyboard {
            flex: 1 1 50%; max-width: 480px; height: 100%;
            display: flex; flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 0 2px;
            margin: 0;
            /* Make space for the absolutely positioned header items. THIS IS KEY! */
            padding-top: clamp(50px, 9svh, 65px); /* Increase if header content is taller */
        }
        #keyboard #keyboard-top-row,
        #keyboard #keyboard-main-grid {
            width: 100%;
            gap: clamp(2px, 0.4svh, 3px);
        }
        
        .key {
            min-height: clamp(25px, 4.5svh, 36px);
            font-size: clamp(0.7rem, 2.2svh, 1.1rem);
            border-radius: 3px;
        }
        .key.enter, .key.delete {
             font-size: clamp(0.6rem, 1.8svh, 0.9rem);
        }
    }
  </style>
</head>
<body>
  <div class="main-content">
      <!-- Header Container (TITLE AND GAME NUMBER) - BACK INSIDE .main-content -->
      <div class="header-container">
         <h1>Wordle <img src="flag.png" alt="🇦🇲" style="height: 0.7em; vertical-align: middle;"></h1>
         <span id="game-number-display">Խաղ #...</span>
      </div>
      <!-- Subtitle - BACK INSIDE .main-content -->
      <p class="subtitle">by <a href="https://www.armblog.net" target="_blank">Armen Mkrtchyan</a></p>

      <!-- Controls (THEME AND LAYOUT BUTTONS) - BACK INSIDE .main-content -->
      <button id="toggle-theme">🌗</button>
      <button id="toggle-layout"></button>

      <!-- Message Container -->
      <div class="message-container">
         <div id="message" class="message"></div>
      </div>

      <!-- Board -->
      <div class="board-container">
         <div class="board" id="board"></div>
      </div>
  </div> <!-- End of .main-content -->

  <!-- Keyboard (Sibling of .main-content) -->
  <div id="keyboard">
      <div id="keyboard-top-row"></div>
      <div id="keyboard-main-grid"></div>
  </div>

  <!-- Past Games Popup -->
  <div id="past-games-popup" class="popup-overlay" style="display: none;">
    <div class="popup-content">
      <span class="popup-close" id="popup-close-button">×</span>
      <h2>Նախորդ խաղերը</h2>
      <ul id="past-games-list">
        <!-- Dynamically populated -->
        <li><a href="#">Խաղ #1 - 2025-05-02</a></li>
        <li><a href="#">Խաղ #2 - 2025-05-03</a></li>
      </ul>
    </div>
  </div>


<script>
  const boardElement = document.getElementById('board');
  const keyboardTopRowElement = document.getElementById('keyboard-top-row');
  const keyboardMainGridElement = document.getElementById('keyboard-main-grid');
  const keyboardElement = document.getElementById('keyboard');
  const toggleBtnTheme = document.getElementById('toggle-theme');
  const toggleBtnLayout = document.getElementById('toggle-layout');
  const messageElement = document.getElementById('message');
  const mainContent = document.querySelector('.main-content'); // Element for board primarily
  const gameNumberDisplay = document.getElementById('game-number-display');
  const pastGamesPopup = document.getElementById('past-games-popup');
  const pastGamesList = document.getElementById('past-games-list');
  const popupCloseButton = document.getElementById('popup-close-button');

  // --- Constants ---
  const WORD_LENGTH = 5;
  const MAX_ROWS = 6;
  const ENTER_KEY = 'ընդունել';
  const DELETE_KEY = 'ջնջել';
  const LOCAL_STORAGE_LAYOUT_KEY = 'armenianWordleLayout';
  const LOCAL_STORAGE_HISTORY_KEY = 'armenianWordleHistory';
  const START_DATE_STRING = "2025-05-02";

  // --- Word List ---
  const WORDS = ['ավյուն', 'արժեք', 'կարագ', 'կաղնի', 'ծագում', 'խելոք', 'անգիր', 'խաղալ', 'հասուն', 'ձողիկ', 'վարիչ', 'ոսկոր', 'խանութ', 'զնդան', 'միջոց', 'ժյուրի', 'եղինջ', 'վեզիր', 'նյարդ', 'ազնիվ', 'անեծք', 'տեսակ', 'պառավ', 'գնորդ', 'հնդիկ', 'չղջիկ', 'պանդա', 'կռունկ', 'մեռած', 'հատոր', 'ոսկյա', 'պարեն', 'կարծր', 'լորտու', 'մոծակ', 'կամաց', 'էկրան', 'գազար', 'համեղ', 'կապիկ', 'ֆոտոն', 'գմբեթ', 'տիտան', 'անգետ', 'սասան', 'բրդյա', 'թախիծ', 'հաշիշ', 'ճիրան', 'կախիչ', 'վրացի', 'գաճաճ', 'կայան', 'կարապ', 'լրտես', 'հոսել', 'օազիս', 'ուրբաթ', 'անմիտ', 'ըմպել', 'ծորալ', 'ակցիզ', 'կշեռք', 'թռչող', 'ալևոր', 'ննջել', 'փական', 'անցում', 'հերոս', 'խնամք', 'ուզբեկ', 'կարիք', 'բրդոտ', 'էթիկա', 'ակունք', 'մալուխ', 'ծղրիդ', 'մետրո', 'ծպտուն', 'աբխազ', 'երկար', 'բոլուկ', 'թիթեռ', 'եռյակ', 'սկիզբ', 'ուտեստ', 'ականջ', 'մենակ', 'սուտակ', 'ֆագոտ', 'թթենի', 'օպերա', 'ուղևոր', 'մոլոր', 'դիմակ', 'դեղին', 'քանակ', 'բարդի', 'տարեց', 'թշշալ', 'հատիկ', 'նստել', 'խրճիթ', 'կյանք', 'մկնիկ', 'պիթոն', 'ցնորք', 'ապրել', 'քննել', 'ծորան', 'սպիրտ', 'չեչեն', 'թավիշ', 'թոշակ', 'ֆերմա', 'լողափ', 'մռայլ', 'գունատ', 'աղցան', 'ծամոն', 'իսլամ', 'կարող', 'մածուն', 'թիրախ', 'հուլիս', 'ցուցակ', 'շիրիմ', 'ներել', 'շնչեղ', 'երեխա', 'տիկին', 'ռաբիզ', 'անտիկ', 'պարոն', 'քոթոթ', 'բաժին', 'տզրուկ', 'կիսատ', 'կռնատ', 'մողես', 'հարավ', 'փակել', 'փոխել', 'նիզակ', 'շուշան', 'տոնել', 'բիբար', 'թափոն', 'տնտես', 'մկրատ', 'հանում', 'կեֆիր', 'փրկիչ', 'սերիա', 'ակնոց', 'բալիկ', 'կմախք', 'դակիչ', 'որսալ', 'ջահել', 'կոպիտ', 'բարիք', 'անթիվ', 'առողջ', 'բովել', 'հյուսն', 'անբան', 'թռչել', 'հովազ', 'կոշիկ', 'ողբալ', 'մումիա', 'կանոն', 'ճաշակ', 'բաժակ', 'բանուկ', 'ամայի', 'քարոզ', 'մոդել', 'վճռել', 'վասալ', 'նեղուց', 'ծիրան', 'կավատ', 'վարազ', 'խլուրդ', 'ասորի', 'աղոթք', 'ոչինչ', 'բկլիկ', 'դահուկ', 'շեփոր', 'վազել', 'եզակի', 'սիգար', 'հռչակ', 'սրվակ', 'հմայք', 'տարափ', 'վահան', 'մաֆիա', 'խելառ', 'գետին', 'սիրող', 'ավելի', 'նեխուր', 'ժողով', 'բռնակ', 'թովիչ', 'ճզմել', 'կոտեմ', 'կատար', 'հովիվ', 'մինչև', 'բազուկ', 'եղյամ', 'ընկեր', 'բեկոր', 'դահիճ', 'երևակ', 'քլունգ', 'երգիչ', 'միջուկ', 'ատլաս', 'սիսեռ', 'լոլիկ', 'ապրիլ', 'թևնոց', 'տատիկ', 'սմբակ', 'անզեն', 'դանակ', 'փեթակ', 'ջիհադ', 'անուրջ', 'արթուն', 'սիրած', 'մտրուկ', 'շքերթ', 'հուշում', 'կոբրա', 'ելույթ', 'վաղուց', 'կրքոտ', 'կանեփ', 'աղքատ', 'տաքսի', 'նամակ', 'խոժոռ', 'խռպոտ', 'կայուն', 'երաշտ', 'ամրակ', 'կաուրի', 'պահոց', 'ձվաձև', 'հաճար', 'հուժկու', 'տավար', 'ռուբլի', 'վզկապ', 'հատուկ', 'զորեղ', 'աղանձ', 'դրույթ', 'թռչուն', 'գիտակ', 'սրբիչ', 'քաղաք', 'հատում', 'ածելի', 'կուրծք', 'համար', 'թութակ', 'հպարտ', 'կտրոն', 'անձավ', 'հազալ', 'պոչատ', 'չորոց', 'աբեղա', 'տիպար', 'բնազդ', 'սրունք', 'թենիս', 'քաղցր', 'թզենի', 'խաղաղ', 'խորան', 'րաբբի', 'քամիչ', 'ծորակ', 'գուշակ', 'սանիկ', 'փաթիլ', 'պեպեն', 'քանոն', 'խստիվ', 'առնետ', 'կարել', 'պնդել', 'սնոտի', 'հրդեհ', 'օրրան', 'շապիկ', 'ուղերձ', 'դարակ', 'ժանիք', 'քնքուշ', 'շինել', 'մեդալ', 'կիթառ', 'ջրհոս', 'երդիկ', 'նզովք', 'հազար', 'արծաթ', 'բացիլ', 'ճկույթ', 'գավառ', 'կավիճ', 'լարում', 'սոխուկ', 'կաթսա', 'ատաղձ', 'մեթոդ', 'կռվել', 'ծիծակ', 'լեմուր', 'ներուժ', 'ցնցում', 'ջնջել', 'պանիր', 'մասոն', 'կոտոշ', 'մզկիթ', 'առյուծ', 'ծիծաղ', 'գնդիկ', 'կաշվե', 'ռեհան', 'խնդիր', 'արմատ', 'լողալ', 'աղյուս', 'դիմել', 'պատիվ', 'համառ', 'պղպեղ', 'գրպան', 'հիշել', 'թրջել', 'նախիր', 'ռեժիմ', 'կնճիռ', 'գնացք', 'սնդիկ', 'գետակ', 'տիպիկ', 'զվարթ', 'ղազախ', 'բացիկ', 'խմիչք', 'մեդիա', 'սակավ', 'պարապ', 'վառիչ', 'գիլաս', 'գազան', 'ոստան', 'շփվել', 'երինջ', 'անդամ', 'եղունգ', 'միայն', 'մարել', 'ծարավ', 'լացող', 'պարան', 'քուռակ', 'անտուն', 'դժգոհ', 'նարդի', 'հնչել', 'ցորեն', 'կոմիկ', 'թմրած', 'ձյուդո', 'կամար', 'իներտ', 'երեկո', 'թշվառ', 'չարիք', 'կնքել', 'տարազ', 'հաշիվ', 'ճաշել', 'վանող', 'աղվես', 'պիցցա', 'սթրես', 'անսեռ', 'ծանոթ', 'ակումբ', 'արգոն', 'դափնի', 'հոգնա', 'դոլար', 'քաշել', 'լոբբի', 'բալետ', 'ռեգբի', 'ճագար', 'կեսօր', 'նոխազ', 'զոմբի', 'մրցում', 'տեքստ', 'ֆիլտր', 'առվակ', 'փրկել', 'վարակ', 'լակոտ', 'սփռոց', 'տխմար', 'շաքար', 'քիմիկ', 'ձգտել', 'դատել', 'այրել', 'հաչան', 'փխրուն', 'սողալ', 'դադար', 'սմբուկ', 'հասակ', 'սկյուռ', 'լուսան', 'անզոր', 'բմբուլ', 'ճաքել', 'խղճալ', 'հասած', 'բորսա', 'ծարիր', 'պարել', 'սրիկա', 'դելտա', 'ծուղակ', 'կցորդ', 'բարակ', 'հնարք', 'կակաո', 'խոշոր', 'շերեփ', 'ընտիր', 'ժպտալ', 'կաղին', 'բշտիկ', 'թաթար', 'միջին', 'արշավ', 'պտույտ', 'օդաչու', 'կոկոս', 'ֆիզիկ', 'դաջել', 'դիմում', 'իմաստ', 'չոփիկ', 'հրաշք', 'ձագար', 'թալիբ', 'տաբատ', 'արջուկ', 'պարգև', 'ատյան', 'աջլիկ', 'արյուն', 'խաբել', 'զոդում', 'խոսել', 'ռետին', 'սխեմա', 'կոալա', 'նեխել', 'կպչուն', 'բրդել', 'կապիչ', 'կտրուկ', 'կաթոդ', 'աղանդ', 'թմբուկ', 'լազեր', 'մոխիր', 'լուցկի', 'բացիչ', 'սալոր', 'ակորդ', 'քոթուկ', 'սուլոց', 'դդմիկ', 'չինար', 'շլդիկ', 'շռայլ', 'ազդել', 'պալատ', 'բորոտ', 'փետուր', 'չաման', 'դրվագ', 'խղճուկ', 'տոմատ', 'սեզոն', 'շավիղ', 'խավիծ', 'խմբակ', 'ծնունդ', 'բանան', 'նժույգ', 'բժիշկ', 'հումոր', 'դիետա', 'անխնա', 'լուսին', 'չքնաղ', 'վոկալ', 'ստինք', 'խնամի', 'ներկա', 'դրոշմ', 'դրամա', 'ստվար', 'կլիմա', 'անալի', 'խրոխտ', 'բերրի', 'թրթուր', 'սիրուն', 'թերաճ', 'խաչել', 'մանուկ', 'թլփատ', 'դժվար', 'նշտար', 'չփլախ', 'սիրել', 'դալար', 'ծակող', 'զգեստ', 'բախում', 'հոլով', 'բուժիչ', 'հիմար', 'սրճել', 'հեղուկ', 'արխիվ', 'ստվեր', 'ճնշում', 'մելիք', 'հուզիչ', 'կախել', 'բիզոն', 'անդուր', 'ապակի', 'ավլել', 'օծյալ', 'ավարտ', 'օսման', 'հնոտի', 'խշշոց', 'բերել', 'բռնել', 'սնանկ', 'խճուղի', 'վերին', 'լքյալ', 'բացել', 'բեղլու', 'արմավ', 'վիճակ', 'հսկիչ', 'հավատ', 'գտնել', 'երշիկ', 'մտնել', 'կոճակ', 'գտածո', 'մասուր', 'վիպակ', 'կաթիլ', 'հորան', 'ծնվել', 'արկած', 'կորած', 'երանգ', 'սալիկ', 'խրթին', 'լվացք', 'ոստրե', 'պղինձ', 'կողակ', 'փափուկ', 'աղջիկ', 'կվարց', 'կողով', 'բյուջե', 'ծամել', 'մամուլ', 'խարան', 'քրքիջ', 'սյուժե', 'մորթի', 'նիկել', 'ճահիճ', 'խուճապ', 'հավաք', 'կռռալ', 'զննել', 'գալիք', 'լապշա', 'օրենք', 'կեռաս', 'վտանգ', 'հաճախ', 'սապատ', 'գոռոզ', 'հատակ', 'կուզիկ', 'եղեգն', 'վարել', 'դրախտ', 'թթվաշ', 'մանրէ', 'միտում', 'հեծան', 'անդեմ', 'քերել', 'ապագա', 'ձգվել', 'գավաթ', 'ամբոխ', 'սփռել', 'ոռնալ', 'դիպուկ', 'հետին', 'թակոց', 'կակաչ', 'տոննա', 'սպորտ', 'դուդուկ', 'կացին', 'եռակի', 'հրշեջ', 'արդուկ', 'կոչել', 'փրփուր', 'թափոր', 'երգել', 'ակտիվ', 'նիհար', 'ամորֆ', 'մոդեմ', 'դաժան', 'ծղոտե', 'խոնավ', 'նորեկ', 'թվանք', 'քացախ', 'անբիծ', 'երդում', 'տաջիկ', 'աճյուն', 'կրկին', 'քիմիա', 'նավակ', 'թափել', 'թալան', 'կատակ', 'ոչխար', 'թաղել', 'բացում', 'բրինձ', 'փորել', 'երկիր', 'անվախ', 'նետել', 'տափակ', 'չմուշկ', 'լրատու', 'ճոպան', 'մատիտ', 'բոբիկ', 'լյարդ', 'թռիչք', 'պղտոր', 'բացատ', 'տանգո', 'ցավել', 'սուլիչ', 'փարոս', 'պապիկ', 'կանաչ', 'սկսել', 'ցամաք', 'միջատ', 'խաշել', 'չարչի', 'եռանդ', 'բռնիչ', 'ագռավ', 'ածանց', 'ջութակ', 'զրույց', 'անճար', 'մորուք', 'կեռիկ', 'պահակ', 'ցուցում', 'պաշար', 'ծեծել', 'դժոխք', 'ջրվեժ', 'աղմուկ', 'շնչել', 'շրջան', 'դոգմա', 'բլրակ', 'դայակ', 'ռեզուս', 'շիտակ', 'եզերք', 'ձավար', 'մթերք', 'լիզել', 'գոհար', 'վառոդ', 'սենատ', 'բուժում', 'բարձր', 'ճամփա', 'անամպ', 'դոնոր', 'նռնակ', 'հոպոպ', 'փուչիկ', 'շաղափ', 'պարտք', 'տնջրի', 'պուրակ', 'կայսր', 'կարոտ', 'կոկիկ', 'համով', 'ռոբոտ', 'արծիվ', 'մագիլ', 'չափում', 'հավան', 'քավոր', 'խնձոր', 'մորեխ', 'սպասք', 'տակառ', 'տանիք', 'եղևնի', 'գոմեշ', 'կսկիծ', 'զգույշ', 'լիսեռ', 'սելավ', 'առնել', 'ամուրի', 'փշրել', 'խավար', 'կորիզ', 'քննիչ', 'անհոգ', 'ապտակ', 'տավիղ', 'խաղող', 'տոնուս', 'ցերեկ', 'պահել', 'լողակ', 'գումար', 'միզել', 'ողորկ', 'քարափ', 'գոռալ', 'վրձին', 'կորեկ', 'մատաղ', 'ծաղիկ', 'բանակ', 'գերան', 'եղեռն', 'խիզախ', 'անձրև', 'գերաճ', 'հոգոց', 'քամոց', 'նախնի', 'բիրժա', 'գզրոց', 'զատիկ', 'օգնել', 'տապան', 'քամել', 'փայտե', 'կրկես', 'լացել', 'կրճատ', 'վագոն', 'սիբեխ', 'արձան', 'սրինգ', 'համեմ', 'ալյուր', 'կպչել', 'աքլոր', 'կարատ', 'թշշոց', 'ունելի', 'նամազ', 'կապոց', 'փողոց', 'կրծել', 'անմահ', 'ելևէջ', 'դուստր', 'պատիժ', 'ծածուկ', 'բողոք', 'շարան', 'դիտել', 'հեղեղ', 'ցողուն', 'զգաստ', 'տաշեղ', 'թարախ', 'տեսիլ', 'սոված', 'պակաս', 'ստերջ', 'ջեռոց', 'գնդակ', 'դնչիկ', 'նամուս', 'պասիվ', 'գրգիռ', 'վայրի', 'վիսկի', 'ծալել', 'պոպոք', 'կրծող', 'անկոչ', 'պնդուկ', 'կճղակ', 'շաբաթ', 'հունիս', 'մատուռ', 'սամբո', 'հալվա', 'տոկուն', 'նվաստ', 'ամրոց', 'տապակ', 'կիտել', 'օթևան', 'օքսիդ', 'ծավալ', 'մտրակ', 'ոտնակ', 'ոհմակ', 'անկապ', 'ոլորտ', 'շնորհ', 'արարք', 'ջոկատ', 'փաթեթ', 'գալար', 'դղյակ', 'մոտիկ', 'զավակ', 'եղնիկ', 'տարիք', 'տոկոս', 'մանգո', 'խուճուճ', 'աֆղան', 'արճիճ', 'խոցել', 'մեխակ', 'թափուր', 'դրացի', 'հատել', 'զիջող', 'թմբիկ', 'թմբիր', 'սրբել', 'մայիս', 'ճուռակ', 'կոչում', 'պնդում', 'քոչել', 'արդար', 'հնաոճ', 'կարիճ', 'սոխակ', 'զննող', 'ասույթ', 'հովիտ', 'իշխան', 'գագաթ', 'ուռենի', 'կիսել', 'լուծում', 'պիտակ', 'սամբա', 'թանաք', 'ըմբիշ', 'չվերթ', 'մետաղ', 'դեկան', 'անկում', 'անոնս', 'պարեկ', 'արևոտ', 'բրոնզ', 'կաքավ', 'անկախ', 'խնոցի', 'կնճիթ', 'հստակ', 'ծծումբ', 'ժխտել', 'վիշապ', 'թանձր', 'մեռել', 'այսօր', 'սխտոր', 'վզնոց', 'խառատ', 'գուլպա', 'առույգ', 'ծովափ', 'անտառ', 'մրցել', 'օթյակ', 'մազոտ', 'սնունդ', 'չեզոք', 'տաշել', 'ամբար', 'կրունկ', 'գիշեր', 'թառափ', 'մառան', 'ազդակ', 'երկաթ', 'նշենի', 'խոռոչ', 'բերան', 'ճակատ', 'սեղան', 'ստույգ', 'հոկեյ', 'աճուրդ', 'զոդել', 'սպունգ', 'մաքուր', 'սառած', 'արձակ', 'նոտար', 'վառել', 'կտրիճ', 'հասցե', 'շրջել', 'պագել', 'կենաց', 'կրպակ', 'աղերս', 'սավան', 'տվյալ', 'նորից', 'բոսոր', 'չափել', 'սողուն', 'նպաստ', 'կտրել', 'փսխել', 'հրթիռ', 'կնունք', 'կապար', 'չնչին', 'ուլունք', 'լինել', 'զուռնա', 'բլթակ', 'քծնել', 'տեսուչ', 'հնչեղ', 'պտտել', 'ճաղատ', 'սրճեփ', 'թոնիր', 'այրոց', 'խխունջ', 'քոլեջ', 'ասպետ', 'դպրոց', 'տկլոր', 'ռադիո', 'ցավոտ', 'անհամ', 'դոդոշ', 'պատառ', 'բնույթ', 'ստեղն', 'թրմել', 'ջնջոց', 'ծածան', 'մրսել', 'քծնող', 'գարուն', 'տաճար', 'սամիթ', 'քավել', 'լավաշ', 'աքսոր', 'մրրիկ', 'դիմաց', 'զղջում', 'թեփուկ', 'նայել', 'ելնել', 'ամփոփ', 'բոժոժ', 'լքված', 'օրգան', 'դագաղ', 'հալոց', 'ավանդ', 'չոբան', 'սափոր', 'լծորդ', 'տառեխ', 'հարիչ', 'ցնցուղ', 'օմեգա', 'սրբան', 'թաքուն', 'չամիչ', 'ծնծղա', 'ստրուկ', 'անտեր', 'անգին!', 'գուսան'];
  if (WORDS.length === 0) console.error("Word list is empty!");

  // --- Correctly Sorted LOWERCASE Armenian Letters ---
  const sortedLetters = ['ա', 'բ', 'գ', 'դ', 'ե', 'զ', 'է', 'ը','թ', 'ժ', 'ի', 'լ', 'խ', 'ծ', 'կ', 'հ','ձ', 'ղ', 'ճ', 'մ', 'յ', 'ն', 'շ', 'ո','չ', 'պ', 'ջ', 'ռ', 'ս', 'վ', 'տ', 'ր','ց', 'ու', 'փ', 'ք', 'և', 'օ', 'ֆ'];
  const allLetters = [...sortedLetters];

  // --- Keyboard Layout Definitions ---
  const keyboardAlphabeticalLayout = [sortedLetters.slice(0, 8),sortedLetters.slice(8, 16),sortedLetters.slice(16, 24),sortedLetters.slice(24, 32),[...sortedLetters.slice(32), '']];
  const keyboardPhoneticLayout = [['է', 'թ', 'փ', 'ձ', 'ջ', 'և', 'ր', 'չ', 'ճ', 'ժ'],['ք', 'ո', 'ե', 'ռ', 'տ', 'ու', 'ի', 'օ', 'պ', 'խ'],['ա', 'ս', 'դ', 'ֆ', 'գ', 'հ', 'յ', 'կ', 'լ', 'ծ'],['զ', 'ղ', 'ց', 'վ', 'բ', 'ն', 'մ', 'շ', 'ը', '']];
  const LAYOUT_NAMES = {'alphabetical': 'ԱԲԳ ⌨️','phonetic': 'ԱՍԴ ⌨️'};

  // --- Game Date and Word Logic ---
  let effectiveDate;
  let isViewingPastGame = false;
  let targetWord;
  let parsedTarget;
  let dateKey;
  let dayOffset;
  let gameNumber;

  function setupDateAndWord(dateString = null) {
      const startYear = parseInt(START_DATE_STRING.substring(0, 4));
      const startMonth = parseInt(START_DATE_STRING.substring(5, 7)) - 1;
      const startDay = parseInt(START_DATE_STRING.substring(8, 10));
      const startDateUTC = Date.UTC(startYear, startMonth, startDay, 0, 0, 0, 0);
      const now = new Date();
      const todayUTC = Date.UTC(now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate(), 0, 0, 0, 0);
      let effectiveDateUTC;
      isViewingPastGame = false;

      if (dateString) {
          const parts = dateString.split('-');
          let requestedDateUTC = NaN;
          if (parts.length === 3) {
               const reqYear = parseInt(parts[0]);
               const reqMonth = parseInt(parts[1]) - 1;
               const reqDay = parseInt(parts[2]);
               if (!isNaN(reqYear) && !isNaN(reqMonth) && !isNaN(reqDay)) {
                    requestedDateUTC = Date.UTC(reqYear, reqMonth, reqDay, 0, 0, 0, 0);
               }
          }
          if (!isNaN(requestedDateUTC) && requestedDateUTC <= todayUTC && requestedDateUTC >= startDateUTC) {
              effectiveDateUTC = requestedDateUTC;
              isViewingPastGame = true;
          } else {
              effectiveDateUTC = todayUTC;
              isViewingPastGame = false;
              if (window.history.replaceState) {
                   window.history.replaceState(null, '', window.location.pathname);
              }
          }
      } else {
          effectiveDateUTC = todayUTC;
          isViewingPastGame = false;
      }

      const diffMillis = effectiveDateUTC - startDateUTC;
      dayOffset = diffMillis >= 0 ? Math.floor(diffMillis / (1000 * 60 * 60 * 24)) : -1;
      gameNumber = dayOffset + 1;
      effectiveDate = new Date(effectiveDateUTC);
      const dailyTargetWords = WORDS.filter(word => !word.endsWith('!'));

      if (dailyTargetWords.length === 0) {
           targetWord = "սխալ";
           dayOffset = -1;
           gameNumber = '?';
      } else if (dayOffset < 0) {
           targetWord = "սխալ";
           gameNumber = '?';
      } else {
           targetWord = dailyTargetWords[dayOffset % dailyTargetWords.length];
      }
      parsedTarget = splitWord(targetWord);
      const keyYear = effectiveDate.getUTCFullYear();
      const keyMonth = String(effectiveDate.getUTCMonth() + 1).padStart(2, '0');
      const keyDay = String(effectiveDate.getUTCDate()).padStart(2, '0');
      const effectiveDateStringForKey = `${keyYear}-${keyMonth}-${keyDay}`;
      dateKey = `armenianWordle-${effectiveDateStringForKey}`;
      gameNumberDisplay.textContent = `Խաղ #${gameNumber}`;
      if (isViewingPastGame) {
          gameNumberDisplay.title = `Դիտում եք ${effectiveDateStringForKey} խաղը։ Սեղմեք՝ բացելու պատմությունը։`;
      } else {
          gameNumberDisplay.title = `Սեղմեք՝ տեսնելու անցած խաղերը։`;
      }
  }

  // --- Game State Variables ---
  let guesses = [];
  let currentGuess = [];
  let currentRowIndex = 0;
  let isGameOver = false;
  let messageTimeout;
  let keyStatuses = {};
  let currentLayoutName = localStorage.getItem(LOCAL_STORAGE_LAYOUT_KEY) || 'phonetic';
  let currentLayout = (currentLayoutName === 'phonetic') ? keyboardPhoneticLayout : keyboardAlphabeticalLayout;

  function saveState() {
    const state = { guesses, currentRowIndex, isGameOver, targetWord, keyStatuses };
    localStorage.setItem(dateKey, JSON.stringify(state));
    localStorage.setItem(LOCAL_STORAGE_LAYOUT_KEY, currentLayoutName);
    const todayForHistoryCheck = new Date();
    todayForHistoryCheck.setHours(0, 0, 0, 0);
    const isEffectiveDateToday = effectiveDate.getTime() === todayForHistoryCheck.getTime();
    if (isGameOver && isEffectiveDateToday) {
        try {
            const historyString = localStorage.getItem(LOCAL_STORAGE_HISTORY_KEY);
            let history = historyString ? JSON.parse(historyString) : [];
            if (!Array.isArray(history)) history = [];
            const currentDateString = effectiveDate.toISOString().split('T')[0];
            const currentGameNumber = gameNumber;
            const existingEntryIndex = history.findIndex(entry => entry.date === currentDateString);
            const newEntry = { date: currentDateString, number: currentGameNumber };
            if (existingEntryIndex > -1) history[existingEntryIndex] = newEntry;
            else history.push(newEntry);
            history.sort((a, b) => new Date(b.date) - new Date(a.date));
            localStorage.setItem(LOCAL_STORAGE_HISTORY_KEY, JSON.stringify(history));
        } catch (e) { console.error("Error saving game history:", e); }
    }
  }

  function loadState() {
    const savedTheme = localStorage.getItem('theme') || 'dark';
    document.body.classList.toggle('dark', savedTheme === 'dark');
    toggleBtnTheme.textContent = savedTheme === 'dark' ? '☀️' : '🌗';
    const savedLayoutName = localStorage.getItem(LOCAL_STORAGE_LAYOUT_KEY);
    if (savedLayoutName && LAYOUT_NAMES[savedLayoutName]) currentLayoutName = savedLayoutName;
    else currentLayoutName = 'phonetic';
    currentLayout = (currentLayoutName === 'phonetic') ? keyboardPhoneticLayout : keyboardAlphabeticalLayout;
    toggleBtnLayout.textContent = LAYOUT_NAMES[currentLayoutName];
    document.body.setAttribute('data-keyboard-layout', currentLayoutName);
    const savedStateJSON = localStorage.getItem(dateKey);
    if (savedStateJSON) {
        try {
            const savedState = JSON.parse(savedStateJSON);
            guesses = savedState.guesses || [];
            currentRowIndex = savedState.currentRowIndex || 0;
            isGameOver = savedState.isGameOver || false;
            keyStatuses = savedState.keyStatuses || {};
            for (const key in keyStatuses) {
               if (!['correct', 'present', 'absent', null].includes(keyStatuses[key])) delete keyStatuses[key];
            }
        } catch (e) {
            console.error(`Error loading saved state for ${dateKey}:`, e);
            resetGameState(); isGameOver = false;
        }
    } else {
        resetGameState(); isGameOver = false;
    }
    currentGuess = [];
  }

  function init() {
    const urlParams = new URLSearchParams(window.location.search);
    const dateParam = urlParams.get('date');
    setupDateAndWord(dateParam);
    loadState();
    buildBoard();
    buildKeyboard();
    redrawBoardFromState();
    updateKeyboardHighlight();

    if (isGameOver) {
        disableInput();
        const lastGuessString = guesses.length > 0 ? guesses[guesses.length - 1].map(g => g.letter).join('') : '';
        const wordForMessage = (localStorage.getItem(dateKey) ? JSON.parse(localStorage.getItem(dateKey)).targetWord : null) || targetWord;
        if (splitWord(lastGuessString).join('') === splitWord(wordForMessage).join('')) showMessage('🎉 Հաղթանակ 🎉', 0);
        else showMessage(`Խաղն ավարտված է։ Բառը՝ ${wordForMessage}`, 0);
    } else {
        if (isViewingPastGame) showMessage(`Խաղ #${gameNumber} (${effectiveDate.toISOString().split('T')[0]})`, 3000);
    }
    window.addEventListener('keydown', handlePhysicalKey);
    toggleBtnLayout.addEventListener('click', switchLayout);
    gameNumberDisplay.addEventListener('click', openPastGamesPopup);
    popupCloseButton.addEventListener('click', closePastGamesPopup);
    pastGamesPopup.addEventListener('click', (e) => { if (e.target === pastGamesPopup) closePastGamesPopup(); });
  }

  function resetGameState() { guesses = []; currentGuess = []; currentRowIndex = 0; isGameOver = false; keyStatuses = {}; }

   function splitWord(word) {
    const chars = []; const lowerWord = String(word || '').toLowerCase();
    for (let i = 0; i < lowerWord.length; i++) {
      if (lowerWord[i] === 'ո' && i + 1 < lowerWord.length && lowerWord[i + 1] === 'ւ') { chars.push('ու'); i++; }
      else { chars.push(lowerWord[i]); }
    } return chars;
   }

  function buildBoard() {
    boardElement.innerHTML = '';
    for (let i = 0; i < MAX_ROWS; i++) {
        const row = document.createElement('div'); row.className = 'row';
        for (let j = 0; j < WORD_LENGTH; j++) {
            const tile = document.createElement('div'); tile.className = 'tile'; tile.innerHTML = '<div></div>'; row.appendChild(tile);
        } boardElement.appendChild(row);
    }
  }

  function buildKeyboard() {
    keyboardTopRowElement.innerHTML = ''; keyboardMainGridElement.innerHTML = '';
    [ENTER_KEY, DELETE_KEY].forEach(keyText => {
        const keyElement = document.createElement('button'); keyElement.textContent = keyText; keyElement.className = 'key';
        if (keyText === ENTER_KEY) { keyElement.classList.add('enter'); keyElement.onclick = handleSubmit; }
        else { keyElement.classList.add('delete'); keyElement.onclick = handleDelete; }
        keyboardTopRowElement.appendChild(keyElement);
    });
    currentLayout.forEach(rowKeys => {
        rowKeys.forEach(keyText => {
            const keyElement = document.createElement('button'); keyElement.textContent = keyText; keyElement.className = 'key';
            if (!keyText) { keyElement.classList.add('placeholder'); keyElement.disabled = true; keyElement.style.cursor = 'default'; keyElement.dataset.key = ''; }
            else { keyElement.dataset.key = keyText; keyElement.onclick = () => handleKeyClick(keyText); }
            keyboardMainGridElement.appendChild(keyElement);
        });
    });
    document.body.setAttribute('data-keyboard-layout', currentLayoutName);
  }

    function switchLayout() {
        currentLayoutName = (currentLayoutName === 'phonetic') ? 'alphabetical' : 'phonetic';
        currentLayout = (currentLayoutName === 'phonetic') ? keyboardPhoneticLayout : keyboardAlphabeticalLayout;
        toggleBtnLayout.textContent = LAYOUT_NAMES[currentLayoutName];
        buildKeyboard(); adjustBoardSize(); updateKeyboardHighlight();
        localStorage.setItem(LOCAL_STORAGE_LAYOUT_KEY, currentLayoutName);
    }

  function redrawBoardFromState() {
     const rows = boardElement.querySelectorAll('.row');
     rows.forEach((row, rowIndex) => {
        const tiles = row.querySelectorAll('.tile');
        if (rowIndex < guesses.length) {
             const guessData = guesses[rowIndex];
             tiles.forEach((tile, tileIndex) => {
                const tileInner = tile.querySelector('div'); if (!tileInner) return;
                const letterData = guessData[tileIndex] || { letter: '', status: '' };
                tileInner.textContent = letterData.letter;
                tile.classList.remove('correct', 'present', 'absent', 'filled');
                if (letterData.letter) { tile.classList.add('filled'); if (letterData.status) tile.classList.add(letterData.status); }
             });
        } else {
              tiles.forEach(tile => { const tileInner = tile.querySelector('div'); if (tileInner) tileInner.textContent = ''; tile.classList.remove('correct', 'present', 'absent', 'filled'); });
        }
     });
      if (currentRowIndex < MAX_ROWS && currentRowIndex >= guesses.length) updateCurrentRowDisplay();
  }

  function updateCurrentRowDisplay() {
    if (isGameOver || currentRowIndex >= MAX_ROWS) return;
    const currentRow = boardElement.querySelectorAll('.row')[currentRowIndex]; if (!currentRow) return;
    const tiles = currentRow.querySelectorAll('.tile');
    tiles.forEach((tile, index) => {
        const tileInner = tile.querySelector('div'); if (!tileInner) return;
        const letter = currentGuess[index] || ''; tileInner.textContent = letter;
        if (letter) tile.classList.add('filled'); else tile.classList.remove('filled');
        tile.classList.remove('correct', 'present', 'absent');
    });
  }

  function updateKeyboardHighlight() {
    keyboardElement.querySelectorAll('.key[data-key]').forEach(keyElement => {
        const letter = keyElement.dataset.key; if (!letter) return;
        const cumulativeStatus = keyStatuses[letter];
        keyElement.classList.remove('correct', 'present', 'absent', 'has-present');
        if (cumulativeStatus) keyElement.classList.add(cumulativeStatus);
    });
  }

  function handleKeyClick(key) { if (isGameOver || currentGuess.length >= WORD_LENGTH) return; currentGuess.push(key); updateCurrentRowDisplay(); }
  function handleDelete() { if (isGameOver || currentGuess.length === 0) return; currentGuess.pop(); updateCurrentRowDisplay(); }

  function handleSubmit() {
    if (isGameOver) return;
    if (currentGuess.length !== WORD_LENGTH) { shakeRow(currentRowIndex); showMessage("Անբավարար տառերի քանակ", 1500); return; }
    const guessString = currentGuess.join('');
    const isValidWord = WORDS.includes(guessString) || WORDS.includes(guessString + '!');
    if (!isValidWord) { shakeRow(currentRowIndex); showMessage("Տվյալ բառը մեր բառարանում չկա :(", 1500); return; }
    const result = checkGuess(guessString); guesses.push(result);
    result.forEach(({ letter, status }) => {
        const currentStatus = keyStatuses[letter];
        if (status === 'correct') keyStatuses[letter] = 'correct';
        else if (status === 'present' && currentStatus !== 'correct') keyStatuses[letter] = 'present';
        else if (status === 'absent' && !currentStatus) keyStatuses[letter] = 'absent';
    });
    animateGuessResult(currentRowIndex, result); updateKeyboardHighlight();
    setTimeout(() => {
        currentRowIndex++; currentGuess = [];
        checkWinLoss(guessString); saveState();
    }, WORD_LENGTH * 150 + 300);
  }

  function handlePhysicalKey(e) {
     if (isGameOver) return; let key = e.key;
     if (e.altKey || e.ctrlKey || e.metaKey || key.startsWith('F') || key.length > 1 && !['Backspace', 'Delete', 'Enter'].includes(key)) return;
     key = key.toLowerCase();
     if (key === 'enter') handleSubmit();
     else if (key === 'backspace' || key === 'delete') handleDelete();
     else if (allLetters.includes(key)) handleKeyClick(key);
  }

  function checkGuess(guessString) {
     const guessChars = splitWord(guessString); const result = []; const targetCopy = [...parsedTarget];
     for(let i = 0; i < WORD_LENGTH; i++) result[i] = { letter: guessChars[i], status: '' };
     for (let i = 0; i < WORD_LENGTH; i++) if (guessChars[i] === parsedTarget[i]) { result[i].status = 'correct'; targetCopy[i] = null; }
     for (let i = 0; i < WORD_LENGTH; i++) {
         if (result[i].status === 'correct') continue; const letter = guessChars[i]; const indexInTarget = targetCopy.indexOf(letter);
         if (indexInTarget !== -1) { result[i].status = 'present'; targetCopy[indexInTarget] = null; } else { result[i].status = 'absent'; }
     } return result;
  }

  function checkWinLoss(lastGuessString) {
     if (splitWord(lastGuessString).join('') === parsedTarget.join('')) { showMessage('🎉 Հաղթանակ 🎉', 5000); isGameOver = true; disableInput(); }
     else if (currentRowIndex >= MAX_ROWS) { showMessage(`Պարտություն։ Այսօրվա բառը՝ ${targetWord}`, 0); isGameOver = true; disableInput(); }
  }

  function disableInput() {
     isGameOver = true; window.removeEventListener('keydown', handlePhysicalKey);
     keyboardElement.querySelectorAll('.key').forEach(btn => {
         if (btn.classList.contains('enter') || btn.classList.contains('delete') || btn.dataset.key) { btn.onclick = null; btn.style.cursor = 'default'; }
     });
  }

  function animateGuessResult(rowIndex, result) {
     const row = boardElement.querySelectorAll('.row')[rowIndex]; if (!row) return;
     const tiles = row.querySelectorAll('.tile');
     tiles.forEach((tile, index) => {
         const { letter, status } = result[index]; const tileInner = tile.querySelector('div'); if (!tileInner) return;
         tileInner.textContent = letter; tile.classList.add('filled'); tile.classList.remove('correct', 'present', 'absent');
         setTimeout(() => { if (status) tile.classList.add(status); }, index * 150);
     });
  }

  function shakeRow(rowIndex) {
    const row = boardElement.querySelectorAll('.row')[rowIndex];
    if (row) { row.classList.add('shake'); row.addEventListener('animationend', () => row.classList.remove('shake'), { once: true }); }
  }

   function showMessage(msg, duration = 2000) {
        clearTimeout(messageTimeout); messageElement.textContent = msg; messageElement.classList.add('show');
        if (duration > 0) messageTimeout = setTimeout(() => { messageElement.classList.remove('show'); }, duration);
   }

  toggleBtnTheme.onclick = () => {
    const isDark = document.body.classList.toggle('dark');
    localStorage.setItem('theme', isDark ? 'dark' : 'light');
    toggleBtnTheme.textContent = isDark ? '☀️' : '🌗';
  };

  function openPastGamesPopup() {
      try {
          pastGamesList.innerHTML = '';
          const startYear = parseInt(START_DATE_STRING.substring(0, 4));
          const startMonth = parseInt(START_DATE_STRING.substring(5, 7)) - 1;
          const startDay = parseInt(START_DATE_STRING.substring(8, 10));
          const startDateUTC = Date.UTC(startYear, startMonth, startDay, 0, 0, 0, 0);
          const now = new Date();
          const todayUTC = Date.UTC(now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate(), 0, 0, 0, 0);
          if (isNaN(startDateUTC) || startDateUTC > todayUTC) {
               pastGamesList.innerHTML = `<li>Խաղերը սկսվում են ${START_DATE_STRING}-ից։</li>`;
               pastGamesPopup.style.display = 'flex'; return;
          }
          const todayOffset = Math.floor((todayUTC - startDateUTC) / (1000 * 60 * 60 * 24));
          const todaysGameNumber = todayOffset + 1;
          if (todaysGameNumber < 1) pastGamesList.innerHTML = '<li>Խաղերի ցուցակը ստեղծելիս սխալ։</li>';
          else {
              const items = [];
              for (let i = 1; i <= todaysGameNumber; i++) {
                  const gameOffset = i - 1;
                  const gameDateUTC = startDateUTC + (gameOffset * 1000 * 60 * 60 * 24);
                  const gameDate = new Date(gameDateUTC);
                  const year = gameDate.getUTCFullYear();
                  const month = String(gameDate.getUTCMonth() + 1).padStart(2, '0');
                  const day = String(gameDate.getUTCDate()).padStart(2, '0');
                  const gameDateString = `${year}-${month}-${day}`;
                  const li = document.createElement('li'); const a = document.createElement('a');
                  a.href = `${window.location.pathname}?date=${gameDateString}`;
                  a.textContent = `Խաղ #${i} - ${gameDateString}`; a.title = `Դիտել ${gameDateString} խաղը`;
                  if (effectiveDate && gameDateUTC === effectiveDate.getTime()) a.style.fontWeight = 'bold';
                  li.appendChild(a); items.push(li);
              } items.reverse().forEach(item => pastGamesList.appendChild(item));
          }
          pastGamesPopup.style.display = 'flex';
      } catch (e) {
          console.error("Error generating past games list:", e);
          pastGamesList.innerHTML = '<li>Պատմությունը բեռնելիս սխալ տեղի ունեցավ։</li>';
          pastGamesPopup.style.display = 'flex';
      }
  }

  function closePastGamesPopup() { pastGamesPopup.style.display = 'none'; }

  function adjustBoardSize() {
      if (window.matchMedia("(orientation: landscape) and (max-height: 600px)").matches) {
        const boardContainer = document.querySelector('.board-container');
        if (boardContainer) boardContainer.style.maxWidth = ''; // Let CSS aspect-ratio handle width.
        return;
      }

      const viewportHeight = window.innerHeight;
      // Query from .main-content for portrait default.
      const headerContainer = document.querySelector('.main-content > .header-container');
      const subtitle = document.querySelector('.main-content > .subtitle');
      const keyboard = document.getElementById('keyboard');
      const mainContentEl = document.querySelector('.main-content');
      const boardContainer = document.querySelector('.board-container');

      if (!headerContainer || !subtitle || !keyboard || !boardContainer || !boardElement || !mainContentEl) {
          console.warn("adjustBoardSize (portrait): One or more elements not found.");
          return;
      }

      let nonBoardHeight = 0;
      // In portrait: headerContainer and subtitle are part of .main-content.
      // keyboard is a sibling of .main-content.
      // Total non-board height within viewport = mainContent's top/bottom padding +
      //                                        headerContainer height + subtitle height +
      //                                        boardContainer's top/bottom margin +
      //                                        keyboard height (with its own margins)

      const mainContentStyle = getComputedStyle(mainContentEl);
      nonBoardHeight += parseFloat(mainContentStyle.paddingTop) || 0;
      nonBoardHeight += parseFloat(mainContentStyle.paddingBottom) || 0; // Space at bottom of .main-content

      [headerContainer, subtitle].forEach(el => { // Elements within .main-content affecting board space
          const style = getComputedStyle(el);
          nonBoardHeight += el.offsetHeight;
          nonBoardHeight += parseFloat(style.marginTop) || 0;
          nonBoardHeight += parseFloat(style.marginBottom) || 0;
      });
      
      const boardContainerStyle = getComputedStyle(boardContainer);
      nonBoardHeight += parseFloat(boardContainerStyle.marginTop) || 0;
      nonBoardHeight += parseFloat(boardContainerStyle.marginBottom) || 0;

      const keyboardStyle = getComputedStyle(keyboard); // Keyboard outside .main-content
      nonBoardHeight += keyboard.offsetHeight;
      nonBoardHeight += parseFloat(keyboardStyle.marginTop) || 0;
      nonBoardHeight += parseFloat(keyboardStyle.marginBottom) || 0;


      const availableBoardHeight = viewportHeight - nonBoardHeight;
      const boardStyle = getComputedStyle(boardElement);
      const rowGap = parseFloat(boardStyle.rowGap) || 0;
      const columnGap = parseFloat(boardStyle.columnGap) || 0;
      const buffer = 8; // Small buffer
      const maxTileSizeBasedOnHeight = Math.max(0, (availableBoardHeight - (MAX_ROWS - 1) * rowGap - buffer) / MAX_ROWS);
      const requiredBoardWidthFromHeight = (WORD_LENGTH * maxTileSizeBasedOnHeight) + (WORD_LENGTH - 1) * columnGap;
      
      const tempMaxWidth = boardContainer.style.maxWidth;
      boardContainer.style.maxWidth = ''; // Clear to get CSS max width
      const cssMaxWidthForBoardContainer = parseFloat(getComputedStyle(boardContainer).maxWidth); // default is likely 'none' -> NaN
      const mainContentMaxWidth = parseFloat(mainContentStyle.maxWidth) || Infinity; // max-width of .main-content (550px)

      // Effective max width constraint from CSS for board container is its parent's width if it doesn't have its own.
      // The board-container will fit within .main-content.
      const finalCssMaxWidth = mainContentMaxWidth; 
      boardContainer.style.maxWidth = tempMaxWidth; // Restore if it was set

      const targetWidth = Math.min(requiredBoardWidthFromHeight, finalCssMaxWidth);
      const minReasonableTileSize = 30;
      const minReasonableBoardWidth = (WORD_LENGTH * minReasonableTileSize) + (WORD_LENGTH - 1) * columnGap;

      if (targetWidth > minReasonableBoardWidth && targetWidth > 0) {
          boardContainer.style.maxWidth = `${targetWidth}px`;
      } else {
           boardContainer.style.maxWidth = ''; // Revert to CSS based (e.g. full width of parent)
      }
  }

  document.addEventListener('DOMContentLoaded', () => { init(); adjustBoardSize(); });
  window.addEventListener('resize', adjustBoardSize);
</script>

</body>
</html>
